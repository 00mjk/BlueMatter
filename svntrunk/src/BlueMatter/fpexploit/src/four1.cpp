/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 // Fourier Transform
// "Numerical Recipes in C", isbn 0 521 43108 5
// Keyed in under license.

#include <math.h>
static inline void SWAP(double & a, double & b) {
   double tempr=a ;
   a=b ;
   b=tempr ;
   } ;

extern double sintable[10] ;

void four1(double data[], unsigned int nn, double dsign)
{
   unsigned int n ;
   unsigned int mmax ;
   unsigned int m ;
   unsigned int j ;
   unsigned int istep ;
   unsigned int i ;
   double wtemp ;
   double wr ;
   double wi ;
   double wpr ;
   double wpi ;
   double theta ;
   double tempr ;
   double tempi ;
   unsigned int split ;

   // Butterfly
   n = nn << 1 ;
   j = 1 ;
   for (i=1;i<n ; i+=2)
   {
      if (j>i)
      {
         SWAP(data[j],data[i]) ;
         SWAP(data[j+1],data[i+1]) ;
      } /* endif */
      m = n >> 1 ;
      while (m >= 2 && j > m)
      {
         j -= m ;
         m >>= 1 ;
      } /* endwhile */
      j += m ;
   } /* endfor */

   // Danielson-Lanczos
   mmax = 2 ;
   split = 1 ;
   while (n > mmax)         // --> log2(nn) iterations
   {
      istep = mmax << 1 ;
//      theta = ( isign * 2.0 * M_PI ) / mmax ;
//      wtemp = sin(0.5*theta) ;
      wtemp = sintable [ split ] * dsign ;
      wpr = -2.0 * wtemp * wtemp ;
//      wpi = sin(theta) ;
      wpi = sintable [ split - 1 ] * dsign ;
      split += 1 ;
      wr = 1.0 ;
      wi = 0.0 ;
      for (m=1;m<mmax ; m+=2)          // Split loop, total of nn iterations
      {
         for (i=m;i<=n ;i+=istep )
         {
            j=i+mmax ;
            tempr = wr*data[j]-wi*data[j+1];
            tempi = wr*data[j+1]+wi*data[j];
            data[j]=data[i]-tempr ;
            data[j+1]=data[i+1]-tempi ;
            data[i] += tempr ;
            data[i+1] += tempi ;
         } /* endfor */
         wtemp = wr ;
         wr = wr*wpr - wi *wpi + wr ;
         wi = wi*wpr + wtemp*wpi + wi ;
      } /* endfor */
      mmax = istep ;
   } /* endwhile */
}
