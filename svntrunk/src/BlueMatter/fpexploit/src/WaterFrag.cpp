/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /***************************************************************************
 * Project:         BlueMatter
 *
 * Module:          IPartPair
 *
 * Purpose:         Manage pairwise interactions between irreducible partition pairs
 *                  during NonBonded Interactions, specialised for use when each pair
 *                  is a single water molecule
 *
 *                  Test case for Blue Light compiler. Expectations ...
 *                  1) Inlining will succeed, resulting in exactly 1 generated procedure
 *                  2) 9-way symmetry will be spotted and result in 4 'parallel' + 1 'sequential' ops
 *                  3) Register allocation. Compiles with vacpp suggest that 99 floating-point registers are
 *                     necessary to avoid spills to storage. Blue Light has 64 floating-point registers; so
 *                     target is roughly 35 spills. Maybe some condensing using quadword loads or stores.
 *                  4) 9-way symmetry will eliminate bubbles due to 5-cycle FP arithmetic, where logically possible
 *                  5) store and load instructions for constants and temporaries scheduled so as not to cause
 *                     delays to the FP pipeline (loads too late, stores too soon, or load/store occurring
 *                     together and preventing FP dispatch)
 *
 *
 *
 * Classification:  IBM Internal Use Only
 *
 * History:         010817 TJCW Created from IrreduciblePartitionPair.
 *
 ***************************************************************************/

// This file contains active message infrastructure and nonbonded engine
// thread code.

// Currently, this code does not have an initialization phase.  This leads to
// some extra data in operand packets and also makes it impossible to
// dynamically allocate some of the structures.  These are allocated based
// on a compilte time limit.  THIS CAN ALL BE CHANGED AS WE GO ALONG.

// 'fsel' is a built-in instruction on PPCGR and above, sometimes we want to force its use
#if defined(ARCH_HAS_FSEL)
#include <builtins.h>
#define fsel(a, x, y) __fsel((a),(x),(y))
#else
#define fsel(a, x, y) ( (a) >= 0.0 ? (x) : (y) )
#endif
#include <BlueMatter/fpexploit.hpp>
#include <BlueMatter/watergroup.hpp>
#include <iostream.h>
#include <iomanip.h>

#include <assert.h>
// #include <builtins.h>

extern "builtin" void __compute_parallel(double, double, ...) ;


//static volatile double __simd_target_value[27] ;
//static inline void __simd_target(double X, int Y)
//{
//   __simd_target_value[Y] = X ;
//}
//
//static inline void __simd_target(const XYZ& A, int Y)
//{
//   __simd_target(A.mX,Y) ;
//   __simd_target(A.mY,Y+9) ;
//   __simd_target(A.mZ,Y+18) ;
//}

static inline double NearestImageInPeriodicLine(const double a, const double b, const double c)
{
  double d=b-a ;
  double ad = fabs(d) ;
  double bound = ad+ad-c ;
  double rx = fsel(d, (b-c) , (b+c)) ;
  double result = fsel( bound , rx, b) ;
  return result ;
}

inline
void
NearestImageInPeriodicVolume(const XYZ &PositionA, const XYZ &PositionB, XYZ &Nearest)
  {
  double mX = NearestImageInPeriodicLine(PositionA.mX, PositionB.mX, RTG.mBoundingBoxDimensionVector.mX) ;
  double mY = NearestImageInPeriodicLine(PositionA.mY, PositionB.mY, RTG.mBoundingBoxDimensionVector.mY) ;
  double mZ = NearestImageInPeriodicLine(PositionA.mZ, PositionB.mZ, RTG.mBoundingBoxDimensionVector.mZ) ;
  Nearest.mX = mX ;
  Nearest.mY = mY ;
  Nearest.mZ = mZ ;
  }

class NonbondCutoff
{
   public:
// Plug the required min and max switch radii in here, and the rest will be derived from them
// Also plug in a 'tag atom outer radius', to allow for the possibility of (e.g.) an H-H interaction even
// when the O-O has gone
   static double MinSoft(void) { return 3.1 ; } ;
   static double MaxSoft(void) { return 3.2 ; } ;
   static double MinSoftSquare(void) { return MinSoft()*MinSoft() ; } ;
   static double MaxSoftSquare(void) { return MaxSoft()*MaxSoft() ; } ;
   static double Midpoint(void) { return (MaxSoft() + MinSoft()) * 0.5 ; } ;
   static double Halfrange(void) { return (MaxSoft() - MinSoft()) * 0.5 ; } ;
   static double Scale(void) { return 1.0/Halfrange() ; } ;
   static double Rangescale(double x) { return x*Scale() - Midpoint()*Scale(); } ;
   static double Function(double xu)
   {
     // This is a quintic, which had better vary from 1 to 0 at mincutoff and maxcutoff respectively,
     // and have 0 first and second derivatives at these points.
     // Such a quintic has no other maxima or minima, so we can set it to 1.0 and 0.0 outside the range like this
     double x=Rangescale(xu) ;
     double xx=x*x ;
     double s0=(-3.0/16.0)*xx + (10.0/16.0) ;
     double s1=s0*xx + (-15.0/16) ;
     double s2=s1*x + (8.0/16.0) ;
     // Now wa have the in-range quintic, apply the out-of-range limits
     double candlim=fsel(x, 1.0, 0.0) ;
     double lim=fsel(xx-1.0,candlim,s2) ;
     return lim ;
   } ;
   static double Derivative(double xu)
   {
     // This is a quartic, which had better be 0 and have 0 first derivative at mincutoff and maxcutoff respectively,
     // and be negative between these points.
     double x=Rangescale(xu) ;
     double xx=x*x ;
     double s0=(-15.0*Scale()/16.0)*xx + (30.0*Scale()/16.0) ;
     double s1=s0*xx + (-15.0*Scale()/16.0) ;
     // Now we have the in-range quartic, apply the limit for below-range and above-range
     double lim=fsel(xx-1.0, 0.0, s1) ;
     return lim ;
   } ;
} ;

class GenericMDVM
{
public:
//   double mDummy ;
   void DummyFunction(void) {
      assert(0) ;
      } ;
} ;

class WATERNBVM: public GenericMDVM
{
public:
   XYZ mVector ;
   double mLengthSquared ;
   double mRecipLengthSquared ;
   double mRecipLength ;

   XYZ mForceA ;
   XYZ mForceB ;
   double mEnergy ;
   double mDEDR ;

   WATERNBVM(const XYZ& aVector
            , double aLengthSquared
            , double aRecipLengthSquared
            , double aRecipLength
            )
   {
      mVector=aVector ;
      mLengthSquared=aLengthSquared ;
      mRecipLengthSquared=aRecipLengthSquared ;
      mRecipLength = aRecipLength ;
   } ;
   const XYZ& GetVector(void) const { return mVector ; } ;
   double GetLengthSquared(void) const { return mLengthSquared ; } ;
//   double GetRecipLengthSquared(void) const { return mRecipLengthSquared ; } ;
   double GetRecipLengthSquared(void) const { return mRecipLength*mRecipLength ; } ;
   double GetRecipLength(void) const { return mRecipLength ; } ;

//   void SetForceA(const XYZ& aForce) { mForceA = aForce ; } ;
//   void SetForceB(const XYZ& aForce) { mForceB = aForce ; } ;
//   const XYZ& GetForceA(void) const { return mForceA ; } ;
//   const XYZ& GetForceB(void) const { return mForceB ; } ;
   void SetEnergy(double aEnergy) { mEnergy = aEnergy ; } ;
   double GetEnergy(void) const { return mEnergy ; } ;
   void SetDEDR(double aDEDR) { mDEDR = aDEDR ; } ;
   double GetDEDR(void) { return mDEDR ; } ;
} ;

class UDF_Binding {
   public:
   enum {
      ForceCodeCount = 2
      } ;
    enum
    {
        LennardJonesForce_Code = 0,
        StdChargeForce_Code = 1
    };
    struct LennardJonesForce_Params
    {
        double epsilon;
        double sigma;
    };

    struct StdChargeForce_Params
    {
        double ChargeAxB;
    };
    template <class MDVM> static inline void UDF_Execute(const int Code, MDVM &aMDVM, void *Params)
    {
        switch (Code)
        {
        case LennardJonesForce_Code:
            UDF_LennardJonesForce_Execute(aMDVM, *(LennardJonesForce_Params *)Params);
            break;
        case StdChargeForce_Code:
            UDF_StdChargeForce_Execute(aMDVM, *(StdChargeForce_Params *)Params);
            break;
        default:
            cerr << "UDF_Execute failed - Code " << Code << " not found" << endl;
            assert(0);
            break;
                }
        }



template
<class MDVM, class ParamsType>
static
inline
void
UDF_LennardJonesForce_Execute(MDVM &aMDVM, ParamsType &Params)
  {

  double dVecABMagR = aMDVM.GetRecipLength() ;
  double dVecABMag2R = aMDVM.GetRecipLengthSquared() ;
  double tmp2 = Params.sigma*Params.sigma*dVecABMag2R ;
  double tmp6 = tmp2*tmp2*tmp2 ;
  double tmp12         = tmp6 * tmp6;

  double lje           = Params.epsilon * (tmp12 - 2.0 * tmp6);

  aMDVM.SetEnergy( lje );

  double DEDR =
                (
                  (12.0 * Params.epsilon) *
                  (
                      (  tmp12)
                    - (  tmp6)
                  )
                ) * dVecABMagR;

  aMDVM.SetDEDR( DEDR ) ;

  }

template
<class MDVM, class ParamsType>
static
inline
void
UDF_StdChargeForce_Execute(MDVM &aMDVM, ParamsType &Params)
  {
  // NOTE: This method assumes that distance based cutoffs are handled outside.

  double dVecABMagR = aMDVM.GetRecipLength() ;
  double dVecABMag2R = aMDVM.GetRecipLengthSquared() ;
  double ca         = Params.ChargeAxB * dVecABMagR ;

  double DEDR       = ca * dVecABMagR ;

  aMDVM.SetEnergy( ca );
  aMDVM.SetDEDR(DEDR) ;

  }

   } ;

static const UDF_Binding::LennardJonesForce_Params LJParams_O_O = { 0.1, 0.01 } ;
static const UDF_Binding::LennardJonesForce_Params LJParams_O_H = { 0.1, 0.01 } ;
static const UDF_Binding::LennardJonesForce_Params LJParams_H_H = { 0.1, 0.01 } ;

static const UDF_Binding::StdChargeForce_Params ChParams_O_O = { 0.001 } ;
static const UDF_Binding::StdChargeForce_Params ChParams_O_H = { 0.001 } ;
static const UDF_Binding::StdChargeForce_Params ChParams_H_H = { 0.001 } ;

template<class SourceGroupIF, class TargetGroupIF, class ResultIF, class EnergyIF>
inline void
WaterFragmentPair       ( int           aSimTick,
                          const SourceGroupIF& SourcePartitionElementIF,
                          const TargetGroupIF& TargetPartitionElementIF,
                          ResultIF     &aResultIF,
                          EnergyIF     &aEnergyIF,
                          void       ** aPersistentStatePtr        )
  {

  // Work out appropriate periodic image, and if any atoms in the molecules are close enough to warrant nonbond work
  XYZ GeoCentre_Source = SourcePartitionElementIF.GetGeoCentre() ;
  XYZ GeoCentre_Target = TargetPartitionElementIF.GetGeoCentre() ;
  XYZ Nearest_Target ;
  NearestImageInPeriodicVolume(GeoCentre_Source, GeoCentre_Target, Nearest_Target) ;
  XYZ Vector_GeoCentre = Nearest_Target - GeoCentre_Source ;
  double Radius_Source = SourcePartitionElementIF.GetGeoRadius() ;
  double Radius_Target = TargetPartitionElementIF.GetGeoRadius() ;
  double InLimit = (NonbondCutoff::MaxSoft() - Radius_Source - Radius_Target) ;

  // Fetch the atom positions
  XYZ Position_Source_OX = * SourcePartitionElementIF.GetPositionPtr(0) ;
  XYZ Position_Source_H1 = * SourcePartitionElementIF.GetPositionPtr(1) ;
  XYZ Position_Source_H2 = * SourcePartitionElementIF.GetPositionPtr(2) ;

  XYZ Position_Target_OX = * TargetPartitionElementIF.GetPositionPtr(0) ;
  XYZ Position_Target_H1 = * TargetPartitionElementIF.GetPositionPtr(1) ;
  XYZ Position_Target_H2 = * TargetPartitionElementIF.GetPositionPtr(2) ;

  int TargetIrreduciblePartitionElementId = TargetPartitionElementIF.GetIrreduciblePartitionElementId();
  int SourceIrreduciblePartitionElementId = SourcePartitionElementIF.GetIrreduciblePartitionElementId();

  int SourceFragmentSiteCount = MSD_IF::GetIrreduciblePartitionElementMemberSiteCount( SourceIrreduciblePartitionElementId );
  int TargetFragmentSiteCount = MSD_IF::GetIrreduciblePartitionElementMemberSiteCount( TargetIrreduciblePartitionElementId );

  // assert(3 == SourceFragmentSiteCount ) ;  // Water has 3 atoms
  // assert(3 == TargetFragmentSiteCount ) ;  // Water has 3 atoms

  // Find the nearest image of the oxygen atom
  // XYZ Nearest_Target_OX ;
  // NearestImageInPeriodicVolume(Position_Source_OX, Position_Target_OX, Nearest_Target_OX) ;

  // Translation vector to move target molecule to its nearest image
  // XYZ Translation_To_Nearest = Nearest_Target_OX - Position_Target_OX ;
  XYZ Translation_To_Nearest = Nearest_Target - GeoCentre_Target ;

  // Coherent nearest image of hydrogens
  XYZ Nearest_Target_OX = Position_Target_OX + Translation_To_Nearest ;
  XYZ Nearest_Target_H1 = Position_Target_H1 + Translation_To_Nearest ;
  XYZ Nearest_Target_H2 = Position_Target_H2 + Translation_To_Nearest ;

  // Vectors from source atoms to target atoms
  XYZ Vector_OX_OX = Nearest_Target_OX - Position_Source_OX ;
  XYZ Vector_OX_H1 = Nearest_Target_H1 - Position_Source_OX ;
  XYZ Vector_OX_H2 = Nearest_Target_H2 - Position_Source_OX ;
  XYZ Vector_H1_OX = Nearest_Target_OX - Position_Source_H1 ;
  XYZ Vector_H1_H1 = Nearest_Target_H1 - Position_Source_H1 ;
  XYZ Vector_H1_H2 = Nearest_Target_H2 - Position_Source_H1 ;
  XYZ Vector_H2_OX = Nearest_Target_OX - Position_Source_H2 ;
  XYZ Vector_H2_H1 = Nearest_Target_H1 - Position_Source_H2 ;
  XYZ Vector_H2_H2 = Nearest_Target_H2 - Position_Source_H2 ;

  // Squared lengths of these vectors
  double L2_OX_OX = Vector_OX_OX.LengthSquared() ;
  double L2_OX_H1 = Vector_OX_H1.LengthSquared() ;
  double L2_OX_H2 = Vector_OX_H2.LengthSquared() ;
  double L2_H1_OX = Vector_H1_OX.LengthSquared() ;
  double L2_H1_H1 = Vector_H1_H1.LengthSquared() ;
  double L2_H1_H2 = Vector_H1_H2.LengthSquared() ;
  double L2_H2_OX = Vector_H2_OX.LengthSquared() ;
  double L2_H2_H1 = Vector_H2_H1.LengthSquared() ;
  double L2_H2_H2 = Vector_H2_H2.LengthSquared() ;

  // There are 2 cases where no nonbond forces need computation ...
  // 1) Molecule centres too far apart
  // 2) Same molecule passed as source and target
  // The compiler is free to move these tests around as far as it wants; ideally it would skip
  // as soon as it can, consistent with optimal scheduling of the compute-intensive path.
  if (
      InLimit*InLimit < Vector_GeoCentre.LengthSquared()
      && SourceIrreduciblePartitionElementId != TargetIrreduciblePartitionElementId)
  {
    // Reciprocal lengths of these vectors
    double R_OX_OX = 1.0 / sqrt(L2_OX_OX) ;
    double R_OX_H1 = 1.0 / sqrt(L2_OX_H1) ;
    double R_OX_H2 = 1.0 / sqrt(L2_OX_H2) ;
    double R_H1_OX = 1.0 / sqrt(L2_H1_OX) ;
    double R_H1_H1 = 1.0 / sqrt(L2_H1_H1) ;
    double R_H1_H2 = 1.0 / sqrt(L2_H1_H2) ;
    double R_H2_OX = 1.0 / sqrt(L2_H2_OX) ;
    double R_H2_H1 = 1.0 / sqrt(L2_H2_H1) ;
    double R_H2_H2 = 1.0 / sqrt(L2_H2_H2) ;

    __compute_parallel(
                  R_OX_OX,
                  R_OX_H1,
                  R_OX_H2,
                  R_H1_OX,
                  R_H1_H1,
                  R_H1_H2,
                  R_H2_OX,
                  R_H2_H1,
                  R_H2_H2
                      ) ;
    // Reciprocal square lengths of these vectors
    double R2_OX_OX = R_OX_OX * R_OX_OX ;
    double R2_OX_H1 = R_OX_H1 * R_OX_H1 ;
    double R2_OX_H2 = R_OX_H2 * R_OX_H2 ;
    double R2_H1_OX = R_H1_OX * R_H1_OX ;
    double R2_H1_H1 = R_H1_H1 * R_H1_H1 ;
    double R2_H1_H2 = R_H1_H2 * R_H1_H2 ;
    double R2_H2_OX = R_H2_OX * R_H2_OX ;
    double R2_H2_H1 = R_H2_H1 * R_H2_H1 ;
    double R2_H2_H2 = R_H2_H2 * R_H2_H2 ;

    // MDVM's for each pair

    WATERNBVM VM_OX_OX(Vector_OX_OX, L2_OX_OX, R2_OX_OX, R_OX_OX) ;
    WATERNBVM VM_OX_H1(Vector_OX_H1, L2_OX_H1, R2_OX_H1, R_OX_H1) ;
    WATERNBVM VM_OX_H2(Vector_OX_H2, L2_OX_H2, R2_OX_H2, R_OX_H2) ;
    WATERNBVM VM_H1_OX(Vector_H1_OX, L2_H1_OX, R2_H1_OX, R_H1_OX) ;
    WATERNBVM VM_H1_H1(Vector_H1_H1, L2_H1_H1, R2_H1_H1, R_H1_H1) ;
    WATERNBVM VM_H1_H2(Vector_H1_H2, L2_H1_H2, R2_H1_H2, R_H1_H2) ;
    WATERNBVM VM_H2_OX(Vector_H2_OX, L2_H2_OX, R2_H2_OX, R_H2_OX) ;
    WATERNBVM VM_H2_H1(Vector_H2_H1, L2_H2_H1, R2_H2_H1, R_H2_H1) ;
    WATERNBVM VM_H2_H2(Vector_H2_H2, L2_H2_H2, R2_H2_H2, R_H2_H2) ;

//    double SoftCutoffFunction = ( L2_OX_OX <= NonbondCutoff::MinSoftSquare() )
//                              ? 1.0
//                              : NonbondCutoff::Function(L2_OX_OX * R_OX_OX) ;
//    double SoftCutoffDerivative = ( L2_OX_OX <= NonbondCutoff::MinSoftSquare() )
//                              ? 0.0
//                              : NonbondCutoff::Derivative(L2_OX_OX * R_OX_OX) ;

    // Lennard-Jones forces
    UDF_Binding::UDF_Execute( UDF_Binding::LennardJonesForce_Code, VM_OX_OX, (void *) &LJParams_O_O) ;
    UDF_Binding::UDF_Execute( UDF_Binding::LennardJonesForce_Code, VM_OX_H1, (void *) &LJParams_O_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::LennardJonesForce_Code, VM_OX_H2, (void *) &LJParams_O_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::LennardJonesForce_Code, VM_H1_OX, (void *) &LJParams_O_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::LennardJonesForce_Code, VM_H1_H1, (void *) &LJParams_H_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::LennardJonesForce_Code, VM_H1_H2, (void *) &LJParams_H_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::LennardJonesForce_Code, VM_H2_OX, (void *) &LJParams_O_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::LennardJonesForce_Code, VM_H2_H1, (void *) &LJParams_H_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::LennardJonesForce_Code, VM_H2_H2, (void *) &LJParams_H_H) ;

    // Pull out the LJ's to make room for the charge-charge forces
    double LJDEDR_OX_OX = VM_OX_OX.GetDEDR() ;
    double LJDEDR_H1_OX = VM_H1_OX.GetDEDR() ;
    double LJDEDR_H2_OX = VM_H2_OX.GetDEDR() ;
    double LJDEDR_OX_H1 = VM_OX_H1.GetDEDR() ;
    double LJDEDR_H1_H1 = VM_H1_H1.GetDEDR() ;
    double LJDEDR_H2_H1 = VM_H2_H1.GetDEDR() ;
    double LJDEDR_OX_H2 = VM_OX_H2.GetDEDR() ;
    double LJDEDR_H1_H2 = VM_H1_H2.GetDEDR() ;
    double LJDEDR_H2_H2 = VM_H2_H2.GetDEDR() ;
    double LJEnergy_OX_OX = VM_OX_OX.GetEnergy() ;
    double LJEnergy_H1_OX = VM_H1_OX.GetEnergy() ;
    double LJEnergy_H2_OX = VM_H2_OX.GetEnergy() ;
    double LJEnergy_OX_H1 = VM_OX_H1.GetEnergy() ;
    double LJEnergy_H1_H1 = VM_H1_H1.GetEnergy() ;
    double LJEnergy_H2_H1 = VM_H2_H1.GetEnergy() ;
    double LJEnergy_OX_H2 = VM_OX_H2.GetEnergy() ;
    double LJEnergy_H1_H2 = VM_H1_H2.GetEnergy() ;
    double LJEnergy_H2_H2 = VM_H2_H2.GetEnergy() ;

    // Charge forces
    UDF_Binding::UDF_Execute( UDF_Binding::StdChargeForce_Code, VM_OX_OX, (void *) &ChParams_O_O) ;
    UDF_Binding::UDF_Execute( UDF_Binding::StdChargeForce_Code, VM_OX_H1, (void *) &ChParams_O_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::StdChargeForce_Code, VM_OX_H2, (void *) &ChParams_O_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::StdChargeForce_Code, VM_H1_OX, (void *) &ChParams_O_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::StdChargeForce_Code, VM_H1_H1, (void *) &ChParams_H_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::StdChargeForce_Code, VM_H1_H2, (void *) &ChParams_H_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::StdChargeForce_Code, VM_H2_OX, (void *) &ChParams_O_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::StdChargeForce_Code, VM_H2_H1, (void *) &ChParams_H_H) ;
    UDF_Binding::UDF_Execute( UDF_Binding::StdChargeForce_Code, VM_H2_H2, (void *) &ChParams_H_H) ;

    double ChDEDR_OX_OX = VM_OX_OX.GetDEDR() ;
    double ChDEDR_H1_OX = VM_H1_OX.GetDEDR() ;
    double ChDEDR_H2_OX = VM_H2_OX.GetDEDR() ;
    double ChDEDR_OX_H1 = VM_OX_H1.GetDEDR() ;
    double ChDEDR_H1_H1 = VM_H1_H1.GetDEDR() ;
    double ChDEDR_H2_H1 = VM_H2_H1.GetDEDR() ;
    double ChDEDR_OX_H2 = VM_OX_H2.GetDEDR() ;
    double ChDEDR_H1_H2 = VM_H1_H2.GetDEDR() ;
    double ChDEDR_H2_H2 = VM_H2_H2.GetDEDR() ;
    double ChEnergy_OX_OX = VM_OX_OX.GetEnergy() ;
    double ChEnergy_H1_OX = VM_H1_OX.GetEnergy() ;
    double ChEnergy_H2_OX = VM_H2_OX.GetEnergy() ;
    double ChEnergy_OX_H1 = VM_OX_H1.GetEnergy() ;
    double ChEnergy_H1_H1 = VM_H1_H1.GetEnergy() ;
    double ChEnergy_H2_H1 = VM_H2_H1.GetEnergy() ;
    double ChEnergy_OX_H2 = VM_OX_H2.GetEnergy() ;
    double ChEnergy_H1_H2 = VM_H1_H2.GetEnergy() ;
    double ChEnergy_H2_H2 = VM_H2_H2.GetEnergy() ;

//  XYZ Force_OX = VM_OX_OX.GetForceA() + VM_OX_H1.GetForceA() + VM_OX_H2.GetForceA() ;
//  XYZ Force_H1 = VM_H1_OX.GetForceA() + VM_H1_H1.GetForceA() + VM_H1_H2.GetForceA() ;
//  XYZ Force_H2 = VM_H2_OX.GetForceA() + VM_H2_H1.GetForceA() + VM_H2_H2.GetForceA() ;

// Switch function and derivative for soft cutoff
    double Switch_OX_OX = NonbondCutoff::Function(L2_OX_OX * R_OX_OX) ;
    double Switch_OX_H1 = NonbondCutoff::Function(L2_OX_H1 * R_OX_H1) ;
    double Switch_OX_H2 = NonbondCutoff::Function(L2_OX_H2 * R_OX_H2) ;
    double Switch_H1_OX = NonbondCutoff::Function(L2_H1_OX * R_H1_OX) ;
    double Switch_H1_H1 = NonbondCutoff::Function(L2_H1_H1 * R_H1_H1) ;
    double Switch_H1_H2 = NonbondCutoff::Function(L2_H1_H2 * R_H1_H2) ;
    double Switch_H2_OX = NonbondCutoff::Function(L2_H2_OX * R_H2_OX) ;
    double Switch_H2_H1 = NonbondCutoff::Function(L2_H2_H1 * R_H2_H1) ;
    double Switch_H2_H2 = NonbondCutoff::Function(L2_H2_H2 * R_H2_H2) ;

    __compute_parallel(
                  Switch_OX_OX,
                  Switch_OX_H1,
                  Switch_OX_H2,
                  Switch_H1_OX,
                  Switch_H1_H1,
                  Switch_H1_H2,
                  Switch_H2_OX,
                  Switch_H2_H1,
                  Switch_H2_H2
                      ) ;

    double Derivative_OX_OX = NonbondCutoff::Derivative(L2_OX_OX * R_OX_OX) ;
    double Derivative_OX_H1 = NonbondCutoff::Derivative(L2_OX_H1 * R_OX_H1) ;
    double Derivative_OX_H2 = NonbondCutoff::Derivative(L2_OX_H2 * R_OX_H2) ;
    double Derivative_H1_OX = NonbondCutoff::Derivative(L2_H1_OX * R_H1_OX) ;
    double Derivative_H1_H1 = NonbondCutoff::Derivative(L2_H1_H1 * R_H1_H1) ;
    double Derivative_H1_H2 = NonbondCutoff::Derivative(L2_H1_H2 * R_H1_H2) ;
    double Derivative_H2_OX = NonbondCutoff::Derivative(L2_H2_OX * R_H2_OX) ;
    double Derivative_H2_H1 = NonbondCutoff::Derivative(L2_H2_H1 * R_H2_H1) ;
    double Derivative_H2_H2 = NonbondCutoff::Derivative(L2_H2_H2 * R_H2_H2) ;

    __compute_parallel(
                  Derivative_OX_OX,
                  Derivative_OX_H1,
                  Derivative_OX_H2,
                  Derivative_H1_OX,
                  Derivative_H1_H1,
                  Derivative_H1_H2,
                  Derivative_H2_OX,
                  Derivative_H2_H1,
                  Derivative_H2_H2
                      ) ;

    double EnergyLJ_OX_OX = LJEnergy_OX_OX*Switch_OX_OX ;
    double EnergyLJ_OX_H1 = LJEnergy_OX_H1*Switch_OX_H1 ;
    double EnergyLJ_OX_H2 = LJEnergy_OX_H2*Switch_OX_H2 ;
    double EnergyLJ_H1_OX = LJEnergy_H1_OX*Switch_H1_OX ;
    double EnergyLJ_H1_H1 = LJEnergy_H1_H1*Switch_H1_H1 ;
    double EnergyLJ_H1_H2 = LJEnergy_H1_H2*Switch_H1_H2 ;
    double EnergyLJ_H2_OX = LJEnergy_H2_OX*Switch_H2_OX ;
    double EnergyLJ_H2_H1 = LJEnergy_H2_H1*Switch_H2_H1 ;
    double EnergyLJ_H2_H2 = LJEnergy_H2_H2*Switch_H2_H2 ;

    __compute_parallel(
                  EnergyLJ_OX_OX,
                  EnergyLJ_OX_H1,
                  EnergyLJ_OX_H2,
                  EnergyLJ_H1_OX,
                  EnergyLJ_H1_H1,
                  EnergyLJ_H1_H2,
                  EnergyLJ_H2_OX,
                  EnergyLJ_H2_H1,
                  EnergyLJ_H2_H2
                  ) ;

    // Apply the energy for LJ
    double Energy_LJ =
    0.5 *
     ( EnergyLJ_OX_OX
     + EnergyLJ_OX_H1
     + EnergyLJ_OX_H2
     + EnergyLJ_H1_OX
     + EnergyLJ_H1_H1
     + EnergyLJ_H1_H2
     + EnergyLJ_H2_OX
     + EnergyLJ_H2_H1
     + EnergyLJ_H2_H2 ) ;


    // Apply the energy for Charge
    double EnergyCh_OX_OX = ChEnergy_OX_OX*Switch_OX_OX ;
    double EnergyCh_OX_H1 = ChEnergy_OX_H1*Switch_OX_H1 ;
    double EnergyCh_OX_H2 = ChEnergy_OX_H2*Switch_OX_H2 ;
    double EnergyCh_H1_OX = ChEnergy_H1_OX*Switch_H1_OX ;
    double EnergyCh_H1_H1 = ChEnergy_H1_H1*Switch_H1_H1 ;
    double EnergyCh_H1_H2 = ChEnergy_H1_H2*Switch_H1_H2 ;
    double EnergyCh_H2_OX = ChEnergy_H2_OX*Switch_H2_OX ;
    double EnergyCh_H2_H1 = ChEnergy_H2_H1*Switch_H2_H1 ;
    double EnergyCh_H2_H2 = ChEnergy_H2_H2*Switch_H2_H2 ;

    __compute_parallel(
                  EnergyCh_OX_OX,
                  EnergyCh_OX_H1,
                  EnergyCh_OX_H2,
                  EnergyCh_H1_OX,
                  EnergyCh_H1_H1,
                  EnergyCh_H1_H2,
                  EnergyCh_H2_OX,
                  EnergyCh_H2_H1,
                  EnergyCh_H2_H2
                  ) ;

    double Energy_Ch =
    0.5 *
     ( EnergyCh_OX_OX
     + EnergyCh_OX_H1
     + EnergyCh_OX_H2
     + EnergyCh_H1_OX
     + EnergyCh_H1_H1
     + EnergyCh_H1_H2
     + EnergyCh_H2_OX
     + EnergyCh_H2_H1
     + EnergyCh_H2_H2 ) ;

    // Compute the 'net' derivatives
    double Net_DEDR_OX_OX = (LJDEDR_OX_OX+ChDEDR_OX_OX)*Switch_OX_OX + (LJEnergy_OX_OX+ChEnergy_OX_OX)*Derivative_OX_OX ;
    double Net_DEDR_H1_OX = (LJDEDR_H1_OX+ChDEDR_H1_OX)*Switch_H1_OX + (LJEnergy_H1_OX+ChEnergy_H1_OX)*Derivative_H1_OX ;
    double Net_DEDR_H2_OX = (LJDEDR_H2_OX+ChDEDR_H2_OX)*Switch_H2_OX + (LJEnergy_H2_OX+ChEnergy_H2_OX)*Derivative_H2_OX ;
    double Net_DEDR_OX_H1 = (LJDEDR_OX_H1+ChDEDR_OX_H1)*Switch_OX_H1 + (LJEnergy_OX_H1+ChEnergy_OX_H1)*Derivative_OX_H1 ;
    double Net_DEDR_H1_H1 = (LJDEDR_H1_H1+ChDEDR_H1_H1)*Switch_H1_H1 + (LJEnergy_H1_H1+ChEnergy_H1_H1)*Derivative_H1_H1 ;
    double Net_DEDR_H2_H1 = (LJDEDR_H2_H1+ChDEDR_H2_H1)*Switch_H2_H1 + (LJEnergy_H2_H1+ChEnergy_H2_H1)*Derivative_H2_H1 ;
    double Net_DEDR_OX_H2 = (LJDEDR_OX_H2+ChDEDR_OX_H2)*Switch_OX_H2 + (LJEnergy_OX_H2+ChEnergy_OX_H2)*Derivative_OX_H2 ;
    double Net_DEDR_H1_H2 = (LJDEDR_H1_H2+ChDEDR_H1_H2)*Switch_H1_H2 + (LJEnergy_H1_H2+ChEnergy_H1_H2)*Derivative_H1_H2 ;
    double Net_DEDR_H2_H2 = (LJDEDR_H2_H2+ChDEDR_H2_H2)*Switch_H2_H2 + (LJEnergy_H2_H2+ChEnergy_H2_H2)*Derivative_H2_H2 ;

    // Apply the pairwise forces, accounting for switch function
    XYZ Force_OX_OX = Vector_OX_OX*(Net_DEDR_OX_OX*R_OX_OX) ;
    XYZ Force_H1_OX = Vector_H1_OX*(Net_DEDR_H1_OX*R_H1_OX) ;
    XYZ Force_H2_OX = Vector_H2_OX*(Net_DEDR_H2_OX*R_H2_OX) ;
    XYZ Force_OX_H1 = Vector_OX_H1*(Net_DEDR_OX_H1*R_OX_H1) ;
    XYZ Force_H1_H1 = Vector_H1_H1*(Net_DEDR_H1_H1*R_H1_H1) ;
    XYZ Force_H2_H1 = Vector_H2_H1*(Net_DEDR_H2_H1*R_H2_H1) ;
    XYZ Force_OX_H2 = Vector_OX_H2*(Net_DEDR_OX_H2*R_OX_H2) ;
    XYZ Force_H1_H2 = Vector_H1_H2*(Net_DEDR_H1_H2*R_H1_H2) ;
    XYZ Force_H2_H2 = Vector_H2_H2*(Net_DEDR_H2_H2*R_H2_H2) ;

    __compute_parallel(
               Force_OX_OX.mX,
               Force_H1_OX.mX,
               Force_H2_OX.mX,
               Force_OX_H1.mX,
               Force_H1_H1.mX,
               Force_H2_H1.mX,
               Force_OX_H2.mX,
               Force_H1_H2.mX,
               Force_H2_H2.mX,
               Force_OX_OX.mY,
               Force_H1_OX.mY,
               Force_H2_OX.mY,
               Force_OX_H1.mY,
               Force_H1_H1.mY,
               Force_H2_H1.mY,
               Force_OX_H2.mY,
               Force_H1_H2.mY,
               Force_H2_H2.mY,
               Force_OX_OX.mZ,
               Force_H1_OX.mZ,
               Force_H2_OX.mZ,
               Force_OX_H1.mZ,
               Force_H1_H1.mZ,
               Force_H2_H1.mZ,
               Force_OX_H2.mZ,
               Force_H1_H2.mZ,
               Force_H2_H2.mZ
    ) ;

    XYZ Force_OX = Force_OX_OX+Force_OX_H1+Force_OX_H2 ;
    XYZ Force_H1 = Force_H1_OX+Force_H1_H1+Force_H1_H2 ;
    XYZ Force_H2 = Force_H2_OX+Force_H2_H1+Force_H2_H2 ;

//  aEnergyIF.AddEnergy( UDF_Binding::StdChargeForce_Code, Energy_Ch ) ;
//  aEnergyIF.AddEnergy( UDF_Binding::LennardJonesForce_Code, Energy_LJ ) ;
    aEnergyIF.AddEnergies( Energy_LJ, Energy_Ch ) ;

//    aResultIF.AddForce(0,Force_OX) ;
//    aResultIF.AddForce(1,Force_H1) ;
//    aResultIF.AddForce(2,Force_H2) ;
    aResultIF.AddForce3(Force_OX,Force_H1,Force_H2) ;

    } /* endif */

  }
//******************************

void op_water_water(const WaterGroup& SourceGroup
                  , const WaterGroup& TargetGroup
                  , Result& aResult
                  , Energy& aEnergy
                  , int SimTick
                  , void** PersistentStatePointer
                  )
{
   WaterFragmentPair<WaterGroup,WaterGroup,Result,Energy> (
     SimTick
    ,SourceGroup
    ,TargetGroup
    ,aResult
    ,aEnergy
    ,PersistentStatePointer
    ) ;

}

XYZ RunTimeGlobals::mBoundingBoxDimensionVector={10.0, 10.0, 10.0} ;
int MSD_IF::mIrreduciblePartitionElementMemberSiteCount[] = { 3, 3, 3, 3 } ;

void WriteForce(double& csum, const Result& R)
{
  csum += R.mForce0.mX + R.mForce0.mY + R.mForce0.mZ
        + R.mForce1.mX + R.mForce1.mY + R.mForce1.mZ
        + R.mForce2.mX + R.mForce2.mY + R.mForce2.mZ ;
}

void WriteEnergy(double& csum, const Energy& E)
{
  csum += E.LJEnergy + E.ChEnergy ;
}

extern "C" { int wmain(void) ; } ;

int wmain(void)
{
   WaterGroup WaterVector[] = {
         { 0, {0.0, 0.0, 0.0}, 1.0,
                                  { {0.0, 0.0, 0.0},
                                    {0.0, 1.0, 0.0},
                                    {0.0, 0.0, 1.0} } }
        ,{ 1, {1.0, 1.0, 0.0}, 1.0,
                                  { {1.0, 1.0, 0.0},
                                    {1.0, 2.0, 0.0},
                                    {1.0, 1.0, 1.0} } }
        ,{ 2, {2.0, 1.0, 0.0}, 1.0,
                                  { {2.0, 1.0, 0.0},
                                    {2.0, 2.0, 0.0},
                                    {2.0, 1.0, 1.0} } }
        ,{ 3, {3.0, 0.0, 0.0}, 1.0,
                                  { {3.0, 0.0, 0.0},
                                    {3.0, 1.0, 0.0},
                                    {3.0, 0.0, 1.0} } }
                              }      ;

  Energy E= { 0.0, 0.0 } ;

  double csum=0.0 ;
  for (int sourceindex=0; sourceindex<4; sourceindex+=1)
  {
     Result R={ { 0.0, 0.0, 0.0 }
               ,{ 0.0, 0.0, 0.0 }
               ,{ 0.0, 0.0, 0.0 } } ;
     for (int targetindex=0; targetindex<4; targetindex+=1)
     {
        op_water_water(WaterVector[sourceindex]
                      ,WaterVector[targetindex]
                      ,R,E,0,NULL) ;
     } /* endfor */
     WriteForce(csum,R) ;
  } /* endfor */
  WriteEnergy(csum,E) ;

  return (csum >= 0.0 ? 0 : 1) ;
}

/*
  int main(void)
  {
     return wmain() ;
  }
*/
