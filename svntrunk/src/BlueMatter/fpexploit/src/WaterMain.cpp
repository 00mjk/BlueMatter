/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include <BlueMatter/fpexploit.hpp>
#include <BlueMatter/watergroup.hpp>
// #define WRITEOUT
#if defined(WRITEOUT)
#include <iostream.h>
#endif
XYZ RunTimeGlobals::mBoundingBoxDimensionVector={10.0, 10.0, 10.0} ;
int MSD_IF::mIrreduciblePartitionElementMemberSiteCount[] = { 3, 3, 3, 3 } ;

void WriteForce(double& csum, const Result& R)
{
#if defined(WRITEOUT)
  cout << '(' << R.mForce0.mX
       << ',' << R.mForce0.mY
       << ',' << R.mForce0.mZ
       << "),(" << R.mForce1.mX
       << ',' << R.mForce1.mY
       << ',' << R.mForce1.mZ
       << "),(" << R.mForce2.mX
       << ',' << R.mForce2.mY
       << ',' << R.mForce2.mZ
       << ")\n" ;
#endif
  csum += R.mForce0.mX + R.mForce0.mY + R.mForce0.mZ
        + R.mForce1.mX + R.mForce1.mY + R.mForce1.mZ
        + R.mForce2.mX + R.mForce2.mY + R.mForce2.mZ ;
}

void WriteEnergy(double& csum, const Energy& E)
{
#if defined(WRITEOUT)
   cout << "LJ=" << E.LJEnergy
        << " Charge=" << E.ChEnergy
        << '\n' ;
#endif
  csum += E.LJEnergy + E.ChEnergy ;
}

int main(void)
{
   WaterGroup WaterVector[] = {
         { 0, {0.0, 0.0, 0.0}, 1.0,
                                  { {0.0, 0.0, 0.0},
                                    {0.0, 1.0, 0.0},
                                    {0.0, 0.0, 1.0} } }
        ,{ 1, {1.0, 1.0, 0.0}, 1.0,
                                  { {1.0, 1.0, 0.0},
                                    {1.0, 2.0, 0.0},
                                    {1.0, 1.0, 1.0} } }
        ,{ 2, {2.0, 1.0, 0.0}, 1.0,
                                  { {2.0, 1.0, 0.0},
                                    {2.0, 2.0, 0.0},
                                    {2.0, 1.0, 1.0} } }
        ,{ 3, {3.0, 0.0, 0.0}, 1.0,
                                  { {3.0, 0.0, 0.0},
                                    {3.0, 1.0, 0.0},
                                    {3.0, 0.0, 1.0} } }
                              }      ;

  Energy E= { 0.0, 0.0 } ;

  double csum=0.0 ;
  for (int sourceindex=0; sourceindex<4; sourceindex+=1)
  {
    Result R={ { 0.0, 0.0, 0.0 }
              ,{ 0.0, 0.0, 0.0 }
              ,{ 0.0, 0.0, 0.0 } } ;
     for (int targetindex=0; targetindex<4; targetindex+=1)
     {
        op_water_water(WaterVector[sourceindex]
                      ,WaterVector[targetindex]
                      ,R,E,0,NULL) ;
     } /* endfor */
     WriteForce(csum,R) ;
  } /* endfor */
  WriteEnergy(csum,E) ;

  return (csum >= 0.0 ? 0 : 1) ;
}
