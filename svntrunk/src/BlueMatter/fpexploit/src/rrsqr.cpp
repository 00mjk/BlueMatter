/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Reciprocal and reciprocal square root, the way Double Hummer does it
 */
#include <math.h>
#include <stdio.h>
#include <builtins.h>
#include <iostream.h>
#include <iomanip.h>


/*
 * Tables for offsets and exponents for piecewise-linear approximations in hardware
 * (Thanks to Robert Goldiez and Ken Dockser)
 */
int slope_table_rsqrt[2][32] = {
   {
0x7d1  , 0x778  , 0x725  , 0x6d8  , 0x691  , 0x64e  , 0x610  , 0x5d5  ,
0x59e  , 0x56a  , 0x53a  , 0x50c  , 0x4e0  , 0x4b8  , 0x491  , 0x46c  ,
0x449  , 0x428  , 0x409  , 0x7d6  , 0x79d  , 0x766  , 0x732  , 0x701  ,
0x6d1  , 0x6a4  , 0x679  , 0x64f  , 0x627  , 0x601  , 0x5dc  , 0x5b9
  },
  {
0x587  , 0x548  , 0x50d  , 0x4d7  , 0x4a4  , 0x475  , 0x449  , 0x420  ,
0x7f2  , 0x7a9  , 0x764  , 0x723  , 0x6e6  , 0x6ac  , 0x675  , 0x641  ,
0x610  , 0x5e1  , 0x5b5  , 0x58a  , 0x562  , 0x53b  , 0x517  , 0x4f4  ,
0x4d2  , 0x4b2  , 0x493  , 0x476  , 0x45a  , 0x43f  , 0x425  , 0x40c
}
  } ;

int slope_exponent_table_rsqrt[2][32] = {
   {
0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 ,
0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 ,
0-2 , 0-2 , 0-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 ,
-1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2
   },
   {
-1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 ,
-2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 ,
-2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 ,
-2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2
  }

   } ;
int offset_table_rsqrt[2][32] = {
   {
0xbe86 , 0xbba8 , 0xb8e6 , 0xb644 , 0xb3c5 , 0xb15a , 0xaf0d , 0xaccd ,
0xaaa7 , 0xa892 , 0xa69a , 0xa4ac , 0xa2c7 , 0xa105 , 0x9f45 , 0x9d92 ,
0x9bee , 0x9a5a , 0x98d6 , 0x9757 , 0x95e5 , 0x9478 , 0x9319 , 0x91c8 ,
0x9078 , 0x8f38 , 0x8e00 , 0x8cca , 0x8b9e , 0x8a7c , 0x895d , 0x884a
  }, {
0x86b9 , 0x84b1 , 0x82bc , 0x80e3 , 0xfe31 , 0xfacb , 0xf786 , 0xf467 ,
0xf15b , 0xee6f , 0xeb9a , 0xe8df , 0xe640 , 0xe3b4 , 0xe13b , 0xded8 ,
0xdc8c , 0xda4c , 0xd826 , 0xd602 , 0xd3fa , 0xd1f5 , 0xd00f , 0xce2d ,
0xcc51 , 0xca89 , 0xc8c8 , 0xc71c , 0xc578 , 0xc3dc , 0xc249 , 0xc0bf

  }
   } ;

int offset_exponent_table_rsqrt[2][32] = {
   {
-0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 ,
-0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 ,
-0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 ,
-0 , -0 , -0 , -0 , -0 , -0 , -0 , -0
   }, {
-0 , -0 , -0 , -0 , -1 , -1 , -1 , -1 ,
-1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ,
-1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ,
-1 , -1 , -1 , -1 , -1 , -1 , -1 , -1
  }
   } ;

int slope_table_recip[32] = {
0xf83 , 0xe9a , 0xdc4 , 0xd00 , 0xc4c , 0xba7 , 0xb0e , 0xa80 ,
0x9fd , 0x983 , 0x912 , 0x8a8 , 0x846 , 0xfd4 , 0xf28 , 0xe86 ,
0xdee , 0xd5f , 0xcd9 , 0xc5b , 0xbe3 , 0xb73 , 0xb08 , 0xaa3 ,
0xa44 , 0x9e9 , 0x993 , 0x941 , 0x8f3 , 0x8aa , 0x863 , 0x820

   } ;
int slope_exponent_table_recip[32] = {
-1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ,
-1 , -1 , -1 , -1 , -1 , -2 , -2 , -2 ,
-2 , -2 , -2 , -2 , -2 , -2 , -2 , -2 ,
-2 , -2 , -2 , -2 , -2 , -2 , -2 , -2

   } ;

int offset_table_recip[32] = {
 0xfc142 , 0xf4920 , 0xed773 , 0xe6c45 , 0xe0705 , 0xda7a2 , 0xd4ccc , 0xcf646 ,
 0xca466 , 0xc563e , 0xc0c15 , 0xbc4dd , 0xb817c , 0xb40cc , 0xb02fd , 0xac782 ,
 0xa8e82 , 0xa57c4 , 0xa236b , 0x9f137 , 0x9c077 , 0x99217 , 0x964f4 , 0x9398d ,
 0x90ffd , 0x8e777 , 0x8c07f , 0x89ab3 , 0x87622 , 0x85357 , 0x830f3 , 0x80ff8
   } ;


/*
 * Methods for picking apart and rebuilding double-precision floating point
 * numbers in IEEE representation.
 * (Only intended to handle 'well-behaved' numbers)
 */
class doublemap
{
  public:
  class uintpair
  {
     public:
    unsigned int m_hi ;
    unsigned int m_lo ;
  } ;
   union {
      double m_d ;
      uintpair m_u ;
      } m_value ;
  doublemap(double X) { m_value.m_d = X ; } ;
  doublemap(
    unsigned int Xsign ,   // 0 for positive, 1 for negative
    unsigned int Xexponent ,
    unsigned int Xsignificand_hi ,  // The 0x00100000 bit had better be set, to get the right answer
    unsigned int Xsignificand_lo
    ) {
       m_value.m_u.m_hi = ( ( Xsign << 31 )                & 0x80000000 )
                        | ( ( (Xexponent + 1023 )  << 20 ) & 0x7ff00000 )
                        | ( Xsignificand_hi                & 0x000fffff ) ;
       m_value.m_u.m_lo = Xsignificand_lo ;
   } ;
  doublemap(long Xh, long Xl) { m_value.m_u.m_hi = Xh; m_value.m_u.m_lo = Xl ; } ;
  double get_value(void) const { return m_value.m_d ; } ;

  unsigned int hiword(void) const { return m_value.m_u.m_hi ; } ;
  unsigned int loword(void) const { return m_value.m_u.m_lo ; } ;

  unsigned int sign_bit(void) const { return hiword() >> 31 ; } ;
  unsigned int exponent_bits(void) const { return hiword() & 0x7ff00000 ; } ;
  unsigned int significand_hi_bits(void) const { return hiword() & 0x000fffff ; } ;
  unsigned int significand_lo_bits(void) const { return loword() ; } ;

  int exponent(void) const { return ( exponent_bits() >> 20 ) - 1023 ; } ;
  unsigned int significand_hi(void) const { return significand_hi_bits() | 0x00100000 ; } ;
  unsigned int significand_lo(void) const { return significand_lo_bits() ; } ;
  bool is_negative(void) const { return  0 != sign_bit() ; } ;
} ;

double dInf = 1.0/0.0 ;
double dNaN = 1.0/sqrt(-1.0) ;

/*
 * Algorithms in the hardware for 'fres' and 'frsqrte' (at least, for the parallel versions)
 */
double estimate_reciprocal_square_root(double X)
{
   /*
    * Special cases of X <= 0.0 give non-represented numbers
    */
   if (X < 0.0 )
   {
      return dNaN ;
   }
   else if ( X == 0.0 )
   {
      return dInf ;
   } /* endif */
   /*
    * Normal case of X > 0.0
    */
   doublemap in_map(X) ;
   int in_exponent = in_map.exponent() ;
   int in_exponent_lobit = in_exponent & 1 ;
   int in_exponent_half = in_exponent >> 1 ;
   unsigned int in_index = ( in_map.significand_hi() >> 15 ) & 0x1f ; // in_index should be in (0,31)
   // The input value is trucated to 21 bits of precision (including the implied leading 1)
   doublemap mid_map(0,in_exponent_lobit,in_map.significand_hi(),0) ;  // mid_map should be in (1,4), truncate to 21 bits of precision

   int slope_significand = slope_table_rsqrt[in_exponent_lobit][in_index] ;
   int slope_exponent = slope_exponent_table_rsqrt[in_exponent_lobit][in_index] ;

   int offset_significand = offset_table_rsqrt[in_exponent_lobit][in_index] ;
   int offset_exponent    = offset_exponent_table_rsqrt[in_exponent_lobit][in_index] ;

   doublemap slope(1,slope_exponent,slope_significand << 10,0) ;
   doublemap offset(0,offset_exponent,offset_significand << 5, 0) ;

   doublemap mid_result(mid_map.get_value() * slope.get_value() + offset.get_value() ) ;

   int mid_exponent = mid_result.exponent() ;

   int out_exponent = mid_exponent - in_exponent_half ;
   // The output value is truncated to 24 bits of precision (including the implied leading 1)
   doublemap out_result(0, out_exponent,mid_result.significand_hi(),mid_result.significand_lo() & 0xe0000000 ) ; // truncation of result
   // doublemap out_result(0, out_exponent,mid_result.significand_hi(),mid_result.significand_lo() ) ;  // non-truncated version
   double result = out_result.get_value() ;

   /*
    * Diagnosis, compare the lookup values with the analytic values
    */
//   printf("in-exponent %d in-index %d\n",in_exponent, in_index) ;
//   printf("Calculating %0.17e * %0.17e + %0.17e\n",mid_map.get_value(),slope.get_value(),offset.get_value()) ;
//   printf("Giving %0.17e\n",mid_result.get_value()) ;

//   double f = 1.0 / sqrt(X) ;
//   double ff = -0.5 * ( 1.0/sqrt(X*X*X)) ;
//   double fo = f - ( ff * X ) ;

//   printf("%0.6e %0.6e %0.6e %0.6e %0.6e %0.6e %0.6e %0.6e\n",X,ff,slope.get_value(),fo,offset.get_value(),f,out_result.get_value(),X*result*result) ;
   return result ;
}

double estimate_reciprocal(double X)
{
   /*
    * Special case of X == 0.0, reciprocal not represented
    */
   if ( X == 0.0 )
   {
      return dInf ;
   } /* endif */
   /*
    * Normal case of X <> 0.0
    */
   doublemap in_map(X) ;
   int in_exponent = in_map.exponent() ;
   int in_sign = in_map.sign_bit() ;
   unsigned int in_index = ( in_map.significand_hi() >> 15 ) & 0x1f ; // in_index should be in (0,31)
   // Truncate input to 21 bits of precision, including implied leading 1
   doublemap mid_map(0,0,in_map.significand_hi(),0) ;  // mid_map should be in (1,2)

   int slope_significand = slope_table_recip[in_index] ;
   int slope_exponent = slope_exponent_table_recip[in_index] ;

   int offset_significand = offset_table_recip[in_index] ;

   doublemap slope(1,slope_exponent,slope_significand << 9,0) ;
   doublemap offset(0,0,offset_significand << 1, 0) ;

   doublemap mid_result(mid_map.get_value() * slope.get_value() + offset.get_value() ) ;
   int mid_exponent = mid_result.exponent() ;

   int out_exponent = mid_exponent - in_exponent ;

   double result ;
   if ( out_exponent > -1023 )
   {
     // Result is normalised
     // Truncate output to 24 bits of precision, including implied leading 1
     doublemap out_result(in_sign, out_exponent,mid_result.significand_hi(),mid_result.significand_lo() & 0xe0000000 ) ;
     result = out_result.get_value() ;
   }
   else
   {
      // Result is denormal
      doublemap out_result(in_sign, -1023,
         mid_result.significand_hi() >> (-1022-out_exponent),
         (( mid_result.significand_hi() << (32+1022+out_exponent) ) | (mid_result.significand_lo() >> (-1022-out_exponent) ) ) & 0xe0000000
        ) ;
      result = out_result.get_value() ;
   } /* endif */

   /*
    * Diagnosis, compare the lookup values with the analytic values
    */
// printf("in-exponent %d in-index %d\n",in_exponent, in_index) ;
// printf("Calculating %0.17e * %0.17e + %0.17e\n",mid_map.get_value(),slope.get_value(),offset.get_value()) ;
// printf("Giving %0.17e\n",mid_result.get_value()) ;
//
// double f = 1.0 / X ;
// double ff = -1.0 / (X*X) ;
// double fo = f - ( ff * X ) ;
//
// printf("%0.6e %0.6e %0.6e %0.6e %0.6e %0.6e %0.6e %0.6e\n",X,ff,slope.get_value(),fo,offset.get_value(),f,out_result.get_value(),X*result) ;
   return result ;
}

/*
 * Given an estimate x0 of a solution to the equations
 * f(x) = a*x-1, f(x) = 0
 * produce a better estimate x1 of the solution.
 *
 * Newton's method wants to calculate
 * x1 = x0 - f(x0)/f'(x0)      where f'(x) = df/dx = a
 *
 * i.e. x1 = x0 - (a*x0-1) / a
 * we can't do the division conveniently, but we do have an estimate of
 * 1/a, namely x0. So instead we will compute
 * x1 = x0 - x0 * ( a*x0 - 1 )
 * and we will arrange it as
 * x1 = x0 * ( 2 - a*x0 )
 * so that the compiler can find the 'multiply-add'
 */
static inline double better_reciprocal(double a, double x0)
{
   double f0 = a*x0 - 1.0 ;
   double x1 = x0 - x0 * f0 ;
   return x1 ;
}

static inline double better_divide(double a, double r0, double b)
{
#if 0
   double bs = b * 1024.0 ;
   double x0s = bs*r0 ;
   double f0s = __fmsub(a,x0s,bs) ;
   double x1s = x0s - r0 * f0s ;
   double x1 = x1s * ( 1.0/1024.0 ) ;
#else
   double x0 = b*r0 ;
   // double f0 = a*x0 - b ;
   double f0 = __fmsub(a,x0,b) ;
   // double x1 = x0 - r0 * f0 ;
   double x1 = __fnmsub(r0,f0,x0) ;
#endif
   return x1 ;
}

double complete_reciprocal(double x0, double a)
{
   double x1 = better_reciprocal(a,x0) ;
   double x2 = better_reciprocal(a,x1) ;
   double x3 = better_reciprocal(a,x2) ;
   return x3 ;
}

float complete_reciprocal_float(double x0, double a)
{
   double x1 = better_reciprocal(a,x0) ;
   double x2 = better_reciprocal(a,x1) ;
   return x2 ;
}

double complete_divide(double x0, double a, double b)
{
   double x1 = better_reciprocal(a,x0) ;
   double x2 = better_reciprocal(a,x1) ;
   double x3 = better_divide    (a,x2,b) ;
   return x3 ;
}

float complete_divide_float(double x0, double a, double b)
{
   double x1 = better_reciprocal(a,x0) ;
   double x2 = better_reciprocal(a,x1) ;
   return b*x2 ;
}

double reciprocal(double a)
{

   double x0 = estimate_reciprocal(a) ;
   return complete_reciprocal(x0, a) ;
}

float reciprocal_float(float a)
{
   double x0 = estimate_reciprocal(a) ;
   double dresult = complete_reciprocal_float(x0, a) ;
   float result = dresult ;
   return result ;
}

double divide(double a, double n)
{

   double x0 = estimate_reciprocal(a) ;
   return complete_divide(x0, a, n) ;
}

float divide_float(float a, float n)
{

   double x0 = estimate_reciprocal(a) ;
   return complete_divide_float(x0, a, n) ;
}

/*
 * Software iterations for refinement to IEEE-accurate results
 */

/*
 * Given an estimate x0 of a solution to the equations
 * f(x) = a*x*x-1, f(x) = 0
 * produce a better estimate x1 of the solution.
 *
 * Newton's method wants to calculate
 * x1 = x0 - f(x0)/f'(x0)      where f'(x) = df/dx = 2 * a * x
 *
 * i.e. x1 = x0 - (a*x0*x0-1) / ( 2 * a * x0 )
 * we can't do the division conveniently, but we do have an estimate of
 * 1/(a*x0), namely x0. So instead we will compute
 * x1 = x0 - x0 * ( a*x0*x0 - 1 ) / 2
 * and we will arrange it as
 * x1 = x0 * ( 1.5 - (0.5*a)*(x0*x0) )
 * so that the compiler can find the 'multiply-add'
 */
static inline
double better_reciprocal_square_root(double a, double x0)
{
   double x02 = x0*x0 ;
   double hf0 = (0.5*a) * x02 - 0.5 ;
   double x1 = x0 - x0 * hf0 ;
   return x1 ;
}

static inline long double better_long_reciprocal_square_root(long double a, long double x0)
{
   long double x02 = x0*x0 ;
   long double hf0 = (0.5*a) * x02 - 0.5 ;
   long double x1 = x0 - x0 * hf0 ;
   return x1 ;
}

double complete_reciprocal_square_root(double x0, double a)
{
   double x1 = better_reciprocal_square_root(a,x0) ;
   double x2 = better_reciprocal_square_root(a,x1) ;
   double x3 = better_reciprocal_square_root(a,x2) ;
   return x3 ;
}

float complete_reciprocal_square_root_float(double x0, double a)
{
   double x1 = better_reciprocal_square_root(a,x0) ;
   double x2 = better_reciprocal_square_root(a,x1) ;
   return x2 ;
// Following is in case we need an additional iteration.
//   double x3 = better_reciprocal_square_root(a,x2) ;
//   return x3 ;
}


double reciprocal_square_root(double a)
{
   double x0 = estimate_reciprocal_square_root(a) ;
   return complete_reciprocal_square_root(x0, a) ;
}

float reciprocal_square_root_float(float a)
{
   double x0 = estimate_reciprocal_square_root(a) ;
   return complete_reciprocal_square_root_float(x0, a) ;
}

double complete_square_root(double x0, double a)
{
   double x1 = better_reciprocal_square_root(a,x0) ;
   double x2 = better_reciprocal_square_root(a,x1) ;
   double q0 = x2 * a ;
   double q1 = q0 - ( (0.5*x2) * (q0*q0-a) ) ;  // 1 iteration of Newton-Raphson for square root
   // q1 is NaN for a<0, sqrt(a) for a>0, but not right for a==0
   // special-case fixup for a==0 with the 'fsel' following
   double result = __fsel( -abs(a), a , q1 ) ;

   return result ;
}

float complete_square_root_float(double x0, double a)
{
   double x1 = better_reciprocal_square_root(a,x0) ;
   double x2 = better_reciprocal_square_root(a,x1) ;
   double q0 = x2 * a ;
   double result = __fsel( -abs(a), a , q0 ) ;
   return result ;
}

double square_root(double a)
{
   double x0 = estimate_reciprocal_square_root(a) ;
   return complete_square_root(x0, a) ;
}

float square_root_float(float a)
{
   double x0 = estimate_reciprocal_square_root(a) ;
   return complete_square_root_float(x0, a) ;
}

double complete_reciprocal_taylor(double x0, double a)
{
   double ep = x0 * a - 1.0 ; // The accurate reciprocal will be x0 * (1+ep)**(-1)
   // Taylor series for (1+ep)**(-1), with error of the order of (ep**5) which should be small enough
   double epr = ep * ( -1.0 + ep           ) ;  // (1+ep)**(-1)
   double r0 = x0 + x0 * epr ;
   double result = better_reciprocal ( a, r0 ) ;
   return result ;
}

float complete_reciprocal_taylor_float(double x0, double a)
{
   double ep = x0 * a - 1.0 ; // The accurate reciprocal will be x0 * (1+ep)**(-1)
   // Taylor series for (1+ep)**(-1), with error of the order of (ep**5) which should be small enough
   double epr = ep * ( -1.0 + ep * ( 1.0 + ep * ( -1.0 ) ) ) ;  // (1+ep)**(-1)
   double x1 = x0 + x0 * epr ;
   float result = x1 ;
   return result ;
}

double complete_divide_taylor(double x0, double a, double n)
{
   double ep = x0 * a - 1.0 ; // The accurate reciprocal will be x0 * (1+ep)**(-1)
   // Taylor series for (1+ep)**(-1), with error of the order of (ep**5) which should be small enough
// double epr = ep * ( -1.0 + ep * ( 1.0 + ep * (-1.0) )              ) ;  // (1+ep)**(-1)
   double ep3 = -1.0            ;
   double ep2 = +1.0 + ep * ep3 ;
   double ep1 = -1.0 + ep * ep2 ;
   double epr =        ep * ep1 ;

   double x1 = x0 + x0 * epr ;
   double result = better_divide(a, x1, n) ;
   return result ;
}

float complete_divide_taylor_float(double x0, double a, double n)
{
   double ep = x0 * a - 1.0 ; // The accurate reciprocal will be x0 * (1+ep)**(-1)
   // Taylor series for (1+ep)**(-1), with error of the order of (ep**5) which should be small enough
   double epr = ep * ( -1.0 + ep * ( 1.0 + ep * ( -1.0 ) )           ) ;  // (1+ep)**(-1)
   double x1 = x0 + x0 * epr ;
   double r0 = x1 * n ;
   float result = r0 ;
   return result ;
}

double reciprocal_taylor(double a)
{

   double x0 = estimate_reciprocal(a) ;
   return complete_reciprocal_taylor(x0, a) ;
}

float reciprocal_taylor_float(float a)
{

   double x0 = estimate_reciprocal(a) ;
   return complete_reciprocal_taylor_float(x0, a) ;
}

double divide_taylor(double a,double n)
{

   double x0 = estimate_reciprocal(a) ;
   return complete_divide_taylor(x0, a, n) ;
}

float divide_taylor_float(float a,float n)
{

   double x0 = estimate_reciprocal(a) ;
   return complete_divide_taylor_float(x0, a, n) ;
}

double complete_reciprocal_square_root_taylor(double x0, double a)
{
   double ep = (x0*x0)*a - 1.0 ;
   // Taylor series for (1+ep)**(-1/2), with error of the order of (ep**6) which should be small enough
   double epr = ep * ( (-1.0/2.0) + ep * ( (3.0/8.0) + ep * ( (-5.0/16.0) + ep * ( (35.0/128.0) /* + ep * (-63.0/256.0) */  ) ) ) ) ;  // (1+ep)**(-1/2)
   double result = x0 * epr + x0 ;
   return result ;
}

float complete_reciprocal_square_root_taylor_float(double x0, double a)
{
   double ep = (x0*x0)*a - 1.0 ;
   // Taylor series for (1+ep)**(-1/2), with error of the order of (ep**5) which should be small enough
   double epr = ep * ( (-1.0/2.0) + ep * ( (3.0/8.0) + ep * ( (-5.0/16.0) /* + ep * ( (35.0/128.0) + ep * (-63.0/256.0) ) */ ) ) );  // (1+ep)**(-1/2)
// Following is in case we need an additional term
//   double epr = ep * ( (-1.0/2.0) + ep * ( (3.0/8.0) + ep * ( (-5.0/16.0) + ep * ( (35.0/128.0) /* + ep * (-63.0/256.0) */ ) ) ) );  // (1+ep)**(-1/2)
   double result = x0 * epr + x0 ;
   float fresult = result ;
   return fresult ;
}

double reciprocal_square_root_taylor(double a)
{
   double x0 = estimate_reciprocal_square_root(a) ;
   return complete_reciprocal_square_root_taylor(x0, a) ;
}

float reciprocal_square_root_taylor_float(float a)
{
   double x0 = estimate_reciprocal_square_root(a) ;
   return complete_reciprocal_square_root_taylor_float(x0, a) ;
}

double diagnose_recroot_taylor(double a)
{
   double x0 = estimate_reciprocal_square_root(a) ;
   double result = complete_reciprocal_square_root_taylor(x0, a) ;
   cerr << "recroot of " << a
        << " giving estimate " << x0
        << " partial error " << (x0*x0*a) - 1.0
        << endl ;
   return result ;
}

double complete_square_root_taylor(double x0, double a)
{
   double x0a = x0*a ;
   double ep = x0*x0a - 1.0 ;
   // Taylor series for (1+ep)**(-1/2), with error of the order of (ep**6) which should be small enough
   double epr = ep * ( (-1.0/2.0) + ep * ( (3.0/8.0) + ep * ( (-5.0/16.0)
// + ep * (35.0/128.0)
   ) ) ) ;  // (1+ep)**(-1/2)
   // q0 is the corrected square root, nominally (x0*epr) * a, but rearranged
   double q0 = x0a * epr + x0a ;
   double q1 = q0 - ( (0.5*(x0*epr + x0)) * (q0*q0-a) ) ;  // 1 iteration of Newton-Raphson for square root
   // q1 is NaN for a<0, sqrt(a) for a>0, but not right for a==0
   // special-case fixup for a==0 with the 'fsel' following
   double result = __fsel( -abs(a), a , q1 ) ;
   return result ;
}

float complete_square_root_taylor_float(double x0, double a)
{
   double x0a = x0*a ;
   double ep = x0*x0a - 1.0 ;
   // Taylor series for (1+ep)**(-1/2), with error of the order of (ep**5) which should be small enough
   double epr = ep * ( (-1.0/2.0) + ep * ( (3.0/8.0)
   + ep * ( (-5.0/16.0)
// + ep * (35.0/128.0)
   )
   )
   ) ;  // (1+ep)**(-1/2)
   // q0 is the corrected square root, nominally (x0*epr) * a, but rearranged
   double q0 = x0a * epr + x0a ;
   // special-case fixup for a==0 with the 'fsel' following
   float result = __fsel( -abs(a), a , q0 ) ;
   return result ;
}

double square_root_taylor(double a)
{
   double x0 = estimate_reciprocal_square_root(a) ;
   return complete_square_root_taylor(x0, a) ;
}

float square_root_taylor_float(float a)
{
   double x0 = estimate_reciprocal_square_root(a) ;
   return complete_square_root_taylor_float(x0, a) ;
}


/*
 * Test harness
 */
void tverify(double a, double n)
{
      printf("Parameters %0.17e %0.17e\n", a,n) ;
      // Newton-Raphson iteration methods
      double r = reciprocal(a) ;
      double s = reciprocal_square_root(a) ;
      double q = square_root(a) ;
      double d = divide(a,n) ;
      // Taylor series methods
      double rt = reciprocal_taylor(a) ;
      double st = reciprocal_square_root_taylor(a) ;
      double qt = square_root_taylor(a) ;
      double dt = divide_taylor(a,n) ;
      // Language-specified (hopefully IEEE conformant) methods
      double ra = 1.0/a ;
      double sa = rsqrt(a) ;
      double qa = sqrt(a) ;
      long double da = (long double)n/(long double)a ;

      // Scaling so errors can be reported as multiples of ULP
      double escale = 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 * 8.0 ; // 2**53

      printf("Reciprocal IEEE=%0.17e N-R=%0.17e (%8.5f)   Taylor=%0.17e (%8.5f)\n",ra,r,escale*(r-ra)/ra,rt,escale*(rt-ra)/ra) ;
      printf("Divide     IEEE=%0.17e N-R=%0.17e (%8.5f)   Taylor=%0.17e (%8.5f)\n",(double)da,d,(double)(escale*(d-da)/da),dt,(double)(escale*(dt-da)/da)) ;
      printf("                (0x%08x%08x %08x%08x)   (0x%08x%08x)   (0x%08x%08x)\n",
                              ((int*)&da)[0], ((int*)&da)[1], ((int*)&da)[2], ((int*)&da)[3],
                              ((int*)&d)[0], ((int*)&d)[1],
                              ((int*)&dt)[0], ((int*)&dt)[1]
            ) ;

      printf("Rec-sqrt   IEEE=%0.17e N-R=%0.17e (%8.5f)   Taylor=%0.17e (%8.5f)\n",sa,s,escale*(s-sa)/sa,st,escale*(st-sa)/sa) ;
      printf("Sqrt       IEEE=%0.17e N-R=%0.17e (%8.5f)   Taylor=%0.17e (%8.5f)\n",qa,q,escale*(q-qa)/qa,qt,escale*(qt-qa)/qa) ;
}

void tverifyf(double a, double n)
{
      printf("Parameters %0.17e %0.17e\n", a,n) ;
      // Newton-Raphson iteration methods
      double r = reciprocal_float(a) ;
      double s = reciprocal_square_root_float(a) ;
      double q = square_root_float(a) ;
      double d = divide_float(a,n) ;
      // Taylor series methods
      double rt = reciprocal_taylor_float(a) ;
      double st = reciprocal_square_root_taylor_float(a) ;
      double qt = square_root_taylor_float(a) ;
      double dt = divide_taylor_float(a,n) ;
      // Language-specified (hopefully IEEE conformant) methods
      double ra = 1.0/a ;
      double sa = rsqrt(a) ;
      double qa = sqrt(a) ;
      long double da = (long double)n/(long double)a ;

      // Scaling so errors can be reported as multiples of ULP
      double escale = 1024.0 * 1024.0 * 4.0; // 2**24

      printf("Reciprocal float IEEE=%0.17e N-R=%0.17e (%8.5f)   Taylor=%0.17e (%8.5f)\n",ra,r,escale*(r-ra)/ra,rt,escale*(rt-ra)/ra) ;
      printf("Divide     float IEEE=%0.17e N-R=%0.17e (%8.5f)   Taylor=%0.17e (%8.5f)\n",(double)da,d,(double)(escale*(d-da)/da),dt,(double)(escale*(dt-da)/da)) ;
      printf("Rec-sqrt   float IEEE=%0.17e N-R=%0.17e (%8.5f)   Taylor=%0.17e (%8.5f)\n",sa,s,escale*(s-sa)/sa,st,escale*(st-sa)/sa) ;
      printf("Sqrt       float IEEE=%0.17e N-R=%0.17e (%8.5f)   Taylor=%0.17e (%8.5f)\n",qa,q,escale*(q-qa)/qa,qt,escale*(qt-qa)/qa) ;
}
int maina(int argc, const char** argv)
{
   if (argc == 3)
   {
      char* dummy0 ;
      double a = strtod(argv[1],&dummy0) ;
      double n = strtod(argv[2],&dummy0) ;
      tverify(a,n) ;
      return 0 ;
   } else if ( argc == 5 )
   {
      char* dummy1 ;
      unsigned long v1 = strtoul(argv[1],&dummy1,0) ;
      unsigned long v2 = strtoul(argv[2],&dummy1,0) ;
      unsigned long v3 = strtoul(argv[3],&dummy1,0) ;
      unsigned long v4 = strtoul(argv[4],&dummy1,0) ;
      doublemap amap(v1,v2) ;
      doublemap nmap(v3,v4) ;
      double a = amap.get_value() ;
      double n = nmap.get_value() ;
      tverify(a,n) ;
      tverifyf(a,n) ;
      return 0 ;
   } else {
      printf("%s 2.0 : simulate Double Hummer reciprocal and reciprocal square root iterations for parameter 2.0"
             "\n", argv[0]) ;
     return 1 ;
   } /* endif */
}

int report_root_taylor(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double q = square_root_taylor(b) ;
      double q2 = square_root_taylor(2.0*b) ;
      double qe = sqrt(b) ;
      double qe2 = sqrt(2.0*b) ;
      if (q != qe) k += 1 ;
      if (q2 != qe2) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}

int report_root(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double q = square_root(b) ;
      double q2 = square_root(2.0*b) ;
      double qe = sqrt(b) ;
      double qe2 = sqrt(2.0*b) ;
      if (q != qe) k += 1 ;
      if (q2 != qe2) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}

int report_root_float(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      float fb = b ;
      float q = square_root_float(fb) ;
      float q2 = square_root_float(2.0*fb) ;
      float qe = sqrt(fb) ;
      float qe2 = sqrt(2.0*fb) ;
      if (q != qe) k += 1 ;
      if (q2 != qe2) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}

int report_root_taylor_float(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      float fb = b ;
      float q = square_root_taylor_float(fb) ;
      float q2 = square_root_taylor_float(2.0*fb) ;
      float qe = sqrt(fb) ;
      float qe2 = sqrt(2.0*fb) ;
      if (q != qe) k += 1 ;
      if (q2 != qe2) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}

int report_recroot_taylor(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double q = reciprocal_square_root_taylor(b) ;
      double q2 = reciprocal_square_root_taylor(2.0*b) ;
      double qe = rsqrt(b) ;
      double qe2 = rsqrt(2.0*b) ;
      long double bq = better_long_reciprocal_square_root(b,q) ;
      long double bq2 = better_long_reciprocal_square_root(2.0*b,q2) ;

      double dbq = bq ;
      double dbq2 = bq2 ;

      if ( dbq != q )
      {
        k += 1 ;
//      (void) diagnose_recroot_taylor(b) ;
      }
      if ( dbq2 != q2 ) {
        k += 1 ;
//      (void) diagnose_recroot_taylor(2.0*b) ;
      }
      b += delta ;
   } /* endfor */
   return k ;
}

int report_recroot(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double q = reciprocal_square_root(b) ;
      double q2 = reciprocal_square_root(2.0*b) ;
      double qe = rsqrt(b) ;
      double qe2 = rsqrt(2.0*b) ;
      long double bq = better_long_reciprocal_square_root(b,q) ;
      long double bq2 = better_long_reciprocal_square_root(2.0*b,q2) ;

      if ( /* q != qe && */ abs(q-bq) > abs(qe-bq) ) {
         k += 1 ;
      }
      if ( /* q2 != qe2 && */ abs(q2-bq2) > abs(qe2-bq2) ) {
         k += 1 ;
      }
      b += delta ;
   } /* endfor */
   return k ;
}

int report_recroot_float(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      float fb = b ;
      float q = reciprocal_square_root_float(fb) ;
      float q2 = reciprocal_square_root_float(2.0*fb) ;
      double dfb = fb ;
      float qe = 1.0/sqrt(dfb) ;
      float qe2 = 1.0/sqrt(2.0*dfb) ;
      if (q != qe) k += 1 ;
      if (q2 != qe2) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}

int report_recroot_taylor_float(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      float fb = b ;
      float q = reciprocal_square_root_taylor_float(fb) ;
      float q2 = reciprocal_square_root_taylor_float(2.0*fb) ;
      double dfb = fb ;
      float qe = 1.0/sqrt(dfb) ;
      float qe2 = 1.0/sqrt(2.0*dfb) ;
      if (q != qe) k += 1 ;
      if (q2 != qe2) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}


int report_reciprocal(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double q = reciprocal(b) ;
      double qe = 1.0/b ;
      if (q != qe) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}

int report_reciprocal_float(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      float fb = b ;
      float q = reciprocal_float(fb) ;
      float qe = 1.0/fb ;
      if (q != qe) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}

int report_reciprocal_taylor_float(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      float fb = b ;
      float q = reciprocal_taylor_float(fb) ;
      float qe = 1.0/fb ;
      if (q != qe) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}

int report_reciprocal_taylor(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double q = reciprocal_taylor(b) ;
      double qe = 1.0/b ;
      if (q != qe) k += 1 ;
      b += delta ;
   } /* endfor */
   return k ;
}

int report_divide(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double c = start ;
      for (unsigned int d=0; d<count;d+=1 )
      {
        double q = divide(c,b) ;
        double qe = b/c ;
        if (q != qe) k += 1 ;
        c += delta ;
      } /* endfor */
      b += delta ;
   } /* endfor */
   return k ;
}

int report_divide_float(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double c = start ;
      for (unsigned int d=0; d<count;d+=1 )
      {
        float fb = b ;
        float fc = c ;
        float q = divide_float(fc,fb) ;
        float qe = fb/fc ;
        if (q != qe) k += 1 ;
        c += delta ;
      } /* endfor */
      b += delta ;
   } /* endfor */
   return k ;
}

int report_divide_taylor_float(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double c = start ;
      for (unsigned int d=0; d<count;d+=1 )
      {
        float fb = b ;
        float fc = c ;
        float q = divide_taylor_float(fc,fb) ;
        float qe = fb/fc ;
        if (q != qe) k += 1 ;
        c += delta ;
      } /* endfor */
      b += delta ;
   } /* endfor */
   return k ;
}

int report_divide_taylor(int count, double start, double delta)
{
   int k = 0 ;
   double b = start ;
   for (unsigned int a=0; a<count; a+=1)
   {
      double c = start ;
      for (unsigned int d=0; d<count;d+=1 )
      {
        double q = divide_taylor(c,b) ;
        double qe = b/c ;
        if (q != qe) k += 1 ;
        c += delta ;
      } /* endfor */
      b += delta ;
   } /* endfor */
   return k ;
}

int mainb(int argc, const char ** argv)
{
   cout << "report_divide            " << report_divide           (1000    ,1.0,1e-3) << endl ;
   cout << "report_divide_taylor     " << report_divide_taylor    (10000   ,1.0,1e-4) << endl ;
   cout << "report_divide_float      " << report_divide_float     (1000    ,1.0,1e-3) << endl ;
   cout << "report_divide_taylor_float      " << report_divide_taylor_float     (1000    ,1.0,1e-3) << endl ;
   cout << "report_root_taylor       " << report_root_taylor      (1000000,1.0,1e-6) << endl ;
   cout << "report_root              " << report_root             (1000000,1.0,1e-6) << endl ;
   cout << "report_root_float        " << report_root_float       (1000000,1.0,1e-6) << endl ;
   cout << "report_root_taylor_float        " << report_root_taylor_float       (1000000,1.0,1e-6) << endl ;
   cout << "report_recroot_taylor    " << report_recroot_taylor   (1000000,1.0,1e-6) << endl ;
   cout << "report_recroot           " << report_recroot          (1000000,1.0,1e-6) << endl ;
   cout << "report_recroot_float     " << report_recroot_float    (1000000,1.0,1e-6) << endl ;
   cout << "report_recroot_taylor_float     " << report_recroot_taylor_float    (1000000,1.0,1e-6) << endl ;
   cout << "report_reciprocal_taylor " << report_reciprocal_taylor(1000000,1.0,1e-6) << endl ;
   cout << "report_reciprocal        " << report_reciprocal       (1000000,1.0,1e-6) << endl ;
   cout << "report_reciprocal_float  " << report_reciprocal_float (1000000,1.0,1e-6) << endl ;
   cout << "report_reciprocal_taylor_float  " << report_reciprocal_taylor_float (10000000,1.0,1e-7) << endl ;
   return 0 ;
}

int main(int argc, const char** argv)
{
   return (argc > 1) ? maina(argc,argv) : mainb(argc,argv) ;
}
