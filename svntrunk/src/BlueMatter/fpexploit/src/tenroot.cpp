/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include <math.h>
#include <BlueMatter/fpexploit.hpp>
void tenroot(double* f, const double* x)
{
   QuadWordAligned(f) ;
   QuadWordAligned(x) ;
   double x0 = x[0] ;
   double x1 = x[1] ;
   double x2 = x[2] ;
   double x3 = x[3] ;
   double x4 = x[4] ;
   double x5 = x[5] ;
   double x6 = x[6] ;
   double x7 = x[7] ;
   double x8 = x[8] ;
   double x9 = x[9] ;
   double r0 = 1.0/sqrt(x0) ;
   double r1 = 1.0/sqrt(x1) ;
   double r2 = 1.0/sqrt(x2) ;
   double r3 = 1.0/sqrt(x3) ;
   double r4 = 1.0/sqrt(x4) ;
   double r5 = 1.0/sqrt(x5) ;
   double r6 = 1.0/sqrt(x6) ;
   double r7 = 1.0/sqrt(x7) ;
   double r8 = 1.0/sqrt(x8) ;
   double r9 = 1.0/sqrt(x9) ;
   f[0] = r0 ;
   f[1] = r1 ;
   f[2] = r2 ;
   f[3] = r3 ;
   f[4] = r4 ;
   f[5] = r5 ;
   f[6] = r6 ;
   f[7] = r7 ;
   f[8] = r8 ;
   f[9] = r9 ;
}

void tendivide(double* f, const double* y, const double* x)
{
   QuadWordAligned(f) ;
   QuadWordAligned(y) ;
   QuadWordAligned(x) ;
   double x0 = x[0] ;
   double x1 = x[1] ;
   double x2 = x[2] ;
   double x3 = x[3] ;
   double x4 = x[4] ;
   double x5 = x[5] ;
   double x6 = x[6] ;
   double x7 = x[7] ;
   double x8 = x[8] ;
   double x9 = x[9] ;
   double y0 = y[0] ;
   double y1 = y[1] ;
   double y2 = y[2] ;
   double y3 = y[3] ;
   double y4 = y[4] ;
   double y5 = y[5] ;
   double y6 = y[6] ;
   double y7 = y[7] ;
   double y8 = y[8] ;
   double y9 = y[9] ;
   double r0 = y0/x0 ;
   double r1 = y1/x1 ;
   double r2 = y2/x2 ;
   double r3 = y3/x3 ;
   double r4 = y4/x4 ;
   double r5 = y5/x5 ;
   double r6 = y6/x6 ;
   double r7 = y7/x7 ;
   double r8 = y8/x8 ;
   double r9 = y9/x9 ;
   f[0] = r0 ;
   f[1] = r1 ;
   f[2] = r2 ;
   f[3] = r3 ;
   f[4] = r4 ;
   f[5] = r5 ;
   f[6] = r6 ;
   f[7] = r7 ;
   f[8] = r8 ;
   f[9] = r9 ;
}
#include <BlueMatter/fpformat.hpp>

extern "C" { int wmain(void) ; } ;
extern "C" { void s0printf(const char *, ...) ; } ;

static double __align(16) rootsources[] = {
   1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0
} ;

static double __align(16) rootsources2[] = {
   -2.0, -1.0, 0.0, 1.0, 2.0, -2.0, -1.0, 0.0, 1.0, 2.0
   } ;

static double __align(16) nsources[] = {
   1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0
   } ;

static double __align(16) dsources[] = {
   10.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0
   } ;

static int __align(16) nsources2[] = {
   0x3ff00000, 0x00000000,
   0x3ff00000, 0x00000000,
   0x001A63D6, 0x5ED4C7AC,
   0x001A63D6, 0x5ED4C7AC,
   0x3ffA63D6, 0x5ED4C7AC,
   0x3ffA63D6, 0x5ED4C7AC,
   0x00201672, 0x00202CE4,
   0x00201672, 0x00202CE4,
   0x3ff01672, 0x00202CE4,
   0x3ff01672, 0x00202CE4
   } ;

static int __align(16) dsources2[] = {
   0x00000000, 0x00000000,
   0x00000000, 0x00000000,
   0x3CF9429B, 0x20328536,
   0x3CF9429B, 0x20328536,
   0x3CF9429B, 0x20328536,
   0x3CF9429B, 0x20328536,
   0x03F95B67, 0xED32B6CF,
   0x03F95B67, 0xED32B6CF,
   0x03F95B67, 0xED32B6CF,
   0x03F95B67, 0xED32B6CF
   } ;


int pipedrain(unsigned int x)
{
   int result = 0 ;
   for (unsigned int a=0; a<x; a+=1)
   {
      result += a ;
   } /* endfor */
   return result ;
}

void show_results(const double* sources, const double* results)
{
  for (int x=0; x<10; x+=1)
  {
     char buffera[20] ;
     char bufferz[20] ;
     int i0 = ((int *)(results+x))[0] ;
     int i1 = ((int *)(results+x))[1] ;
     fpformat(buffera,sources[x], 20) ;
     fpformat(bufferz, results[x], 20) ;
     s0printf("%s 0x%08x%08x %s\n",buffera, i0, i1, bufferz) ;
  } /* endfor */
}

void show_results_divide(const double* numerators, const double* denominators, const double* results)
{
  for (int x=0; x<10; x+=1)
  {
     char buffera[20] ;
     char bufferb[20] ;
     char bufferz[20] ;
     int i0 = ((int *)(results+x))[0] ;
     int i1 = ((int *)(results+x))[1] ;
     fpformat(buffera,numerators[x], 20) ;
     fpformat(bufferb,denominators[x], 20) ;
     fpformat(bufferz, results[x], 20) ;
     s0printf("%s %s 0x%08x%08x %s\n",buffera, bufferb, i0, i1, bufferz) ;
  } /* endfor */
}

int wmain(void)
{
  double rootresults[10] ;
  double rootresults2[10] ;
  double divideresults[10] ;
  double divideresults2[10] ;
  s0printf("fp start\n") ;
  (void) pipedrain(20) ;
  tenroot(rootresults, rootsources) ;
  (void) pipedrain(20) ;
  tenroot(rootresults2, rootsources2) ;
  (void) pipedrain(20) ;
  tenroot(rootresults, rootsources) ;
  (void) pipedrain(20) ;
  tenroot(rootresults2, rootsources2) ;
  (void) pipedrain(20) ;

  tendivide(divideresults, nsources,dsources) ;
  (void) pipedrain(20) ;
  tendivide(divideresults2, (const double *)nsources2,(const double *)dsources2) ;
  (void) pipedrain(20) ;
  tendivide(divideresults, nsources,dsources) ;
  (void) pipedrain(20) ;
  tendivide(divideresults2, (const double *)nsources2,(const double *)dsources2) ;
  (void) pipedrain(20) ;
  s0printf("fp end\n") ;
  show_results(rootsources, rootresults) ;
  show_results(rootsources2, rootresults2) ;
  show_results_divide(dsources,nsources,divideresults) ;
  show_results_divide((const double *)dsources2,(const double *) nsources2,divideresults2) ;
  s0printf("---\n") ;
  return 0 ;
}
