/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 // **********************************************************************
//                       CVS INFORMATION
//
// SOURCE: $Source$
// REVISION: $Revision: 3787 $
// DATE: $Date: 2002-07-18 11:32:17 -0400 (Thu, 18 Jul 2002) $
// AUTHOR: $Author: tjcw $
// TAG NAME (if applicable): $Name$
// **********************************************************************
/*
 * Generate exp(x), suitable for Double Hummer vectorisation
 */

#include <BlueMatter/fpmap.hpp>
#include <math.h>
#include <stdio.h>

#include <builtins.h>

static const double Inf = 1.0/0.0 ;
#if 0
static const double k = M_LN2/16.0 ;
static const double k2= M_LN2/256.0 ;
static const double exptable[16] = {
   exp(0*k), exp(1*k) , exp(2*k) , exp(3*k) ,
   exp(4*k) , exp(5*k) , exp(6*k) , exp(7*k) ,
   exp(8*k) , exp(9*k) , exp(10*k), exp(11*k) ,
   exp(12*k) , exp(13*k) , exp(14*k) , exp(15*k) ,
   } ;
static const double exptable2[16] = {
   exp(0*k2), exp(1*k2) , exp(2*k2) , exp(3*k2) ,
   exp(4*k2) , exp(5*k2) , exp(6*k2) , exp(7*k2) ,
   exp(8*k2) , exp(9*k2) , exp(10*k2), exp(11*k2) ,
   exp(12*k2) , exp(13*k2) , exp(14*k2) , exp(15*k2) ,
   } ;
#else
// This should be the same table, but has been evaluated at compile time
static const double exptable[16] = {
        1.00000000000000000000
     ,  1.04427378242741383881
     ,  1.09050773266525765605
     ,  1.13878863475669164875
     ,  1.18920711500272105982
     ,  1.24185781207348403959
     ,  1.29683955465100965466
     ,  1.35425554693689271456
     ,  1.41421356237309503240
     ,  1.47682614593949929212
     ,  1.54221082540794080126
     ,  1.61049033194925428250
     ,  1.68179283050742905681
     ,  1.75625216037329945002
     ,  1.83400808640934242627
     ,  1.91520656139714725223
   } ;
static const double exptable2[16] = {
        1.00000000000000000000
     ,  1.00271127505020248534
     ,  1.00542990111280282117
     ,  1.00815589811841751551
     ,  1.01088928605170045965
     ,  1.01363008495148943838
     ,  1.01637831491095303739
     ,  1.01913399607773794904
     ,  1.02189714865411667749
     ,  1.02466779289713564431
     ,  1.02744594911876369561
     ,  1.03023163768604101185
     ,  1.03302487902122842138
     ,  1.03582569360195711881
     ,  1.03863410196137878930
     ,  1.04145012468831613985
   } ;
#endif


//static  const double tp10 = 1024.0 ;
//static  const double tp20 = tp10*tp10 ;
//static  const double tp40 = tp20*tp20 ;
#define tp10 (1024.0)
#define tp20 (tp10*tp10)
#define tp40 (tp20*tp20)

static const double k_table[7][2] = {
   1.0                   ,1.0 ,
   1.0/2.0               ,1.0/2.0 ,
   1.0/(2.0*3.0)         ,1.0/(2.0*3.0) ,
   1.0/(2.0*3.0*4.0)     ,1.0/(2.0*3.0*4.0) ,
   1.0/(2.0*3.0*4.0*5.0) ,1.0/(2.0*3.0*4.0*5.0) ,
   1024.0*(1024.0+512.0) ,1024.0*(1024.0+512.0) + 0.0009765625 ,
   tp40 * ( 16.0 + 8.0 ) ,tp40 * ( 16.0 + 8.0 )
   } ;


static inline double hexpa(double x)
{
   // Dividing by ln(2) gives a value such that we can put the integer part into an exponent.
   // Multiplying by 512 gives a value such that we can take the top significand bits for this.
   // Adding (2**20+2**19) brings the exponent to a known value
  const double x1 = x * ( 512.0 / M_LN2 ) + ( 1024.0 * (1024.0 + 512.0) ) ;
  const doublemap m1(x1) ;
  // Figure the appropriate power of 2 from the significand high bits
  const unsigned int sig_hi = m1.significand_hi_bits() ;
  const doublemap m2(0,(sig_hi >> 9) - 1024, 0, 0) ;
  // Construct the number we will exponentiate from the mantissa and tables
  const doublemap m4(0,m1.exponent(),sig_hi & 0x000ffffe, 0) ;

  // Look up the next several bits (4) in a multiplication table
  const unsigned int tabits =(sig_hi >> 5) & 0x0f ;
  const double x31 = exptable[tabits] ;

  // Fixup for out-of-range parameter
  const double x31l = __fsel(x+709.0, x31, 0.0) ;
  const double x31h = __fsel(x-709.0, Inf, x31l) ;

  // And the next 4 bits in another table
  const unsigned int tabits2=(sig_hi >> 1) & 0x0f ;
  const double x32 = exptable2[tabits2] ;

  const double x3 = x31h*x32 ;

  // Back to floating point
  const double x4 = m4.get_value() ;
  double xx4 =  ( x4 - ( 1024.0 * (1024.0 + 512.0) ) )* ( M_LN2 / 512.0 ) ;
  // Figure the remaining part of the original number
  const double z = x - xx4 ;
  // z should be 'small and positive'; feed in to polynomial for exp(z)

  const double f5 =          1.0/(2.0*3.0*4.0*5.0) ;
  const double f4 = z * f5 + 1.0/(2.0*3.0*4.0) ;
  const double f3 = z * f4 + 1.0/(2.0*3.0) ;
  const double f2 = z * f3 + 1.0/2.0 ;
  const double f1 = z * f2 + 1.0 ;
  const double f0 = z * f1 + 1.0 ;

  const double p0 = f0 * x3 ;

  const double x2=m2.get_value() ;

  const double result = p0 * x2 ;
  return result ;
}

/*
 * Version of exponentiator with explicit temporaries, so we can hope for 'parallel store'
 */
static inline double hexpa(double x, doublemap& m1, doublemap& m2, doublemap& m4, unsigned int p)
{
   // Dividing by ln(2) gives a value such that we can put the integer part into an exponent.
   // Multiplying by 512 gives a value such that we can take the top significand bits for this.
   // Adding (2**20+2**19) brings the exponent to a known value
  const double align_factor = k_table[5][p] ;
  const double x1 = x * ( 512.0 / M_LN2 ) + align_factor ;
  m1.set_value(x1) ;
  // Figure the appropriate power of 2 from the significand high bits
  const unsigned int sig_hi = m1.significand_hi_bits() ;
  m2.set_value(0,(sig_hi >> 9) - 1024, 0, 0) ;
  // Construct the number we will exponentiate from the mantissa and tables
  m4.set_value(0,m1.exponent(),sig_hi & 0x000ffffe, 0) ;

  // Look up the next several bits (4) in a multiplication table
  const unsigned int tabits =(sig_hi >> 5) & 0x0f ;
  const double x31 = exptable[tabits] ;

  // Fixup for out-of-range parameter
  const double x31l = __fsel(x+709.0, x31, 0.0) ;
  const double x31h = __fsel(x-709.0, Inf, x31l) ;

  // And the next 4 bits in another table
  const unsigned int tabits2=(sig_hi >> 1) & 0x0f ;
  const double x32 = exptable2[tabits2] ;


  const double x3 = x31h*x32 ;

  // Back to floating point
  const double x4 = m4.get_value() ;
  double xx4 =  ( x4 - align_factor )* ( M_LN2 / 512.0 ) ;
  // Figure the remaining part of the original number
  const double z = x - xx4 ;
  // z should be 'small and positive'; feed in to polynomial for exp(z)

  const double f5 =          k_table[4][p] ;
  const double f4 = z * f5 + k_table[3][p] ;
  const double f3 = z * f4 + k_table[2][p] ;
  const double f2 = z * f3 + k_table[1][p] ;
  const double f1 = z * f2 + k_table[0][p] ;
  const double f0 = z * f1 + k_table[0][p] ;



  const double p0 = f0 * x3 ;

  const double x2=m2.get_value() ;

  const double result = p0 * x2 ;
  return result ;
}

static inline
double hexp(double x)
{

   // Dividing by ln(2) gives a value such that we can put the integer part into an exponent.
   // Adding (2**44+2**43) aligns and rounds this so that
   // bottom 8 bits can be used for lookup
   // higher bits can be stuffed into exponent
   // truncated bits (recovered by subtraction) can be fed to power series
  const double x1 = x * ( 1.0 / M_LN2 ) + ( tp40 * ( 16.0 + 8.0 ) ) ;
  const doublemap m1(x1) ;
  // Figure the appropriate power of 2 from the significand high bits
  const unsigned int sig_lo = m1.significand_lo_bits() ;
  const doublemap m2(0,sig_lo >> 8, 0, 0) ;
  // Recover the number that we will have 'exponentiated' by the bit twiddling
  const double xl2 =  x1 - ( tp40 * ( 16.0 + 8.0 ) ) ;
  // Can range-check xl2 to see if sig_lo put a sensible value in m2
  const double xx4 = xl2 * M_LN2 ;

  // Look up the next several bits (4) in a multiplication table
  const unsigned int tabits =(sig_lo >> 4) & 0x0f ;
  const double x31 = exptable[tabits] ;

  // Fixup for out-of-range parameter
  const double x31l = __fsel(x+709.0, x31, 0.0) ;
  const double x31h = __fsel(x-709.0, Inf, x31l) ;

  // And the next 4 bits in another table
  const unsigned int tabits2=sig_lo & 0x0f ;
  const double x32 = exptable2[tabits2] ;

  const double x3 = x31h*x32 ;

  // Figure the remaining part of the original number
  const double z = x - xx4 ;
  // z should be between +- (2**-8); feed in to polynomial for exp(z)

  const double f5 =          1.0/(2.0*3.0*4.0*5.0) ;
  const double f4 = z * f5 + 1.0/(2.0*3.0*4.0) ;
  const double f3 = z * f4 + 1.0/(2.0*3.0) ;
  const double f2 = z * f3 + 1.0/2.0 ;
  const double f1 = z * f2 + 1.0 ;
  const double f0 = z * f1 + 1.0 ;

  const double p0 = f0 * x3 ;

  const double x2=m2.get_value() ;

  const double result = p0 * x2 ;
  return result ;
}

#define generate_hexp_function(fname)                                                              \
static inline                                                                                      \
double fname(double x)                                                                             \
{                                                                                                  \
  const double x1 = x * ( 1.0 / M_LN2 ) + ( tp40 * ( 16.0 + 8.0 ) ) ;                              \
  const doublemap m1(x1) ;                                                                         \
  const unsigned int sig_lo = m1.significand_lo_bits() ;                                           \
  const doublemap m2(0,sig_lo >> 8, 0, 0) ;                                                        \
  const double xl2 =  x1 - ( tp40 * ( 16.0 + 8.0 ) ) ;                                             \
  const double xx4 = xl2 * M_LN2 ;                                                                 \
                                                                                                   \
  const unsigned int tabits =(sig_lo >> 4) & 0x0f ;                                                \
  const double x31 = exptable[tabits] ;                                                            \
                                                                                                   \
  const double x31l = __fsel(x+709.0, x31, 0.0) ;                                                  \
  const double x31h = __fsel(x-709.0, Inf, x31l) ;                                                 \
                                                                                                   \
  const unsigned int tabits2=sig_lo & 0x0f ;                                                       \
  const double x32 = exptable2[tabits2] ;                                                          \
                                                                                                   \
  const double x3 = x31h*x32 ;                                                                     \
                                                                                                   \
  const double z = x - xx4 ;                                                                       \
                                                                                                   \
  const double f5 =          1.0/(2.0*3.0*4.0*5.0) ;                                               \
  const double f4 = z * f5 + 1.0/(2.0*3.0*4.0) ;                                                   \
  const double f3 = z * f4 + 1.0/(2.0*3.0) ;                                                       \
  const double f2 = z * f3 + 1.0/2.0 ;                                                             \
  const double f1 = z * f2 + 1.0 ;                                                                 \
  const double f0 = z * f1 + 1.0 ;                                                                 \
                                                                                                   \
  const double p0 = f0 * x3 ;                                                                      \
                                                                                                   \
  const double x2=m2.get_value() ;                                                                 \
                                                                                                   \
  const double result = p0 * x2 ;                                                                  \
  return result ;                                                                                  \
}

generate_hexp_function(hexpf0)
generate_hexp_function(hexpf1)
generate_hexp_function(hexpf2)
generate_hexp_function(hexpf3)
generate_hexp_function(hexpf4)
generate_hexp_function(hexpf5)
generate_hexp_function(hexpf6)
generate_hexp_function(hexpf7)
generate_hexp_function(hexpf8)
generate_hexp_function(hexpf9)

static inline
double hexp(double x, doublemap& m1, doublemap& m2)
{

   // Dividing by ln(2) gives a value such that we can put the integer part into an exponent.
   // Adding (2**44+2**43) aligns and rounds this so that
   // bottom 8 bits can be used for lookup
   // higher bits can be stuffed into exponent
   // truncated bits (recovered by subtraction) can be fed to power series
  const double x1 = x * ( 1.0 / M_LN2 ) + ( tp40 * ( 16.0 + 8.0 ) ) ;
  m1.set_value(x1) ;
  // Figure the appropriate power of 2 from the significand high bits
  const unsigned int sig_lo = m1.significand_lo_bits() ;
  m2.set_value(0,sig_lo >> 8, 0, 0) ;
  // Recover the number that we will have 'exponentiated' by the bit twiddling
  const double xl2 =  x1 - ( tp40 * ( 16.0 + 8.0 ) ) ;
  // Can range-check xl2 to see if sig_lo put a sensible value in m2
  const double xx4 = xl2 * M_LN2 ;

  // Look up the next several bits (4) in a multiplication table
  const unsigned int tabits =(sig_lo >> 4) & 0x0f ;
  const double x31 = exptable[tabits] ;

  // Fixup for out-of-range parameter
  const double x31l = __fsel(x+709.0, x31, 0.0) ;
  const double x31h = __fsel(x-709.0, Inf, x31l) ;

  // And the next 4 bits in another table
  const unsigned int tabits2=sig_lo & 0x0f ;
  const double x32 = exptable2[tabits2] ;

  const double x3 = x31h*x32 ;

  // Figure the remaining part of the original number
  const double z = x - xx4 ;
  // z should be between +- (2**-8); feed in to polynomial for exp(z)

  const double f5 =          1.0/(2.0*3.0*4.0*5.0) ;
  const double f4 = z * f5 + 1.0/(2.0*3.0*4.0) ;
  const double f3 = z * f4 + 1.0/(2.0*3.0) ;
  const double f2 = z * f3 + 1.0/2.0 ;
  const double f1 = z * f2 + 1.0 ;
  const double f0 = z * f1 + 1.0 ;

  const double p0 = f0 * x3 ;

  const double x2=m2.get_value() ;

  const double result = p0 * x2 ;
  return result ;
}

static inline double hexp(double x, doublemap& m1, doublemap& m2, unsigned int p)
{
   // Dividing by ln(2) gives a value such that we can put the integer part into an exponent.
   // Adding (2**44+2**43) brings the exponent to a known value
  const double align_factor = k_table[6][p] ;
  const double x1 = x * ( 1.0 / M_LN2 ) + align_factor ;
  m1.set_value(x1) ;
  // Figure the appropriate power of 2 from the significand high bits
  const unsigned int sig_lo = m1.significand_lo_bits() ;
  m2.set_value(0,sig_lo >> 8, 0, 0) ;
  // Recover the number that we will have 'exponentiated' by the bit twiddling
  const double xl2 =  x1 - align_factor ;
  // Can range-check xl2 to see if sig_lo put a sensible value in m2
  const double xx4 = xl2 * M_LN2 ;

  // Look up the next several bits (4) in a multiplication table
  const unsigned int tabits =(sig_lo >> 4) & 0x0f ;
  const double x31 = exptable[tabits] ;

  // Fixup for out-of-range parameter
  const double x31l = __fsel(x+709.0, x31, 0.0) ;
  const double x31h = __fsel(x-709.0, Inf, x31l) ;

  // And the next 4 bits in another table
  const unsigned int tabits2=sig_lo & 0x0f ;
  const double x32 = exptable2[tabits2] ;


  const double x3 = x31h*x32 ;

  // Figure the remaining part of the original number
  const double z = x - xx4 ;
  // z should be between +- (2**-8); feed in to polynomial for exp(z)

  const double f5 =          k_table[4][p] ;
  const double f4 = z * f5 + k_table[3][p] ;
  const double f3 = z * f4 + k_table[2][p] ;
  const double f2 = z * f3 + k_table[1][p] ;
  const double f1 = z * f2 + k_table[0][p] ;
  const double f0 = z * f1 + k_table[0][p] ;



  const double p0 = f0 * x3 ;

  const double x2=m2.get_value() ;

  const double result = p0 * x2 ;
  return result ;
}

/*
 * Error function, from "Numerical Recipes".
 * Fractional error everywhere less than 1.2e-7
 */
static inline double erfcc(double x)
{
   const double z=fabs(x) ;
   const double lz = 1.0+0.5*z ;
//   const double st=1.0/sqrt(lz) ;
//   const double t=st*st ;                 // really, t=1.0/(1.0+0.5*z), but compiler better at roots than divisions at the moment ...
   const double t = 1.0 / lz ;
   const double t9 =      + 0.17087277 ;
   const double t8 = t9*t - 0.82215223 ;
   const double t7 = t8*t + 1.48851587 ;
   const double t6 = t7*t - 1.13520398 ;
   const double t5 = t6*t + 0.27886807 ;
   const double t4 = t5*t - 0.18628806 ;
   const double t3 = t4*t + 0.09678418 ;
   const double t2 = t3*t + 0.37409196 ;
   const double t1 = t2*t + 1.00002368 ;
   const double t0 = t1*t - 1.26551223 ;
   const double ans = t * hexp(-z*z + t0) ;
   return __fsel(x,ans,2.0-ans) ;
}

/*
 * Error function and derivative, from "Numerical Recipes".
 * Fractional error of erfcc everywhere less than 1.2e-7
 *
 *  f(z) = t(z).exp(-z**2+p(t(z)))
 * where t(z) = 1/(1+0.5*z)
 *       p(t) = polynomial in t
 *
 * Substitute a=-z**2 + p(t(z))
 *            b=exp(a)
 *  f    = t.b
 *
 *  df/dz = (dt/dz)*b + t*(db/dz)
 *  dt/dz = -0.5/(1+0.5*z)**2
 *  db/dz = (da/dz)*exp(a)
 *  da/dz = -2*z + (dp/dt)*(dt/dz)
 *
 */
static inline void erfccd(double x, double& fx,double& dfdx)
{
   const double z=fabs(x) ;
   const double lz = 1.0+0.5*z ;
//   const double st=1.0/sqrt(lz) ;
//   const double t=st*st ;                 // really, t=1.0/(1.0+0.5*z), but compiler better at roots than divisions at the moment ...
   const double t = 1.0 / lz ;


   const double kp9 = + 0.17087277 ;
   const double kp8 = - 0.82215223 ;
   const double kp7 = + 1.48851587 ;
   const double kp6 = - 1.13520398 ;
   const double kp5 = + 0.27886807 ;
   const double kp4 = - 0.18628806 ;
   const double kp3 = + 0.09678418 ;
   const double kp2 = + 0.37409196 ;
   const double kp1 = + 1.00002368 ;
   const double kp0 = - 1.26551223 ;

   const double kdp8 = kp9 * 9.0 ;
   const double kdp7 = kp8 * 8.0 ;
   const double kdp6 = kp7 * 7.0 ;
   const double kdp5 = kp6 * 6.0 ;
   const double kdp4 = kp5 * 5.0 ;
   const double kdp3 = kp4 * 4.0 ;
   const double kdp2 = kp3 * 3.0 ;
   const double kdp1 = kp2 * 2.0 ;
   const double kdp0 = kp1 * 1.0 ;

   const double p9 =      + kp9 ;
   const double p8 = p9*t + kp8 ;
   const double p7 = p8*t + kp7 ;
   const double p6 = p7*t + kp6 ;
   const double p5 = p6*t + kp5 ;
   const double p4 = p5*t + kp4 ;
   const double p3 = p4*t + kp3 ;
   const double p2 = p3*t + kp2 ;
   const double p1 = p2*t + kp1 ;
   const double p  = p1*t + kp0 ;

   const double dp8   =       + kdp8 ;
   const double dp7   = dp8*t + kdp7 ;
   const double dp6   = dp7*t + kdp6 ;
   const double dp5   = dp6*t + kdp5 ;
   const double dp4   = dp5*t + kdp4 ;
   const double dp3   = dp4*t + kdp3 ;
   const double dp2   = dp3*t + kdp2 ;
   const double dp1   = dp2*t + kdp1 ;
   const double dpdt  = dp1*t + kdp0 ;


   const double a=-z*z + p ;
   const double b=hexp(a) ;
   const double f=t*b ;
   const double dtdz = -0.5*t*t ;
   const double dadz = -2.0*z + dpdt*dtdz ;
   const double dbdz = dadz*b ;
   const double dfdz = dtdz*b + t*dbdz ;

   fx = __fsel(x,f,2.0-f) ;
   dfdx = dfdz ;

}

static inline void erfccd(double x, double& fx,double& dfdx, doublemap& m1, doublemap& m2)
{
   const double z=fabs(x) ;
   const double lz = 1.0+0.5*z ;
   const double t = 1.0 / lz ;


   const double kp9 = + 0.17087277 ;
   const double kp8 = - 0.82215223 ;
   const double kp7 = + 1.48851587 ;
   const double kp6 = - 1.13520398 ;
   const double kp5 = + 0.27886807 ;
   const double kp4 = - 0.18628806 ;
   const double kp3 = + 0.09678418 ;
   const double kp2 = + 0.37409196 ;
   const double kp1 = + 1.00002368 ;
   const double kp0 = - 1.26551223 ;

   const double kdp8 = kp9 * 9.0 ;
   const double kdp7 = kp8 * 8.0 ;
   const double kdp6 = kp7 * 7.0 ;
   const double kdp5 = kp6 * 6.0 ;
   const double kdp4 = kp5 * 5.0 ;
   const double kdp3 = kp4 * 4.0 ;
   const double kdp2 = kp3 * 3.0 ;
   const double kdp1 = kp2 * 2.0 ;
   const double kdp0 = kp1 * 1.0 ;

   const double p9 =      + kp9 ;
   const double p8 = p9*t + kp8 ;
   const double p7 = p8*t + kp7 ;
   const double p6 = p7*t + kp6 ;
   const double p5 = p6*t + kp5 ;
   const double p4 = p5*t + kp4 ;
   const double p3 = p4*t + kp3 ;
   const double p2 = p3*t + kp2 ;
   const double p1 = p2*t + kp1 ;
   const double p  = p1*t + kp0 ;

   const double dp8   =       + kdp8 ;
   const double dp7   = dp8*t + kdp7 ;
   const double dp6   = dp7*t + kdp6 ;
   const double dp5   = dp6*t + kdp5 ;
   const double dp4   = dp5*t + kdp4 ;
   const double dp3   = dp4*t + kdp3 ;
   const double dp2   = dp3*t + kdp2 ;
   const double dp1   = dp2*t + kdp1 ;
   const double dpdt  = dp1*t + kdp0 ;


   const double a=-z*z + p ;
   const double b=hexp(a,m1,m2) ;
   const double f=t*b ;
   const double dtdz = -0.5*t*t ;
   const double dadz = -2.0*z + dpdt*dtdz ;
   const double dbdz = dadz*b ;
   const double dfdz = dtdz*b + t*dbdz ;

   fx = __fsel(x,f,2.0-f) ;
   dfdx = dfdz ;

}

//static inline void erfccd(double x, double& fx,double& dfdx)
//{
//   const double z=fabs(x) ;
//   const double lz = 1.0+0.5*z ;
////   const double st=1.0/sqrt(lz) ;
////   const double t=st*st ;                 // really, t=1.0/(1.0+0.5*z), but compiler better at roots than divisions at the moment ...
//   const double t = 1.0 / lz ;
//
//
//   const double kp9 = + 0.17087277 ;
//   const double kp8 = - 0.82215223 ;
//   const double kp7 = + 1.48851587 ;
//   const double kp6 = - 1.13520398 ;
//   const double kp5 = + 0.27886807 ;
//   const double kp4 = - 0.18628806 ;
//   const double kp3 = + 0.09678418 ;
//   const double kp2 = + 0.37409196 ;
//   const double kp1 = + 1.00002368 ;
//   const double kp0 = - 1.26551223 ;
//
//   const double kdp8 = kp9 * 9.0 ;
//   const double kdp7 = kp8 * 8.0 ;
//   const double kdp6 = kp7 * 7.0 ;
//   const double kdp5 = kp6 * 6.0 ;
//   const double kdp4 = kp5 * 5.0 ;
//   const double kdp3 = kp4 * 4.0 ;
//   const double kdp2 = kp3 * 3.0 ;
//   const double kdp1 = kp2 * 2.0 ;
//   const double kdp0 = kp1 * 1.0 ;
//
//   const double p9 =      + kp9 ;
//   const double p8 = p9*t + kp8 ;
//   const double p7 = p8*t + kp7 ;
//   const double p6 = p7*t + kp6 ;
//   const double p5 = p6*t + kp5 ;
//   const double p4 = p5*t + kp4 ;
//   const double p3 = p4*t + kp3 ;
//   const double p2 = p3*t + kp2 ;
//   const double p1 = p2*t + kp1 ;
//   const double p  = p1*t + kp0 ;
//
//   const double dp8   =       + kdp8 ;
//   const double dp7   = dp8*t + kdp7 ;
//   const double dp6   = dp7*t + kdp6 ;
//   const double dp5   = dp6*t + kdp5 ;
//   const double dp4   = dp5*t + kdp4 ;
//   const double dp3   = dp4*t + kdp3 ;
//   const double dp2   = dp3*t + kdp2 ;
//   const double dp1   = dp2*t + kdp1 ;
//   const double dpdt  = dp1*t + kdp0 ;
//
//
//   const double a=-z*z + p ;
//   const double b=hexp(a) ;
//   const double f=t*b ;
//   const double dtdz = -0.5*t*t ;
//   const double dadz = -2.0*z + dpdt*dtdz ;
//   const double dbdz = dadz*b ;
//   const double dfdz = dtdz*b + t*dbdz ;
//
//   fx = __fsel(x,f,2.0-f) ;
//   dfdx = dfdz ;
//
//}

void hexp10(double* result, const double* x)
{
   double r0 = hexp(x[0]) ;
   double r1 = hexp(x[1]) ;
   double r2 = hexp(x[2]) ;
   double r3 = hexp(x[3]) ;
   double r4 = hexp(x[4]) ;
   double r5 = hexp(x[5]) ;
   double r6 = hexp(x[6]) ;
   double r7 = hexp(x[7]) ;
   double r8 = hexp(x[8]) ;
   double r9 = hexp(x[9]) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
   result[5] = r5 ;
   result[6] = r6 ;
   result[7] = r7 ;
   result[8] = r8 ;
   result[9] = r9 ;
}

void hexp6(double* result, const double* x)
{
   double r0 = hexp(x[0]) ;
   double r1 = hexp(x[1]) ;
   double r2 = hexp(x[2]) ;
   double r3 = hexp(x[3]) ;
   double r4 = hexp(x[4]) ;
   double r5 = hexp(x[5]) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
   result[5] = r5 ;
}

void ghexp10(double* result, const double* x)
{
   double x0 = x[0] ;
   double x1 = x[1] ;
   double x2 = x[2] ;
   double x3 = x[3] ;
   double x4 = x[4] ;
   double x5 = x[5] ;
   double x6 = x[6] ;
   double x7 = x[7] ;
   double x8 = x[8] ;
   double x9 = x[9] ;
   double r0 = hexpf0(x0) ;
   double r1 = hexpf1(x1) ;
   double r2 = hexpf2(x2) ;
   double r3 = hexpf3(x3) ;
   double r4 = hexpf4(x4) ;
   double r5 = hexpf5(x5) ;
   double r6 = hexpf6(x6) ;
   double r7 = hexpf7(x7) ;
   double r8 = hexpf8(x8) ;
   double r9 = hexpf9(x9) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
   result[5] = r5 ;
   result[6] = r6 ;
   result[7] = r7 ;
   result[8] = r8 ;
   result[9] = r9 ;
}

class doublemap10 {
  public:
   doublemap a0 ;
   doublemap a1 ;
   doublemap a2 ;
   doublemap a3 ;
   doublemap a4 ;
   doublemap a5 ;
   doublemap a6 ;
   doublemap a7 ;
   doublemap a8 ;
   doublemap a9 ;
   } ;

void hexp10a(double* result, const double* x)
{
   doublemap10 mu, mv ;
   double x0 = x[0] ;
   double x1 = x[1] ;
   double x2 = x[2] ;
   double x3 = x[3] ;
   double x4 = x[4] ;
   double x5 = x[5] ;
   double x6 = x[6] ;
   double x7 = x[7] ;
   double x8 = x[8] ;
   double x9 = x[9] ;
   double r0 = hexp(x0,mu.a0,mv.a0,0) ;
   double r1 = hexp(x1,mu.a1,mv.a1,1) ;
   double r2 = hexp(x2,mu.a2,mv.a2,0) ;
   double r3 = hexp(x3,mu.a3,mv.a3,1) ;
   double r4 = hexp(x4,mu.a4,mv.a4,0) ;
   double r5 = hexp(x5,mu.a5,mv.a5,1) ;
   double r6 = hexp(x6,mu.a6,mv.a6,0) ;
   double r7 = hexp(x7,mu.a7,mv.a7,1) ;
   double r8 = hexp(x8,mu.a8,mv.a8,0) ;
   double r9 = hexp(x9,mu.a9,mv.a9,1) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
   result[5] = r5 ;
   result[6] = r6 ;
   result[7] = r7 ;
   result[8] = r8 ;
   result[9] = r9 ;
}

void hexp10b(double* result, const double* x)
{
   doublemap mu0 ;
   doublemap mu1 ;
   doublemap mu2 ;
   doublemap mu3 ;
   doublemap mu4 ;
   doublemap mu5 ;
   doublemap mu6 ;
   doublemap mu7 ;
   doublemap mu8 ;
   doublemap mu9 ;
   doublemap mv0 ;
   doublemap mv1 ;
   doublemap mv2 ;
   doublemap mv3 ;
   doublemap mv4 ;
   doublemap mv5 ;
   doublemap mv6 ;
   doublemap mv7 ;
   doublemap mv8 ;
   doublemap mv9 ;
   double x0 = x[0] ;
   double x1 = x[1] ;
   double x2 = x[2] ;
   double x3 = x[3] ;
   double x4 = x[4] ;
   double x5 = x[5] ;
   double x6 = x[6] ;
   double x7 = x[7] ;
   double x8 = x[8] ;
   double x9 = x[9] ;
   double r0 = hexp(x0,mu0,mv0,0) ;
   double r1 = hexp(x1,mu1,mv1,1) ;
   double r2 = hexp(x2,mu2,mv2,0) ;
   double r3 = hexp(x3,mu3,mv3,1) ;
   double r4 = hexp(x4,mu4,mv4,0) ;
   double r5 = hexp(x5,mu5,mv5,1) ;
   double r6 = hexp(x6,mu6,mv6,0) ;
   double r7 = hexp(x7,mu7,mv7,1) ;
   double r8 = hexp(x8,mu8,mv8,0) ;
   double r9 = hexp(x9,mu9,mv9,1) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
   result[5] = r5 ;
   result[6] = r6 ;
   result[7] = r7 ;
   result[8] = r8 ;
   result[9] = r9 ;
}

void hexp10c(double* result, const double* x)
{
   doublemap mu[10], mv[10] ;
   double x0 = x[0] ;
   double x1 = x[1] ;
   double x2 = x[2] ;
   double x3 = x[3] ;
   double x4 = x[4] ;
   double x5 = x[5] ;
   double x6 = x[6] ;
   double x7 = x[7] ;
   double x8 = x[8] ;
   double x9 = x[9] ;
   double r0 = hexp(x0,mu[0],mv[0],0) ;
   double r1 = hexp(x1,mu[1],mv[1],1) ;
   double r2 = hexp(x2,mu[2],mv[2],0) ;
   double r3 = hexp(x3,mu[3],mv[3],1) ;
   double r4 = hexp(x4,mu[4],mv[4],0) ;
   double r5 = hexp(x5,mu[5],mv[5],1) ;
   double r6 = hexp(x6,mu[6],mv[6],0) ;
   double r7 = hexp(x7,mu[7],mv[7],1) ;
   double r8 = hexp(x8,mu[8],mv[8],0) ;
   double r9 = hexp(x9,mu[9],mv[9],1) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
   result[5] = r5 ;
   result[6] = r6 ;
   result[7] = r7 ;
   result[8] = r8 ;
   result[9] = r9 ;
}


void erfcc10(double* result, const double* x)
{
   double r0 = erfcc(x[0]) ;
   double r1 = erfcc(x[1]) ;
   double r2 = erfcc(x[2]) ;
   double r3 = erfcc(x[3]) ;
   double r4 = erfcc(x[4]) ;
   double r5 = erfcc(x[5]) ;
   double r6 = erfcc(x[6]) ;
   double r7 = erfcc(x[7]) ;
   double r8 = erfcc(x[8]) ;
   double r9 = erfcc(x[9]) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
   result[5] = r5 ;
   result[6] = r6 ;
   result[7] = r7 ;
   result[8] = r8 ;
   result[9] = r9 ;
}

void erfccd10(double* result, double* resultd, const double* x)
{
   double x0 = x[0] ;
   double x1 = x[1] ;
   double x2 = x[2] ;
   double x3 = x[3] ;
   double x4 = x[4] ;
   double x5 = x[5] ;
   double x6 = x[6] ;
   double x7 = x[7] ;
   double x8 = x[8] ;
   double x9 = x[9] ;
   erfccd(x0,result[0],resultd[0]) ;
   erfccd(x1,result[1],resultd[1]) ;
   erfccd(x2,result[2],resultd[2]) ;
   erfccd(x3,result[3],resultd[3]) ;
   erfccd(x4,result[4],resultd[4]) ;
   erfccd(x5,result[5],resultd[5]) ;
   erfccd(x6,result[6],resultd[6]) ;
   erfccd(x7,result[7],resultd[7]) ;
   erfccd(x8,result[8],resultd[8]) ;
   erfccd(x9,result[9],resultd[9]) ;
}

void erfccd6(double* result, double* resultd, const double* x)
{
   double x0 = x[0] ;
   double x1 = x[1] ;
   double x2 = x[2] ;
   double x3 = x[3] ;
   double x4 = x[4] ;
   double x5 = x[5] ;
   double r0 ;
   double r1 ;
   double r2 ;
   double r3 ;
   double r4 ;
   double r5 ;
   double d0 ;
   double d1 ;
   double d2 ;
   double d3 ;
   double d4 ;
   double d5 ;
   erfccd(x0,r0,d0) ;
   erfccd(x1,r1,d1) ;
   erfccd(x2,r2,d2) ;
   erfccd(x3,r3,d3) ;
   erfccd(x4,r4,d4) ;
   erfccd(x5,r5,d5) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
   result[5] = r5 ;
   resultd[0] = d0 ;
   resultd[1] = d1 ;
   resultd[2] = d2 ;
   resultd[3] = d3 ;
   resultd[4] = d4 ;
   resultd[5] = d5 ;
}

class double6
{
   public:
   double d0 ;
   double d1 ;
   double d2 ;
   double d3 ;
   double d4 ;
   double d5 ;
} ;
class double6pair
{
   public:
   double6 a ;
   double6 b ;
} ;

void erfccd6a(double6pair& result, const double6& x)
{
   double x0 = x.d0 ;
   double x1 = x.d1 ;
   double x2 = x.d2 ;
   double x3 = x.d3 ;
   double x4 = x.d4 ;
   double x5 = x.d5 ;
   double r0 ;
   double r1 ;
   double r2 ;
   double r3 ;
   double r4 ;
   double r5 ;
   double d0 ;
   double d1 ;
   double d2 ;
   double d3 ;
   double d4 ;
   double d5 ;
   doublemap m00 ;
   doublemap m01 ;
   doublemap m02 ;
   doublemap m03 ;
   doublemap m04 ;
   doublemap m05 ;
   doublemap m10 ;
   doublemap m11 ;
   doublemap m12 ;
   doublemap m13 ;
   doublemap m14 ;
   doublemap m15 ;
   erfccd(x0,r0,d0,m00,m10) ;
   erfccd(x1,r1,d1,m01,m11) ;
   erfccd(x2,r2,d2,m02,m12) ;
   erfccd(x3,r3,d3,m03,m13) ;
   erfccd(x4,r4,d4,m04,m14) ;
   erfccd(x5,r5,d5,m05,m15) ;
   result.a.d0 = r0 ;
   result.a.d1 = r1 ;
   result.a.d2 = r2 ;
   result.a.d3 = r3 ;
   result.a.d4 = r4 ;
   result.a.d5 = r5 ;
   result.b.d0 = d0 ;
   result.b.d1 = d1 ;
   result.b.d2 = d2 ;
   result.b.d3 = d3 ;
   result.b.d4 = d4 ;
   result.b.d5 = d5 ;
}

#if 0
/*
 * Test harness
 */
int mainx(int argc, const char** argv)
{
   if (argc >= 2)
   {
      char* dummy0 ;
      double a = strtod(argv[1],&dummy0) ;
      printf("Parameter %0.17e\n", a) ;

      double ex = hexpa(a) ;
      double exa = exp(a) ;

      double erfcca = erfcc(a) ;

      // Scaling so errors can be reported as multiples of ULP
      double escale = 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 * 8.0 ; // 2**53

      printf("Exp IEEE=%0.17e Seq=%0.17e (%0.17e %8.3f)\n",exa,ex,ex/exa,escale*(ex-exa)/exa) ;
      printf("erfcc   =%0.17e\n", erfcca) ;
      return 0 ;
   } else {
      printf("%s 2.0 : simulate exponentiation algorithm for parameter 2.0"
             "\n", argv[0]) ;
     return 1 ;
   } /* endif */
}

/*
 * Test harness
 */
int mainy(int argc, const char** argv)
{
   const int a=atoi(argv[1]) ;
   const double qa = 8.0/a ;
   double ra = 0.0 ;
   double sf = 0.0 ;
   double sdf = 0.0 ;
   for (int b=0; b<a; b+=6)
   {
      double6 x ;
      x.d0 = ra ;
      x.d1 = ra + 1.0*qa ;
      x.d2 = ra + 2.0*qa ;
      x.d3 = ra + 3.0*qa ;
      x.d4 = ra + 4.0*qa ;
      x.d5 = ra + 5.0*qa ;
      ra += 6.0*qa ;
      double6pair r ;
      erfccd6a(r,x) ;
      sf  += r.a.d0 + r.a.d1 + r.a.d2 + r.a.d3 + r.a.d4 + r.a.d5 ;
      sdf += r.b.d0 + r.b.d1 + r.b.d2 + r.b.d3 + r.b.d4 + r.b.d5 ;
   } /* endfor */
   printf("%0.17e %0.17e\n",sf,sdf) ;
   return 0 ;
}
#else
// Test harness for DoubleHummer timing

void fewghexp(double* f, const double* x, int count)
{
  double x0 = 0.0 ;
  double x1 = 0.0 ;
  double x2 = 0.0 ;
  double x3 = 0.0 ;
  double x4 = 0.0 ;
  double x5 = 0.0 ;
  double x6 = 0.0 ;
  double x7 = 0.0 ;
  double x8 = 0.0 ;
  double x9 = 0.0 ;
  double r[10] ;
  switch (count)
  {
     case 9: x8 = x[8] ;
     case 8: x7 = x[7] ;
     case 7: x6 = x[6] ;
     case 6: x5 = x[5] ;
     case 5: x4 = x[4] ;
     case 4: x3 = x[3] ;
     case 3: x2 = x[2] ;
     case 2: x1 = x[1] ;
     case 1: x0 = x[0] ;
  } /* endswitch */
  ghexp10(r,x) ;
  double r0 = r[0] ;
  double r1 = r[1] ;
  double r2 = r[2] ;
  double r3 = r[3] ;
  double r4 = r[4] ;
  double r5 = r[5] ;
  double r6 = r[6] ;
  double r7 = r[7] ;
  double r8 = r[8] ;
  switch (count)
  {
     case 9: f[8] = r8 ;
     case 8: f[7] = r7 ;
     case 7: f[6] = r6 ;
     case 6: f[5] = r5 ;
     case 5: f[4] = r4 ;
     case 4: f[3] = r3 ;
     case 3: f[2] = r2 ;
     case 2: f[1] = r1 ;
     case 1: f[0] = r0 ;
  } /* endswitch */
}

void ghexp10l(double* f, const double* x, int groupcount)
{
   for (int a=0; a<groupcount;a+=1 )
   {
      ghexp10(f+10*a, x+10*a) ;
   } /* endfor */
}

extern "C" {
   void arbexp(double* f, const double* x, int count) ;
   } ;
void arbexp(double* f, const double* x, int count)
{
   int tencount = count/10 ;
   int unitcount = count%10 ;
   if (count >= 20 )
   {
     ghexp10l(f,x,tencount-1) ;
     ghexp10(f+(tencount-1)*10,x+(tencount-1)*10) ;
     if (unitcount > 0)
     {
       ghexp10(f+(tencount-1)*10+unitcount,x+(tencount-1)*10+unitcount) ;
     } /* endif */
   }
   else if ( count >= 10 )
   {
      ghexp10(f,x) ;
      if (unitcount > 0 )
      {
         ghexp10(f+unitcount,x+unitcount) ;
      } /* endif */
   }
   else
   {
      fewghexp(f,x,count) ;
   } /* endif */
}

#endif
