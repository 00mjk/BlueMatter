/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
/*
 * Test cases to explore floating-point efficiency on Blue Light with double hummer
 *
 *  Bond angle computation
 *
 *  This tests the compiler's ability to
 *  1) Assign registers effectively, when spills are logically required
 *  2) Pair operations up for issuing Double Hummer parallel instructions
 *  3) Schedule instructions to avoid delays from data dependencies
 *  4) Choose optimally whether to do 'load parallel' and 'store parallel'
 *
 *  Expectations for the loop
 *  1) Efficient choice of reloading registers
 *  2) Efficient grouping of cross and dot products (maybe 2 passes, 5 per pass)
 *  3) scalar ops (1/sqrt(), negate, fsel, multiply, atrig, subtract, etc.)
 *     grouped for 10-way interleave
 *  4) Efficient management of array indexing for parameter loading and result
 *     writeback, to minimise reloads of integer registers and delays due to
 *     integer arithmetic.
 *
 *  Additional expectation
 *  At the end of the loop, the compiler will use the fact that addition is associative to rearrange the
 *  energy sum as (((0+1)+(2+3))+((4+5)+(6+7)))+(8+9) or something similar, to best hide the 5-cycle
 *  adder pipeline delay, and to exploit Double Hummer if appropriate
 *
 *  Note: This test case requires many more intermediate values than the
 *  machine has registers. It explores the compiler's ability to select blocks
 *  to run concurrently, and the compiler's ability to organise spill space
 *  to mimimise delays (e.g. to use quad store or quad load on spill space)
 * Chris Ward
 *  20010814
 */
#include <BlueMatter/fpexploit.hpp>
#include <BlueMatter/fpatrig.hpp>
/*
 * int BondRegisterIndexBA@ = HarmonicAngleSpecTable[@].mBondRegisterIndexBA ;
 * int BondRegisterIndexBC@ = HarmonicAngleSpecTable[@].mBondRegisterIndexBC ;
 * XYZ BondVectorBC@ = BondVectorTable[BondRegisterIndexBC@].mVec ;
 * XYZ BondVectorBA@ = BondVectorTable[BondRegisterIndexBA@].mVec ;
 * XYZ RP@= CrossProduct(BondVectorBC,BondVectorBA) ;
 * double RPL2@ = sqr(RP@) ;
 * double RecipBA@ = BondVectorTable[BondRegisterIndexBA@].mRecipLength ;
 * double RecipBC@ = BondVectorTable[BondRegisterIndexBC@].mRecipLength ;
 * double RPL@ = 1.0/sqrt(RPL2@) ;
 * double SRPL@ = fsel(-RPL@ ,0.0 ,RPL) ;
 * double DotBABC@ = DotProduct(BondVectorBA@,BondVectorBC@) ;
 * double RecipBABC@ = RecipBA@ * RecipBC@ ;
 * double SINTHE@ = RecipBABC@ * RPL2@ * SRPL@ ;
 * double COSTHE@ = DotBABC@ * RecipBABC ;
 * double THETA@ = atrig(SINTHE@, COSTHE@) ;
 * double DTHETA@ = THETA@ - HarmonicAngleSpecTable[@].mth0 ;
 * double KDETHETA@ = DTHETA@ * HarmonicAngleSpecTable[@].mk ;
 * double AngleEnergy@ = KDETHETA@ * DTHETA@ ;
 * double DEDTH@ = 2.0 * KDETHETA@ ;
 * double R12R@ = - RecipBA@ * RecipBA@ ;
 * double R32R@ = RecipCA@ * RecipCA@ ;
 * double SRPLDEDTH@ = SRPL@ @ DEDTH@ ;
 * XYZ ForceA@ = CrossProduct(BondVectorBA@, RP@) * (R12R@ * SRPLDEDTH@) ;
 * XYZ ForceC@ = CrossProduct(BondVectorCA@, RP@) * (R32R@ * SRPLDEDTH@) ;
 * XYZ ForceB@ = negate(sum(ForceA@,ForceC@)) ;
 *
 * PartialForceTable[HarmonicAngleSpecTable[@].mPartialForceRegisterIndexA] = ForceA@ ;
 * PartialForceTable[HarmonicAngleSpecTable[@].mPartialForceRegisterIndexB] = ForceB@ ;
 * PartialForceTable[HarmonicAngleSpecTable[@].mPartialForceRegisterIndexC] = ForceC@ ;
 * Energy@ += AngleEnergy@ ;
 */

#define TENWAY
void HarmonicAngleForce(
   XYZA* PartialForceTable
//   , double& TotalEnergy
   , const MD_BondVector* BondVectorTable
   , const MD_HarmonicAngleSpec* HarmonicAngleSpecTable
//   , unsigned int groupcount
   , double* TraceTable
   )
{
#pragma disjoint(* PartialForceTable, * BondVectorTable)
#pragma disjoint(* PartialForceTable, * HarmonicAngleSpecTable)

/*
  double Energy_0 = 0.0 ;
  double Energy_1 = 0.0 ;
  double Energy_2 = 0.0 ;
  double Energy_3 = 0.0 ;
  double Energy_4 = 0.0 ;
  double Energy_5 = 0.0 ;
#if defined(TENWAY)
  double Energy_6 = 0.0 ;
  double Energy_7 = 0.0 ;
  double Energy_8 = 0.0 ;
  double Energy_9 = 0.0 ;
#endif
*/
//  double Energy_A = 0.0 ;
//  double Energy_B = 0.0 ;

  int BondRegisterIndexBA_0 = HarmonicAngleSpecTable[10*0+0].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_0 = HarmonicAngleSpecTable[10*0+0].mBondRegisterIndexBC ;
  int BondRegisterIndexBA_1 = HarmonicAngleSpecTable[10*0+1].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_1 = HarmonicAngleSpecTable[10*0+1].mBondRegisterIndexBC ;
  int BondRegisterIndexBA_2 = HarmonicAngleSpecTable[10*0+2].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_2 = HarmonicAngleSpecTable[10*0+2].mBondRegisterIndexBC ;
  int BondRegisterIndexBA_3 = HarmonicAngleSpecTable[10*0+3].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_3 = HarmonicAngleSpecTable[10*0+3].mBondRegisterIndexBC ;
  int BondRegisterIndexBA_4 = HarmonicAngleSpecTable[10*0+4].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_4 = HarmonicAngleSpecTable[10*0+4].mBondRegisterIndexBC ;
  int BondRegisterIndexBA_5 = HarmonicAngleSpecTable[10*0+5].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_5 = HarmonicAngleSpecTable[10*0+5].mBondRegisterIndexBC ;
  int BondRegisterIndexBA_6 = HarmonicAngleSpecTable[10*0+6].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_6 = HarmonicAngleSpecTable[10*0+6].mBondRegisterIndexBC ;
  int BondRegisterIndexBA_7 = HarmonicAngleSpecTable[10*0+7].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_7 = HarmonicAngleSpecTable[10*0+7].mBondRegisterIndexBC ;
  int BondRegisterIndexBA_8 = HarmonicAngleSpecTable[10*0+8].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_8 = HarmonicAngleSpecTable[10*0+8].mBondRegisterIndexBC ;
  int BondRegisterIndexBA_9 = HarmonicAngleSpecTable[10*0+9].mBondRegisterIndexBA ;
  int BondRegisterIndexBC_9 = HarmonicAngleSpecTable[10*0+9].mBondRegisterIndexBC ;

  unsigned int a=0 ;
//  for (unsigned int a=0; a<=groupcount ; a+=1)
  {

    XYZ BondVectorBC_0 = BondVectorTable[BondRegisterIndexBC_0].mVec ;
    XYZ BondVectorBA_0 = BondVectorTable[BondRegisterIndexBA_0].mVec ;
    XYZ BondVectorBC_1 = BondVectorTable[BondRegisterIndexBC_1].mVec ;
    XYZ BondVectorBA_1 = BondVectorTable[BondRegisterIndexBA_1].mVec ;

/*a0*/    XYZ RP_0= CrossProduct(BondVectorBC_0,BondVectorBA_0) ;
/*a1*/    XYZ RP_1= CrossProduct(BondVectorBC_1,BondVectorBA_1) ;

/*b0*/ // double RPL2_0 = sqr(RP_0) ;
/*b1*/ // double RPL2_1 = sqr(RP_1) ;
/*g0*/    double DotBABC_0 = DotProduct(BondVectorBA_0,BondVectorBC_0) ;
/*g1*/    double DotBABC_1 = DotProduct(BondVectorBA_1,BondVectorBC_1) ;
/*b0*/    double RPL2_0 = BondVectorTable[BondRegisterIndexBC_0].mSquareLength*BondVectorTable[BondRegisterIndexBA_0].mSquareLength - DotBABC_0*DotBABC_0 ;
/*b0*/    double RPL2_1 = BondVectorTable[BondRegisterIndexBC_1].mSquareLength*BondVectorTable[BondRegisterIndexBA_1].mSquareLength - DotBABC_1*DotBABC_1 ;

    XYZ XPA_0 = CrossProduct(BondVectorBA_0, RP_0) ;
    XYZ XPC_0 = CrossProduct(BondVectorBC_0, RP_0) ;
    XYZ XPA_1 = CrossProduct(BondVectorBA_1, RP_1) ;
    XYZ XPC_1 = CrossProduct(BondVectorBC_1, RP_1) ;

    XYZ BondVectorBC_2 = BondVectorTable[BondRegisterIndexBC_2].mVec ;
    XYZ BondVectorBA_2 = BondVectorTable[BondRegisterIndexBA_2].mVec ;
    XYZ BondVectorBC_3 = BondVectorTable[BondRegisterIndexBC_3].mVec ;
    XYZ BondVectorBA_3 = BondVectorTable[BondRegisterIndexBA_3].mVec ;

/*a2*/    XYZ RP_2= CrossProduct(BondVectorBC_2,BondVectorBA_2) ;
/*a3*/    XYZ RP_3= CrossProduct(BondVectorBC_3,BondVectorBA_3) ;

/*b2*/ // double RPL2_2 = sqr(RP_2) ;
/*b3*/ // double RPL2_3 = sqr(RP_3) ;
/*g2*/    double DotBABC_2 = DotProduct(BondVectorBA_2,BondVectorBC_2) ;
/*g3*/    double DotBABC_3 = DotProduct(BondVectorBA_3,BondVectorBC_3) ;

/*b0*/    double RPL2_2 = BondVectorTable[BondRegisterIndexBC_2].mSquareLength*BondVectorTable[BondRegisterIndexBA_2].mSquareLength - DotBABC_2*DotBABC_2 ;
/*b0*/    double RPL2_3 = BondVectorTable[BondRegisterIndexBC_3].mSquareLength*BondVectorTable[BondRegisterIndexBA_3].mSquareLength - DotBABC_3*DotBABC_3 ;
    XYZ XPA_2 = CrossProduct(BondVectorBA_2, RP_2) ;
    XYZ XPC_2 = CrossProduct(BondVectorBC_2, RP_2) ;
    XYZ XPA_3 = CrossProduct(BondVectorBA_3, RP_3) ;
    XYZ XPC_3 = CrossProduct(BondVectorBC_3, RP_3) ;

    XYZ BondVectorBC_4 = BondVectorTable[BondRegisterIndexBC_4].mVec ;
    XYZ BondVectorBA_4 = BondVectorTable[BondRegisterIndexBA_4].mVec ;
    XYZ BondVectorBC_5 = BondVectorTable[BondRegisterIndexBC_5].mVec ;
    XYZ BondVectorBA_5 = BondVectorTable[BondRegisterIndexBA_5].mVec ;

/*a4*/    XYZ RP_4= CrossProduct(BondVectorBC_4,BondVectorBA_4) ;
/*a5*/    XYZ RP_5= CrossProduct(BondVectorBC_5,BondVectorBA_5) ;

/*b4*/ // double RPL2_4 = sqr(RP_4) ;
/*b5*/ // double RPL2_5 = sqr(RP_5) ;
/*g4*/    double DotBABC_4 = DotProduct(BondVectorBA_4,BondVectorBC_4) ;
/*g5*/    double DotBABC_5 = DotProduct(BondVectorBA_5,BondVectorBC_5) ;

/*b0*/    double RPL2_4 = BondVectorTable[BondRegisterIndexBC_4].mSquareLength*BondVectorTable[BondRegisterIndexBA_4].mSquareLength - DotBABC_4*DotBABC_4 ;
/*b0*/    double RPL2_5 = BondVectorTable[BondRegisterIndexBC_5].mSquareLength*BondVectorTable[BondRegisterIndexBA_5].mSquareLength - DotBABC_5*DotBABC_5 ;
    XYZ XPA_4 = CrossProduct(BondVectorBA_4, RP_4) ;
    XYZ XPC_4 = CrossProduct(BondVectorBC_4, RP_4) ;
    XYZ XPA_5 = CrossProduct(BondVectorBA_5, RP_5) ;
    XYZ XPC_5 = CrossProduct(BondVectorBC_5, RP_5) ;

    XYZ BondVectorBC_6 = BondVectorTable[BondRegisterIndexBC_6].mVec ;
    XYZ BondVectorBA_6 = BondVectorTable[BondRegisterIndexBA_6].mVec ;

    XYZ BondVectorBC_7 = BondVectorTable[BondRegisterIndexBC_7].mVec ;
    XYZ BondVectorBA_7 = BondVectorTable[BondRegisterIndexBA_7].mVec ;

/*a6*/    XYZ RP_6= CrossProduct(BondVectorBC_6,BondVectorBA_6) ;
/*a7*/    XYZ RP_7= CrossProduct(BondVectorBC_7,BondVectorBA_7) ;
/*b6*/ // double RPL2_6 = sqr(RP_6) ;
/*b7*/ // double RPL2_7 = sqr(RP_7) ;
/*g6*/    double DotBABC_6 = DotProduct(BondVectorBA_6,BondVectorBC_6) ;
/*g7*/    double DotBABC_7 = DotProduct(BondVectorBA_7,BondVectorBC_7) ;
/*b0*/    double RPL2_6 = BondVectorTable[BondRegisterIndexBC_6].mSquareLength*BondVectorTable[BondRegisterIndexBA_6].mSquareLength - DotBABC_6*DotBABC_6 ;
/*b0*/    double RPL2_7 = BondVectorTable[BondRegisterIndexBC_7].mSquareLength*BondVectorTable[BondRegisterIndexBA_7].mSquareLength - DotBABC_7*DotBABC_7 ;

    XYZ XPA_6 = CrossProduct(BondVectorBA_6, RP_6) ;
    XYZ XPC_6 = CrossProduct(BondVectorBC_6, RP_6) ;
    XYZ XPA_7 = CrossProduct(BondVectorBA_7, RP_7) ;
    XYZ XPC_7 = CrossProduct(BondVectorBC_7, RP_7) ;

    XYZ BondVectorBC_8 = BondVectorTable[BondRegisterIndexBC_8].mVec ;
    XYZ BondVectorBA_8 = BondVectorTable[BondRegisterIndexBA_8].mVec ;

    XYZ BondVectorBC_9 = BondVectorTable[BondRegisterIndexBC_9].mVec ;
    XYZ BondVectorBA_9 = BondVectorTable[BondRegisterIndexBA_9].mVec ;
/*a8*/    XYZ RP_8= CrossProduct(BondVectorBC_8,BondVectorBA_8) ;
/*a9*/    XYZ RP_9= CrossProduct(BondVectorBC_9,BondVectorBA_9) ;

/*b8*/ // double RPL2_8 = sqr(RP_8) ;
/*b9*/ // double RPL2_9 = sqr(RP_9) ;

/*g8*/    double DotBABC_8 = DotProduct(BondVectorBA_8,BondVectorBC_8) ;
/*g9*/    double DotBABC_9 = DotProduct(BondVectorBA_9,BondVectorBC_9) ;
/*b0*/    double RPL2_8 = BondVectorTable[BondRegisterIndexBC_8].mSquareLength*BondVectorTable[BondRegisterIndexBA_8].mSquareLength - DotBABC_8*DotBABC_8 ;
/*b0*/    double RPL2_9 = BondVectorTable[BondRegisterIndexBC_9].mSquareLength*BondVectorTable[BondRegisterIndexBA_9].mSquareLength - DotBABC_9*DotBABC_9 ;

    XYZ XPA_8 = CrossProduct(BondVectorBA_8, RP_8) ;
    XYZ XPC_8 = CrossProduct(BondVectorBC_8, RP_8) ;
    XYZ XPA_9 = CrossProduct(BondVectorBA_9, RP_9) ;
    XYZ XPC_9 = CrossProduct(BondVectorBC_9, RP_9) ;

/*e0*/    double RPL_0 = 1.0/sqrt(RPL2_0) ;
/*e1*/    double RPL_1 = 1.0/sqrt(RPL2_1) ;
/*e2*/    double RPL_2 = 1.0/sqrt(RPL2_2) ;
/*e3*/    double RPL_3 = 1.0/sqrt(RPL2_3) ;
/*e4*/    double RPL_4 = 1.0/sqrt(RPL2_4) ;
/*e5*/    double RPL_5 = 1.0/sqrt(RPL2_5) ;
/*e6*/    double RPL_6 = 1.0/sqrt(RPL2_6) ;
/*e7*/    double RPL_7 = 1.0/sqrt(RPL2_7) ;
/*e8*/    double RPL_8 = 1.0/sqrt(RPL2_8) ;
/*e9*/    double RPL_9 = 1.0/sqrt(RPL2_9) ;

/*0c*/    double RecipBA_0 = BondVectorTable[BondRegisterIndexBA_0].mRecipLength ;
/*0d*/    double RecipBC_0 = BondVectorTable[BondRegisterIndexBC_0].mRecipLength ;

/*f0*/    double SRPL_0 = fsel(-RPL_0 ,0.0 ,RPL_0) ;
/*f1*/    double SRPL_1 = fsel(-RPL_1 ,0.0 ,RPL_1) ;
/*1c*/    double RecipBA_1 = BondVectorTable[BondRegisterIndexBA_1].mRecipLength ;
/*1d*/    double RecipBC_1 = BondVectorTable[BondRegisterIndexBC_1].mRecipLength ;
/*f2*/    double SRPL_2 = fsel(-RPL_2 ,0.0 ,RPL_2) ;
/*f3*/    double SRPL_3 = fsel(-RPL_3 ,0.0 ,RPL_3) ;
/*2c*/    double RecipBA_2 = BondVectorTable[BondRegisterIndexBA_2].mRecipLength ;
/*2d*/    double RecipBC_2 = BondVectorTable[BondRegisterIndexBC_2].mRecipLength ;
/*f4*/    double SRPL_4 = fsel(-RPL_4 ,0.0 ,RPL_4) ;
/*f5*/    double SRPL_5 = fsel(-RPL_5 ,0.0 ,RPL_5) ;
/*3c*/    double RecipBA_3 = BondVectorTable[BondRegisterIndexBA_3].mRecipLength ;
/*3d*/    double RecipBC_3 = BondVectorTable[BondRegisterIndexBC_3].mRecipLength ;
/*f6*/    double SRPL_6 = fsel(-RPL_6 ,0.0 ,RPL_6) ;
/*f7*/    double SRPL_7 = fsel(-RPL_7 ,0.0 ,RPL_7) ;
/*4c*/    double RecipBA_4 = BondVectorTable[BondRegisterIndexBA_4].mRecipLength ;
/*4d*/    double RecipBC_4 = BondVectorTable[BondRegisterIndexBC_4].mRecipLength ;
/*f8*/    double SRPL_8 = fsel(-RPL_8 ,0.0 ,RPL_8) ;
/*f9*/    double SRPL_9 = fsel(-RPL_9 ,0.0 ,RPL_9) ;

          double STM_0 = RPL2_0 * SRPL_0 ;
          double STM_1 = RPL2_1 * SRPL_1 ;
          double STM_2 = RPL2_2 * SRPL_2 ;
          double STM_3 = RPL2_3 * SRPL_3 ;
          double STM_4 = RPL2_4 * SRPL_4 ;
          double STM_5 = RPL2_5 * SRPL_5 ;
          double STM_6 = RPL2_6 * SRPL_6 ;
          double STM_7 = RPL2_7 * SRPL_7 ;
          double STM_8 = RPL2_8 * SRPL_8 ;
          double STM_9 = RPL2_9 * SRPL_9 ;

/*5c*/    double RecipBA_5 = BondVectorTable[BondRegisterIndexBA_5].mRecipLength ;
/*5d*/    double RecipBC_5 = BondVectorTable[BondRegisterIndexBC_5].mRecipLength ;
/*h0*/    double RecipBABC_0 = RecipBA_0 * RecipBC_0 ;
/*h1*/    double RecipBABC_1 = RecipBA_1 * RecipBC_1 ;
/*6c*/    double RecipBA_6 = BondVectorTable[BondRegisterIndexBA_6].mRecipLength ;
/*6d*/    double RecipBC_6 = BondVectorTable[BondRegisterIndexBC_6].mRecipLength ;
/*h2*/    double RecipBABC_2 = RecipBA_2 * RecipBC_2 ;
/*h3*/    double RecipBABC_3 = RecipBA_3 * RecipBC_3 ;
/*7c*/    double RecipBA_7 = BondVectorTable[BondRegisterIndexBA_7].mRecipLength ;
/*7d*/    double RecipBC_7 = BondVectorTable[BondRegisterIndexBC_7].mRecipLength ;
/*h4*/    double RecipBABC_4 = RecipBA_4 * RecipBC_4 ;
/*h5*/    double RecipBABC_5 = RecipBA_5 * RecipBC_5 ;
/*8c*/    double RecipBA_8 = BondVectorTable[BondRegisterIndexBA_8].mRecipLength ;
/*8d*/    double RecipBC_8 = BondVectorTable[BondRegisterIndexBC_8].mRecipLength ;
/*h6*/    double RecipBABC_6 = RecipBA_6 * RecipBC_6 ;
/*h7*/    double RecipBABC_7 = RecipBA_7 * RecipBC_7 ;
/*9c*/    double RecipBA_9 = BondVectorTable[BondRegisterIndexBA_9].mRecipLength ;
/*9d*/    double RecipBC_9 = BondVectorTable[BondRegisterIndexBC_9].mRecipLength ;
/*h8*/    double RecipBABC_8 = RecipBA_8 * RecipBC_8 ;
/*h9*/    double RecipBABC_9 = RecipBA_9 * RecipBC_9 ;

/*i0*/    double SINTHE_0 = RecipBABC_0 * STM_0 ;
/*i1*/    double SINTHE_1 = RecipBABC_1 * STM_1 ;
/*i2*/    double SINTHE_2 = RecipBABC_2 * STM_2 ;
/*i3*/    double SINTHE_3 = RecipBABC_3 * STM_3 ;
/*i4*/    double SINTHE_4 = RecipBABC_4 * STM_4 ;
/*i5*/    double SINTHE_5 = RecipBABC_5 * STM_5 ;
/*i6*/    double SINTHE_6 = RecipBABC_6 * STM_6 ;
/*i7*/    double SINTHE_7 = RecipBABC_7 * STM_7 ;
/*i8*/    double SINTHE_8 = RecipBABC_8 * STM_8 ;
/*i9*/    double SINTHE_9 = RecipBABC_9 * STM_9 ;
/*j0*/    double COSTHE_0 = DotBABC_0 * RecipBABC_0 ;
/*j1*/    double COSTHE_1 = DotBABC_1 * RecipBABC_1 ;
/*j2*/    double COSTHE_2 = DotBABC_2 * RecipBABC_2 ;
/*j3*/    double COSTHE_3 = DotBABC_3 * RecipBABC_3 ;
/*j4*/    double COSTHE_4 = DotBABC_4 * RecipBABC_4 ;
/*j5*/    double COSTHE_5 = DotBABC_5 * RecipBABC_5 ;
/*j6*/    double COSTHE_6 = DotBABC_6 * RecipBABC_6 ;
/*j7*/    double COSTHE_7 = DotBABC_7 * RecipBABC_7 ;
/*j8*/    double COSTHE_8 = DotBABC_8 * RecipBABC_8 ;
/*j9*/    double COSTHE_9 = DotBABC_9 * RecipBABC_9 ;
/*k0*/    double THETA_0 = atrig(SINTHE_0, COSTHE_0) ;
/*k1*/    double THETA_1 = atrig(SINTHE_1, COSTHE_1) ;
/*k2*/    double THETA_2 = atrig(SINTHE_2, COSTHE_2) ;
/*k3*/    double THETA_3 = atrig(SINTHE_3, COSTHE_3) ;
/*k4*/    double THETA_4 = atrig(SINTHE_4, COSTHE_4) ;
/*k5*/    double THETA_5 = atrig(SINTHE_5, COSTHE_5) ;
/*k6*/    double THETA_6 = atrig(SINTHE_6, COSTHE_6) ;
/*k7*/    double THETA_7 = atrig(SINTHE_7, COSTHE_7) ;
/*k8*/    double THETA_8 = atrig(SINTHE_8, COSTHE_8) ;
/*k9*/    double THETA_9 = atrig(SINTHE_9, COSTHE_9) ;
/*l0*/    double DTHETA_0 = THETA_0 - HarmonicAngleSpecTable[10*a+0].mth0 ;
/*l1*/    double DTHETA_1 = THETA_1 - HarmonicAngleSpecTable[10*a+1].mth0 ;
/*l2*/    double DTHETA_2 = THETA_2 - HarmonicAngleSpecTable[10*a+2].mth0 ;
/*l3*/    double DTHETA_3 = THETA_3 - HarmonicAngleSpecTable[10*a+3].mth0 ;
/*l4*/    double DTHETA_4 = THETA_4 - HarmonicAngleSpecTable[10*a+4].mth0 ;
/*l5*/    double DTHETA_5 = THETA_5 - HarmonicAngleSpecTable[10*a+5].mth0 ;
/*l6*/    double DTHETA_6 = THETA_6 - HarmonicAngleSpecTable[10*a+6].mth0 ;
/*l7*/    double DTHETA_7 = THETA_7 - HarmonicAngleSpecTable[10*a+7].mth0 ;
/*l8*/    double DTHETA_8 = THETA_8 - HarmonicAngleSpecTable[10*a+8].mth0 ;
/*l9*/    double DTHETA_9 = THETA_9 - HarmonicAngleSpecTable[10*a+9].mth0 ;
/*m0*/    double KDETHETA_0 = DTHETA_0 * HarmonicAngleSpecTable[10*a+0].mk ;
/*m1*/    double KDETHETA_1 = DTHETA_1 * HarmonicAngleSpecTable[10*a+1].mk ;
/*m2*/    double KDETHETA_2 = DTHETA_2 * HarmonicAngleSpecTable[10*a+2].mk ;
/*m3*/    double KDETHETA_3 = DTHETA_3 * HarmonicAngleSpecTable[10*a+3].mk ;
/*m4*/    double KDETHETA_4 = DTHETA_4 * HarmonicAngleSpecTable[10*a+4].mk ;
/*m5*/    double KDETHETA_5 = DTHETA_5 * HarmonicAngleSpecTable[10*a+5].mk ;
/*m6*/    double KDETHETA_6 = DTHETA_6 * HarmonicAngleSpecTable[10*a+6].mk ;
/*m7*/    double KDETHETA_7 = DTHETA_7 * HarmonicAngleSpecTable[10*a+7].mk ;
/*m8*/    double KDETHETA_8 = DTHETA_8 * HarmonicAngleSpecTable[10*a+8].mk ;
/*m9*/    double KDETHETA_9 = DTHETA_9 * HarmonicAngleSpecTable[10*a+9].mk ;
/*n0*/    double AngleEnergy_0 = KDETHETA_0 * DTHETA_0 ;
/*n1*/    double AngleEnergy_1 = KDETHETA_1 * DTHETA_1 ;
/*n2*/    double AngleEnergy_2 = KDETHETA_2 * DTHETA_2 ;
/*n3*/    double AngleEnergy_3 = KDETHETA_3 * DTHETA_3 ;
/*n4*/    double AngleEnergy_4 = KDETHETA_4 * DTHETA_4 ;
/*n5*/    double AngleEnergy_5 = KDETHETA_5 * DTHETA_5 ;
/*n6*/    double AngleEnergy_6 = KDETHETA_6 * DTHETA_6 ;
/*n7*/    double AngleEnergy_7 = KDETHETA_7 * DTHETA_7 ;
/*n8*/    double AngleEnergy_8 = KDETHETA_8 * DTHETA_8 ;
/*n9*/    double AngleEnergy_9 = KDETHETA_9 * DTHETA_9 ;
//    Energy_A += AngleEnergy_0 ;
//    Energy_B += AngleEnergy_1 ;
/*o0*/    double DEDTH_0 = 2.0 * KDETHETA_0 ;
/*o1*/    double DEDTH_1 = 2.0 * KDETHETA_1 ;
/*o2*/    double DEDTH_2 = 2.0 * KDETHETA_2 ;
/*o3*/    double DEDTH_3 = 2.0 * KDETHETA_3 ;
/*o4*/    double DEDTH_4 = 2.0 * KDETHETA_4 ;
/*o5*/    double DEDTH_5 = 2.0 * KDETHETA_5 ;
/*o6*/    double DEDTH_6 = 2.0 * KDETHETA_6 ;
/*o7*/    double DEDTH_7 = 2.0 * KDETHETA_7 ;
/*o8*/    double DEDTH_8 = 2.0 * KDETHETA_8 ;
/*o9*/    double DEDTH_9 = 2.0 * KDETHETA_9 ;
//    Energy_A += AngleEnergy_2 ;
//    Energy_B += AngleEnergy_3 ;
/*p0*/    double R12R_0 = - RecipBA_0 * RecipBA_0 ;
/*p1*/    double R12R_1 = - RecipBA_1 * RecipBA_1 ;
/*p2*/    double R12R_2 = - RecipBA_2 * RecipBA_2 ;
/*p3*/    double R12R_3 = - RecipBA_3 * RecipBA_3 ;
/*p4*/    double R12R_4 = - RecipBA_4 * RecipBA_4 ;
/*p5*/    double R12R_5 = - RecipBA_5 * RecipBA_5 ;
/*p6*/    double R12R_6 = - RecipBA_6 * RecipBA_6 ;
/*p7*/    double R12R_7 = - RecipBA_7 * RecipBA_7 ;
/*p8*/    double R12R_8 = - RecipBA_8 * RecipBA_8 ;
/*p9*/    double R12R_9 = - RecipBA_9 * RecipBA_9 ;
//    Energy_A += AngleEnergy_4 ;
//    Energy_B += AngleEnergy_5 ;
/*q0*/    double R32R_0 = RecipBC_0 * RecipBC_0 ;
/*q1*/    double R32R_1 = RecipBC_1 * RecipBC_1 ;
/*q2*/    double R32R_2 = RecipBC_2 * RecipBC_2 ;
/*q3*/    double R32R_3 = RecipBC_3 * RecipBC_3 ;
/*q4*/    double R32R_4 = RecipBC_4 * RecipBC_4 ;
/*q5*/    double R32R_5 = RecipBC_5 * RecipBC_5 ;
/*q6*/    double R32R_6 = RecipBC_6 * RecipBC_6 ;
/*q7*/    double R32R_7 = RecipBC_7 * RecipBC_7 ;
/*q8*/    double R32R_8 = RecipBC_8 * RecipBC_8 ;
/*q9*/    double R32R_9 = RecipBC_9 * RecipBC_9 ;
//    Energy_A += AngleEnergy_6 ;
//    Energy_B += AngleEnergy_7 ;
/*r0*/    double SRPLDEDTH_0 = SRPL_0 * DEDTH_0 ;
/*r1*/    double SRPLDEDTH_1 = SRPL_1 * DEDTH_1 ;
/*r2*/    double SRPLDEDTH_2 = SRPL_2 * DEDTH_2 ;
/*r3*/    double SRPLDEDTH_3 = SRPL_3 * DEDTH_3 ;
/*r4*/    double SRPLDEDTH_4 = SRPL_4 * DEDTH_4 ;
/*r5*/    double SRPLDEDTH_5 = SRPL_5 * DEDTH_5 ;
/*r6*/    double SRPLDEDTH_6 = SRPL_6 * DEDTH_6 ;
/*r7*/    double SRPLDEDTH_7 = SRPL_7 * DEDTH_7 ;
/*r8*/    double SRPLDEDTH_8 = SRPL_8 * DEDTH_8 ;
/*r9*/    double SRPLDEDTH_9 = SRPL_9 * DEDTH_9 ;
//    Energy_A += AngleEnergy_8 ;
//    Energy_B += AngleEnergy_9 ;

          double PA_0 = R12R_0 * SRPLDEDTH_0 ;
          double PA_1 = R12R_1 * SRPLDEDTH_1 ;
          double PA_2 = R12R_2 * SRPLDEDTH_2 ;
          double PA_3 = R12R_3 * SRPLDEDTH_3 ;
          double PA_4 = R12R_4 * SRPLDEDTH_4 ;
          double PA_5 = R12R_5 * SRPLDEDTH_5 ;
          double PA_6 = R12R_6 * SRPLDEDTH_6 ;
          double PA_7 = R12R_7 * SRPLDEDTH_7 ;
          double PA_8 = R12R_8 * SRPLDEDTH_8 ;
          double PA_9 = R12R_9 * SRPLDEDTH_9 ;

          double PC_0 = R32R_0 * SRPLDEDTH_0 ;
          double PC_1 = R32R_1 * SRPLDEDTH_1 ;
          double PC_2 = R32R_2 * SRPLDEDTH_2 ;
          double PC_3 = R32R_3 * SRPLDEDTH_3 ;
          double PC_4 = R32R_4 * SRPLDEDTH_4 ;
          double PC_5 = R32R_5 * SRPLDEDTH_5 ;
          double PC_6 = R32R_6 * SRPLDEDTH_6 ;
          double PC_7 = R32R_7 * SRPLDEDTH_7 ;
          double PC_8 = R32R_8 * SRPLDEDTH_8 ;
          double PC_9 = R32R_9 * SRPLDEDTH_9 ;

/*s0*/    XYZ ForceA_0 = XPA_0 * PA_0 ;
/*t0*/    XYZ ForceC_0 = XPC_0 * PC_0 ;
/*u0*/    XYZ ForceB_0 = negate(sum(ForceA_0,ForceC_0)) ;
/*1s*/    XYZ ForceA_1 = XPA_1 * PA_1 ;
/*1t*/    XYZ ForceC_1 = XPC_1 * PC_1 ;
/*1u*/    XYZ ForceB_1 = negate(sum(ForceA_1,ForceC_1)) ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+0].mPartialForceRegisterIndexA].mXYZ = ForceA_0 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+0].mPartialForceRegisterIndexB].mXYZ = ForceB_0 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+0].mPartialForceRegisterIndexC].mXYZ = ForceC_0 ;
//  Energy_0 += AngleEnergy_0 ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+1].mPartialForceRegisterIndexA].mXYZ = ForceA_1 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+1].mPartialForceRegisterIndexB].mXYZ = ForceB_1 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+1].mPartialForceRegisterIndexC].mXYZ = ForceC_1 ;
//  Energy_1 += AngleEnergy_1 ;

//    BondRegisterIndexBA_0 = HarmonicAngleSpecTable[10*(a+1)+0].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_0 = HarmonicAngleSpecTable[10*(a+1)+0].mBondRegisterIndexBC ;
//    BondRegisterIndexBA_1 = HarmonicAngleSpecTable[10*(a+1)+1].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_1 = HarmonicAngleSpecTable[10*(a+1)+1].mBondRegisterIndexBC ;

/*2s*/    XYZ ForceA_2 = XPA_2 * PA_2 ;
/*2t*/    XYZ ForceC_2 = XPC_2 * PC_2 ;
/*2u*/    XYZ ForceB_2 = negate(sum(ForceA_2,ForceC_2)) ;
/*3s*/    XYZ ForceA_3 = XPA_3 * PA_3 ;
/*3t*/    XYZ ForceC_3 = XPC_3 * PC_3 ;
/*3u*/    XYZ ForceB_3 = negate(sum(ForceA_3,ForceC_3)) ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+2].mPartialForceRegisterIndexA].mXYZ = ForceA_2 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+2].mPartialForceRegisterIndexB].mXYZ = ForceB_2 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+2].mPartialForceRegisterIndexC].mXYZ = ForceC_2 ;
//  Energy_2 += AngleEnergy_2 ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+3].mPartialForceRegisterIndexA].mXYZ = ForceA_3 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+3].mPartialForceRegisterIndexB].mXYZ = ForceB_3 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+3].mPartialForceRegisterIndexC].mXYZ = ForceC_3 ;
//  Energy_3 += AngleEnergy_3 ;

//    BondRegisterIndexBA_2 = HarmonicAngleSpecTable[10*(a+1)+2].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_2 = HarmonicAngleSpecTable[10*(a+1)+2].mBondRegisterIndexBC ;
//    BondRegisterIndexBA_3 = HarmonicAngleSpecTable[10*(a+1)+3].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_3 = HarmonicAngleSpecTable[10*(a+1)+3].mBondRegisterIndexBC ;

/*4s*/    XYZ ForceA_4 = XPA_4 * PA_4 ;
/*4t*/    XYZ ForceC_4 = XPC_4 * PC_4 ;
/*4u*/    XYZ ForceB_4 = negate(sum(ForceA_4,ForceC_4)) ;
/*5s*/    XYZ ForceA_5 = XPA_5 * PA_5 ;
/*5t*/    XYZ ForceC_5 = XPC_5 * PC_5 ;
/*5u*/    XYZ ForceB_5 = negate(sum(ForceA_5,ForceC_5)) ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+4].mPartialForceRegisterIndexA].mXYZ = ForceA_4 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+4].mPartialForceRegisterIndexB].mXYZ = ForceB_4 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+4].mPartialForceRegisterIndexC].mXYZ = ForceC_4 ;
//  Energy_4 += AngleEnergy_4 ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+5].mPartialForceRegisterIndexA].mXYZ = ForceA_5 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+5].mPartialForceRegisterIndexB].mXYZ = ForceB_5 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+5].mPartialForceRegisterIndexC].mXYZ = ForceC_5 ;
//  Energy_5 += AngleEnergy_5 ;

//    BondRegisterIndexBA_4 = HarmonicAngleSpecTable[10*(a+1)+4].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_4 = HarmonicAngleSpecTable[10*(a+1)+4].mBondRegisterIndexBC ;
//    BondRegisterIndexBA_5 = HarmonicAngleSpecTable[10*(a+1)+5].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_5 = HarmonicAngleSpecTable[10*(a+1)+5].mBondRegisterIndexBC ;

/*6s*/    XYZ ForceA_6 = XPA_6 * PA_6 ;
/*6t*/    XYZ ForceC_6 = XPC_6 * PC_6 ;
/*6u*/    XYZ ForceB_6 = negate(sum(ForceA_6,ForceC_6)) ;
/*7s*/    XYZ ForceA_7 = XPA_7 * PA_7 ;
/*7t*/    XYZ ForceC_7 = XPC_7 * PC_7 ;
/*7u*/    XYZ ForceB_7 = negate(sum(ForceA_7,ForceC_7)) ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+6].mPartialForceRegisterIndexA].mXYZ = ForceA_6 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+6].mPartialForceRegisterIndexB].mXYZ = ForceB_6 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+6].mPartialForceRegisterIndexC].mXYZ = ForceC_6 ;
//  Energy_6 += AngleEnergy_6 ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+7].mPartialForceRegisterIndexA].mXYZ = ForceA_7 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+7].mPartialForceRegisterIndexB].mXYZ = ForceB_7 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+7].mPartialForceRegisterIndexC].mXYZ = ForceC_7 ;
//  Energy_7 += AngleEnergy_7 ;

//    BondRegisterIndexBA_6 = HarmonicAngleSpecTable[10*(a+1)+6].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_6 = HarmonicAngleSpecTable[10*(a+1)+6].mBondRegisterIndexBC ;
//    BondRegisterIndexBA_7 = HarmonicAngleSpecTable[10*(a+1)+7].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_7 = HarmonicAngleSpecTable[10*(a+1)+7].mBondRegisterIndexBC ;

/*8s*/    XYZ ForceA_8 = XPA_8 * PA_8 ;
/*8t*/    XYZ ForceC_8 = XPC_8 * PC_8 ;
/*8u*/    XYZ ForceB_8 = negate(sum(ForceA_8,ForceC_8)) ;
/*9s*/    XYZ ForceA_9 = XPA_9 * PA_9 ;
/*9t*/    XYZ ForceC_9 = XPC_9 * PC_9 ;
/*9u*/    XYZ ForceB_9 = negate(sum(ForceA_9,ForceC_9)) ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+8].mPartialForceRegisterIndexA].mXYZ = ForceA_8 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+8].mPartialForceRegisterIndexB].mXYZ = ForceB_8 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+8].mPartialForceRegisterIndexC].mXYZ = ForceC_8 ;
//  Energy_8 += AngleEnergy_8 ;

    PartialForceTable[HarmonicAngleSpecTable[10*a+9].mPartialForceRegisterIndexA].mXYZ = ForceA_9 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+9].mPartialForceRegisterIndexB].mXYZ = ForceB_9 ;
    PartialForceTable[HarmonicAngleSpecTable[10*a+9].mPartialForceRegisterIndexC].mXYZ = ForceC_9 ;
//  Energy_9 += AngleEnergy_9;

//    BondRegisterIndexBA_8 = HarmonicAngleSpecTable[10*(a+1)+8].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_8 = HarmonicAngleSpecTable[10*(a+1)+8].mBondRegisterIndexBC ;
//    BondRegisterIndexBA_9 = HarmonicAngleSpecTable[10*(a+1)+9].mBondRegisterIndexBA ;
//    BondRegisterIndexBC_9 = HarmonicAngleSpecTable[10*(a+1)+9].mBondRegisterIndexBC ;

   /*
    * Compute a 'trace', a single result for each way, to give the scheduler a target
    */
   TraceTable[10*a+0] = AngleEnergy_0 + sqr(ForceA_0) + sqr(ForceB_0) + sqr(ForceC_0) ;
   TraceTable[10*a+1] = AngleEnergy_1 + sqr(ForceA_1) + sqr(ForceB_1) + sqr(ForceC_1) ;
   TraceTable[10*a+2] = AngleEnergy_2 + sqr(ForceA_2) + sqr(ForceB_2) + sqr(ForceC_2) ;
   TraceTable[10*a+3] = AngleEnergy_3 + sqr(ForceA_3) + sqr(ForceB_3) + sqr(ForceC_3) ;
   TraceTable[10*a+4] = AngleEnergy_4 + sqr(ForceA_4) + sqr(ForceB_4) + sqr(ForceC_4) ;
   TraceTable[10*a+5] = AngleEnergy_5 + sqr(ForceA_5) + sqr(ForceB_5) + sqr(ForceC_5) ;
   TraceTable[10*a+6] = AngleEnergy_6 + sqr(ForceA_6) + sqr(ForceB_6) + sqr(ForceC_6) ;
   TraceTable[10*a+7] = AngleEnergy_7 + sqr(ForceA_7) + sqr(ForceB_7) + sqr(ForceC_7) ;
   TraceTable[10*a+8] = AngleEnergy_8 + sqr(ForceA_8) + sqr(ForceB_8) + sqr(ForceC_8) ;
   TraceTable[10*a+9] = AngleEnergy_9 + sqr(ForceA_9) + sqr(ForceB_9) + sqr(ForceC_9) ;
  } /* endfor */
/*
  TotalEnergy += Energy_0
               + Energy_1
               + Energy_2
               + Energy_3
               + Energy_4
               + Energy_5
               + Energy_6
               + Energy_7
               + Energy_8
               + Energy_9
               ;
*/
//   TotalEnergy += Energy_A + Energy_B ;
}
