/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include <BlueMatter/fpexploit.hpp>
// #define WRITEOUT
#if defined(WRITEOUT)
#include <iostream.h>
#endif

static const MD_Atom Waters[] = {
   { 0.0, 0.0, 0.0 }, { 0.0, 0.0, 1.0 }, {0.0, 1.0, 1.0}
  ,{ 1.0, 0.0, 0.0 }, { 1.0, 0.0, 1.0 }, {1.0, 1.0, 1.0}
  ,{ 2.0, 0.0, 0.0 }, { 2.0, 0.0, 1.0 }, {2.0, 1.0, 1.0}
  ,{ 3.0, 0.0, 0.0 }, { 3.0, 0.0, 1.0 }, {3.0, 1.0, 1.0}
  ,{ 4.0, 0.0, 0.0 }, { 4.0, 0.0, 1.0 }, {4.0, 1.0, 1.0}
  ,{ 5.0, 0.0, 0.0 }, { 5.0, 0.0, 1.0 }, {5.0, 1.0, 1.0}
  ,{ 6.0, 0.0, 0.0 }, { 6.0, 0.0, 1.0 }, {6.0, 1.0, 1.0}
  ,{ 7.0, 0.0, 0.0 }, { 7.0, 0.0, 1.0 }, {7.0, 1.0, 1.0}
  ,{ 8.0, 0.0, 0.0 }, { 8.0, 0.0, 1.0 }, {8.0, 1.0, 1.0}
  ,{ 9.0, 0.0, 0.0 }, { 9.0, 0.0, 1.0 }, {9.0, 1.0, 1.0}

   } ;
void WriteXYZ(double& csum, const XYZ& R)
{
#if defined(WRITEOUT)
  cout << '(' << R.mX
       << ',' << R.mY
       << ',' << R.mZ
       << ")\n" ;
#endif
  csum += R.mX + R.mY + R.mZ ;
}

void WriteEnergy(double& csum, double E)
{
#if defined(WRITEOUT)
   cout << "Energy=" << E
        << '\n' ;
#endif
  csum += E ;
}

int main(void)
{
   double StretchEnergy = 0.0 ;
   double AngleEnergy = 0.0 ;
   XYZA TotalForceTable[30] ;

   WaterBond (
    TotalForceTable
    ,Waters
    , StretchEnergy
    , AngleEnergy
    ) ;
  double csum=0.0 ;
  for (int a=0; a<30 ; a+=1)
  {
     WriteXYZ(csum,TotalForceTable[a].mXYZ) ;
  }
  WriteEnergy(csum,StretchEnergy) ;
  WriteEnergy(csum,AngleEnergy) ;

  return (csum >= 0.0 ? 0 : 1) ;
}

