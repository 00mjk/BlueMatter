/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Hummer exponentiate
 */
static const double qt[] = {
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0
   } ;
static const double qt0[] = {
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0
   } ;
static const double qt1[] = {
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0
   } ;
static const double qt2[] = {
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0
   } ;
static const double qt3[] = {
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0
   } ;
static const double qt4[] = {
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0
   } ;
static const double qt5[] = {
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0
   } ;
static const double qt6[] = {
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0
   } ;
static const double qt7[] = {
   1.0, 2.0 , 3.0 , 4.0 ,   1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0 ,    1.0, 2.0 , 3.0 , 4.0
   } ;
inline double hexp(double x)
{
   double xs = x * ( 1 << 24 ) ;
   int as = xs ;
   unsigned int a = as ;
//   double q0 = qt[(0 << 4) + ( ( a >> 28 ) & 0x0f) ] ;
//   double q1 = qt[(1 << 4) + ( ( a >> 24 ) & 0x0f) ] ;
//   double q2 = qt[(2 << 4) + ( ( a >> 20 ) & 0x0f) ] ;
//   double q3 = qt[(3 << 4) + ( ( a >> 16 ) & 0x0f) ] ;
//   double q4 = qt[(4 << 4) + ( ( a >> 12 ) & 0x0f) ] ;
//   double q5 = qt[(5 << 4) + ( ( a >>  8 ) & 0x0f) ] ;
//   double q6 = qt[(6 << 4) + ( ( a >>  4 ) & 0x0f) ] ;
//   double q7 = qt[(7 << 4) + ( ( a       ) & 0x0f) ] ;
   double q0 = qt0[( ( a >> 28 ) & 0x0f) ] ;
   double q1 = qt1[( ( a >> 24 ) & 0x0f) ] ;
   double q2 = qt2[( ( a >> 20 ) & 0x0f) ] ;
   double q3 = qt3[( ( a >> 16 ) & 0x0f) ] ;
   double q4 = qt4[( ( a >> 12 ) & 0x0f) ] ;
   double q5 = qt5[( ( a >>  8 ) & 0x0f) ] ;
   double q6 = qt6[( ( a >>  4 ) & 0x0f) ] ;
   double q7 = qt7[( ( a       ) & 0x0f) ] ;
   return q0*q1*q2*q3*q4*q5*q6*q7 ;
}

void hexp10(double* result, const double* x)
{
   double r0 = hexp(x[0]) ;
   double r1 = hexp(x[1]) ;
   double r2 = hexp(x[2]) ;
   double r3 = hexp(x[3]) ;
   double r4 = hexp(x[4]) ;
   double r5 = hexp(x[5]) ;
   double r6 = hexp(x[6]) ;
   double r7 = hexp(x[7]) ;
   double r8 = hexp(x[8]) ;
   double r9 = hexp(x[9]) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
   result[5] = r5 ;
   result[6] = r6 ;
   result[7] = r7 ;
   result[8] = r8 ;
   result[9] = r9 ;
}

void hexp5(double* result, const double* x)
{
   double r0 = hexp(x[0]) ;
   double r1 = hexp(x[1]) ;
   double r2 = hexp(x[2]) ;
   double r3 = hexp(x[3]) ;
   double r4 = hexp(x[4]) ;
   result[0] = r0 ;
   result[1] = r1 ;
   result[2] = r2 ;
   result[3] = r3 ;
   result[4] = r4 ;
}
