/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 typedef union {
     unsigned int x;
  float f;
} float_u;

typedef union {
     struct { unsigned int hw, lw; } x;
  double f;
} double_u;

typedef union {
     unsigned char bytes[4];
  unsigned int x;
} int_u;

static const double_u xmag = { { 0x3c980000,0 } };

/* constant for initial approximation */
static const unsigned int magic = 0x7fde6000;

/* constants for bad case check */
static const unsigned int add1 = 0xfefefefe,
                          add2 = 0x04040404,
                          and2 = 0x80808080;

void vdiv8 (double y[], double z[], double_u x[], int *pn) {
  double_u r1, r3, r5, r7, r2, r4, r6, r8;
  double rr1, rr3, rr5, rr7, rr2, rr4, rr6, rr8;
  int n = *pn;
  int i, j, n_res;
  int_u ix1, ix2, ix3, ix4, ix5, ix6, ix7, ix8;
  double x1, x2, x3, x4, x5, x6, x7, x8;
  double e1, e2, e3, e4, e5, e6, e7, e8;
  double z1, z2, z3, z4, z5, z6, z7, z8;
  double y1, y2, y3, y4, y5, y6, y7, y8;
  unsigned int emask, emask1, emask2;

  if (n <= 0) return;

  n_res = n & 7;

  for (i=0; i < n_res; ++i) {
    y[i] = z[i] / x[i].f;
  }

  if (i >= n) return;

  ix1.x = x[i].x.hw;
  ix2.x = x[i+1].x.hw;
  ix3.x = x[i+2].x.hw;
  ix4.x = x[i+3].x.hw;
  r1.f = 0.0;
  r2.f = 0.0;
  r3.f = 0.0;
  r4.f = 0.0;
  ix1.x = magic - ix1.x;
  ix2.x = magic - ix2.x;
  ix3.x = magic - ix3.x;
  ix4.x = magic - ix4.x;
  r5.f = 0.0;
  r6.f = 0.0;
  r7.f = 0.0;
  r8.f = 0.0;
  ix5.x = x[i+4].x.hw;
  ix6.x = x[i+5].x.hw;
  ix7.x = x[i+6].x.hw;
  ix8.x = x[i+7].x.hw;
  r1.x.hw = ix1.x;
  r2.x.hw = ix2.x;
  r3.x.hw = ix3.x;
  r4.x.hw = ix4.x;
  ix5.x = magic - ix5.x;
  ix6.x = magic - ix6.x;
  ix7.x = magic - ix7.x;
  ix8.x = magic - ix8.x;
  r5.x.hw = ix5.x;
  r6.x.hw = ix6.x;
  r7.x.hw = ix7.x;
  r8.x.hw = ix8.x;
  x1 = x[i].f;
  x2 = x[i+1].f;
  x3 = x[i+2].f;
  x4 = x[i+3].f;
  x5 = x[i+4].f;
  x6 = x[i+5].f;
  x7 = x[i+6].f;
  x8 = x[i+7].f;
  rr1 = r1.f;
  rr2 = r2.f;
  rr3 = r3.f;
  rr4 = r4.f;

  ix1.bytes[1] = ix3.bytes[0];
  ix2.bytes[1] = ix4.bytes[0];
  e1 = 1.0 - x1*rr1;
  e2 = 1.0 - x2*rr2;
  ix1.bytes[2] = ix5.bytes[0];
  ix2.bytes[2] = ix6.bytes[0];
  e3 = 1.0 - x3*rr3;
  e4 = 1.0 - x4*rr4;
  ix1.bytes[3] = ix7.bytes[0];
  ix2.bytes[3] = ix8.bytes[0];

  rr5 = r5.f;
  rr6 = r6.f;

  emask1 = (add1 + ix1.x) & ~and2;
  emask2 = (add1 + ix2.x) & ~and2;

  rr7 = r7.f;
  rr8 = r8.f;

  e5 = 1.0 - x5*rr5;
  e6 = 1.0 - x6*rr6;
  e7 = 1.0 - x7*rr7;
  e8 = 1.0 - x8*rr8;

  emask1 += add2;
  emask2 += add2;
  emask = emask1 | emask2;

  for (i = i + 8; i < n + 8; i += 8) {
    double t1, t2, t3, t4, t5, t6, t7, t8;

    t1 = e1 + e1*e1;
    t2 = e2 + e2*e2;

    ix1.x = x[i].x.hw;
    ix2.x = x[i+1].x.hw;
    ix3.x = x[i+2].x.hw;
    ix4.x = x[i+3].x.hw;

    e1 = e1*e1;
    e2 = e2*e2;

    t3 = e3 + e3*e3;
    t4 = e4 + e4*e4;

    ix5.x = x[i+4].x.hw;
    ix6.x = x[i+5].x.hw;
    ix7.x = x[i+6].x.hw;
    ix8.x = x[i+7].x.hw;

    e3 = e3*e3;
    e4 = e4*e4;

    t5 = e5 + e5*e5;
    t6 = e6 + e6*e6;

    ix1.x = magic - ix1.x;
    ix2.x = magic - ix2.x;
    ix3.x = magic - ix3.x;
    ix4.x = magic - ix4.x;

    e5 = e5*e5;
    e6 = e6*e6;

    t7 = e7 + e7*e7;
    t8 = e8 + e8*e8;

    r1.x.hw = ix1.x;
    r2.x.hw = ix2.x;
    r3.x.hw = ix3.x;
    r4.x.hw = ix4.x;

    e7 = e7*e7;
    e8 = e8*e8;

    t1 = t1*e1 + t1;
    t2 = t2*e2 + t2;

    ix5.x = magic - ix5.x;
    ix6.x = magic - ix6.x;
    ix7.x = magic - ix7.x;
    ix8.x = magic - ix8.x;

    e1 = e1 + e1*xmag.f;
    e2 = e2 + e2*xmag.f;

    t3 = t3*e3 + t3;
    t4 = t4*e4 + t4;

    r5.x.hw = ix5.x;
    r6.x.hw = ix6.x;
    r7.x.hw = ix7.x;
    r8.x.hw = ix8.x;

    e3 = e3 + e3*xmag.f;
    e4 = e4 + e4*xmag.f;

    t5 = t5*e5 + t5;
    t6 = t6*e6 + t6;

    ix1.bytes[1] = ix3.bytes[0];
    ix2.bytes[1] = ix4.bytes[0];

    e5 = e5 + e5*xmag.f;
    e6 = e6 + e6*xmag.f;

    t7 = t7*e7 + t7;
    t8 = t8*e8 + t8;

    emask &= and2;
    ix1.bytes[2] = ix5.bytes[0];

    e7 = e7 + e7*xmag.f;
    e8 = e8 + e8*xmag.f;

    e1 = e1 + e1*e1;
    e2 = e2 + e2*e2;

    ix2.bytes[2] = ix6.bytes[0];
    ix1.bytes[3] = ix7.bytes[0];

    e3 = e3 + e3*e3;
    e4 = e4 + e4*e4;
    e5 = e5 + e5*e5;
    e6 = e6 + e6*e6;

    ix2.bytes[3] = ix8.bytes[0];

    e7 = e7 + e7*e7;
    e8 = e8 + e8*e8;

    emask1 = add1 + ix1.x;
    emask2 = add1 + ix2.x;

    t1 = t1 + t1*e1;
    t2 = t2 + t2*e2;
    t3 = t3 + t3*e3;
    t4 = t4 + t4*e4;

    x1 = x[i].f;
    x2 = x[i+1].f;
    x3 = x[i+2].f;
    x4 = x[i+3].f;

    t5 = t5 + t5*e5;
    t6 = t6 + t6*e6;

    x5 = x[i+4].f;
    x6 = x[i+5].f;

    t7 = t7 + t7*e7;
    t8 = t8 + t8*e8;

    x7 = x[i+6].f;
    x8 = x[i+7].f;

    rr1 = rr1 + rr1*t1;
    rr2 = rr2 + rr2*t2;

    z1 = z[i-8];
    z2 = z[i-7];

    rr3 = rr3 + rr3*t3;
    rr4 = rr4 + rr4*t4;

    z3 = z[i-6];
    z4 = z[i-5];

    rr5 = rr5 + rr5*t5;
    rr6 = rr6 + rr6*t6;

    z5 = z[i-4];
    z6 = z[i-3];

    rr7 = rr7 + rr7*t7;
    rr8 = rr8 + rr8*t8;

    z7 = z[i-2];
    z8 = z[i-1];

    if (!emask) {
      y1 = z1*rr1;
      y2 = z2*rr2;
      rr1 = r1.f;
      rr2 = r2.f;
      y3 = z3*rr3;
      y4 = z4*rr4;
      rr3 = r3.f;
      rr4 = r4.f;
      y5 = z5*rr5;
      y6 = z6*rr6;
      y7 = z7*rr7;
      y8 = z8*rr8;
    } else {
      y1 = z1 / x[i-8].f;
      y2 = z2 / x[i-7].f;
      y3 = z3 / x[i-6].f;
      y4 = z4 / x[i-5].f;
      y5 = z5 / x[i-4].f;
      y6 = z6 / x[i-3].f;
      y7 = z7 / x[i-2].f;
      y8 = z8 / x[i-1].f;
      rr1 = r1.f;
      rr2 = r2.f;
      rr3 = r3.f;
      rr4 = r4.f;
    }

    /* sty: */
    rr5 = r5.f;
    rr6 = r6.f;
    rr7 = r7.f;
    rr8 = r8.f;

    e1 = 1.0 - x1*rr1;
    e2 = 1.0 - x2*rr2;

    emask1 &= ~and2;
    emask2 &= ~and2;

    e3 = 1.0 - x3*rr3;
    e4 = 1.0 - x4*rr4;

    y[i-8] = y1;
    y[i-7] = y2;
    y[i-6] = y3;
    y[i-5] = y4;

    emask1 += add2;
    emask2 += add2;

    e5 = 1.0 - x5*rr5;
    e6 = 1.0 - x6*rr6;

    emask = emask1 | emask2;

    e7 = 1.0 - x7*rr7;
    e8 = 1.0 - x8*rr8;

    y[i-4] = y5;
    y[i-3] = y6;
    y[i-2] = y7;
    y[i-1] = y8;
  }
}

void vdiv (double y[], double z[], double_u x[], int *pn) {
  double_u r1;
  double rr1;
  int n = *pn;
  int i;
  int_u ix1;
  double x1;
  double e1;
  double z1;
  double y1;
  double t1;
  unsigned int emask, emask1, emask2;

  r1.f = 0.0;
  for (i=0; i < n; ++i) {
    ix1.x = x[i].x.hw;
    ix1.x = magic - ix1.x;
    r1.x.hw = ix1.x;
    x1 = x[i].f;
    rr1 = r1.f;
    emask = (add1 + (ix1.x & 0xFF000000)) & ~and2;
    e1 = 1.0 - x1*rr1;
    t1 = e1 + e1*e1;
    e1 = e1*e1;
    t1 = t1*e1 + t1;
    e1 = e1 + e1*xmag.f;
    e1 = e1 + e1*e1;
    t1 = t1 + t1*e1;
    rr1 = rr1 + rr1*t1;
    z1 = z[i];
    if (emask) y1 = z1/x1;
    else y1 = z1*rr1;
    y[i] = y1;
  }
}

