/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Format a floating-point number for display on simulator
 */
#include <math.h>

void digextract(char& resc, double& val)
{
   double dval = val ;
   double ddig ;
   char cdig ;
   if (dval >= 9.0)
   {
     ddig = 9.0 ;
     cdig = '9' ;
   }
   else
   {
      if (dval >= 8.0 )
      {
         ddig = 8.0 ;
         cdig = '8' ;
      }
      else
      {
         if (dval >= 7.0 )
         {
            ddig = 7.0 ;
            cdig = '7' ;
         }
         else
         {
            if (dval >= 6.0 )
            {
               ddig = 6.0 ;
               cdig = '6' ;
            }
            else
            {
               if (dval >= 5.0 )
               {
                  ddig = 5.0 ;
                  cdig = '5' ;
               }
               else
               {
                  if (dval >= 4.0 )
                  {
                     ddig = 4.0 ;
                     cdig = '4' ;
                  }
                  else
                  {
                     if (dval >= 3.0 )
                     {
                        ddig = 3.0 ;
                        cdig = '3' ;
                     }
                     else
                     {
                        if (dval >= 2.0 )
                        {
                           ddig = 2.0 ;
                           cdig = '2' ;
                        }
                        else
                        {
                           if (dval >= 1.0 )
                           {
                              ddig = 1.0 ;
                              cdig = '1' ;
                           }
                           else
                           {
                              ddig = 0.0 ;
                              cdig = '0' ;
                           } /* endif */
                        } /* endif */
                     } /* endif */
                  } /* endif */
               } /* endif */
            } /* endif */
         } /* endif */
      } /* endif */
   } /* endif */
   /*
    * Store the character, and update/rescale the remainder
    */
   resc = cdig ;
   val = ( dval - ddig ) * 10.0 ;
}

void fpformat(char* target, double x, unsigned int width)
{
   /*
    * Must be enough space to represent the number
    */
   if (width >= 10)
   {
      target[0] = ( x >= 0.0 ) ? '+' : '-' ;
      double xp = fabs(x) ;
      if (0.0 == xp)
      {
         target[1] = '0' ;
         target[2] = '.' ;
         target[3] = '0' ;
         target[4] = 0 ;
      }
      else
      {
         int e ;
         if (xp < 1.0 )
         {
            for (e=-1; e > -400 ; e-=1 )
            {
               xp *= 10.0 ;
               if (xp >= 1.0 ) break ;
            } /* endfor */
         }
         else
         {
            for (e=0; e<400 ; e+=1)
            {
               if (xp < 10.0 ) break ;
               xp *= 0.1 ;
            } /* endfor */
         } /* endif */
         /*
          * Now we have 'xp' scaled in (1.0, 9.9999...)
          * and 'e' the exponent
          */
         digextract(target[1],xp) ;
         target[2] = '.' ;
         for (int p=3 ; p<width-6 ;  p+=1)
         {
            digextract(target[p],xp) ;
         } /* endfor */
         target[width-6] = 'e' ;
         target[width-5] = (e >= 0) ? '+' : '-' ;
         int ep = abs(e) ;
         target[width-4] = (ep/100) + '0' ;
         target[width-3] = ((ep/10) % 10) + '0' ;
         target[width-2] = (ep%10) + '0' ;
         target[width-1] = 0 ;
      } /* endif */
   } /* endif */
}

#include <stdio.h>

int main(int argc, const char ** argv)
{
   char* rest ;
   double d=strtod(argv[1], &rest) ;
   int w = strtoul(argv[2], &rest, 0) ;
   int ww = ( w < 40 ) ? w : 40 ;
   char x[40] ;
   fpformat(x,d,ww) ;
   printf("<%s>\n",x) ;
   return 0 ;
}
