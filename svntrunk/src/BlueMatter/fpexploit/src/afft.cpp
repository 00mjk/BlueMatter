/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #if defined(PK_BGL)
extern "builtin" void __alignx (int, const void *);
#else
#define __alignx(X,Y)
#endif
#include <math.h>
#include <assert.h>
#include <iostream>
#include <iomanip>

using namespace std ;

#define COSHALFANGLE(cosx) (sqrt((1.0+cosx)*0.5))
#define SINHALFANGLE(sinx,coshx) (sinx/(2.0*coshx))


// const double s2p_1   = sin(2.0*M_PI/1.0) ;
// const double s2p_2   = sin(2.0*M_PI/2.0) ;
// const double s2p_4   = sin(2.0*M_PI/4.0) ;
// const double s2p_8   = sin(2.0*M_PI/8.0) ;
// const double s2p_16  = sin(2.0*M_PI/16.0) ;
// const double s2p_32  = sin(2.0*M_PI/32.0) ;
// const double s2p_64  = sin(2.0*M_PI/64.0) ;
// const double s2p_128 = sin(2.0*M_PI/128.0) ;
// const double s2p_256 = sin(2.0*M_PI/256.0) ;

__align(16) class cpx {
   public:
     double Re ;
     double Im ;
   } ;

class afft ;
void show_afft(ostream& dest, const afft& x) ;

class afft {
   public:

   enum {
      k_l2points = 7 ,
      k_points = 1 << k_l2points
      } ;

   // Data which are transformed in place
   cpx m_table[k_points] ;

   // 'internal' functions

   // 2-element bit reverse, should be enough to keep pipelines full
   void br2(
     int s0, int t0,
     int s1, int t1
           ) {
      const double scale = 1.0/sqrt(128.0) ;
      cpx a0 = m_table[s0] ;
      cpx b0 = m_table[t0] ;
      cpx a1 = m_table[s1] ;
      cpx b1 = m_table[t1] ;
      a0.Re *= scale ;
      a0.Im *= scale ;
      b0.Re *= scale ;
      b0.Im *= scale ;
      a1.Re *= scale ;
      a1.Im *= scale ;
      b1.Re *= scale ;
      b1.Im *= scale ;
      m_table[t0] = a0 ;
      m_table[s0] = b0 ;
      m_table[t1] = a1 ;
      m_table[s1] = b1 ;

   } ;
   // 1-element bit reverse, good compiler keeps the pipelines full
   void br1(
     int s0, int t0
           ) {
      const double scale = 1.0/sqrt(128.0) ;
      cpx a0 = m_table[s0] ;
      cpx b0 = m_table[t0] ;
      a0.Re *= scale ;
      a0.Im *= scale ;
      b0.Re *= scale ;
      b0.Im *= scale ;
      m_table[t0] = a0 ;
      m_table[s0] = b0 ;

   } ;
   void bsc(
     int s0
   ) {
      const double scale = 1.0/sqrt(128.0) ;
      cpx a0 = m_table[s0] ;
      a0.Re *= scale ;
      a0.Im *= scale ;
      m_table[s0] = a0 ;
   } ;
   inline void bitreverse(void) ;

   template <int mmax> void Danielson_Lanczos(int i, double wr, double wi)
   {
      __alignx(16,this) ;
      int j=i+(mmax/2) ;
//    assert(i >= 0) ;
//    assert(j >= 0) ;
//    assert(i < 128) ;
//    assert(j < 128) ;
//    cout << i << ' ' << j << endl ;
      __alignx(16,m_table) ;
      cpx dj  = m_table[j] ;
      cpx di  = m_table[i] ;

      double tRe = wr*dj.Re - wi*dj.Im ;
      double tIm = wi*dj.Re + wr*dj.Im ;

      cpx djj ;
      cpx dii ;
      djj.Re = di.Re - tRe ;
      djj.Im = di.Im - tIm ;

      dii.Re = di.Re + tRe ;
      dii.Im = di.Im + tIm ;

      m_table[j] = djj ;
      m_table[i] = dii ;

   } ;

   template <int mmax> void loop2(int m,double wr, double wi)
   {
      __alignx(16,this) ;

//      for (int i=m; i < k_points; i+=mmax)
      for (int x=0;x < 128/mmax; x+=1)
      {
         Danielson_Lanczos<mmax>(m+mmax*x,wr,wi) ;
      } /* endfor */
   } ;

   template <int mmax, int isign> void loop1(double sintheta, double sinhalftheta)
   {
      __alignx(16,this) ;
//    double theta = isign*(2.0*M_PI/mmax) ;
//    double wtemp = sin(0.5*theta) ;
//    double wpr = -2.0 * wtemp * wtemp ;
//    double wpi = sin(theta) ;
      double wpr = -2.0 * sinhalftheta * sinhalftheta ;
      double wpi = isign * sintheta ;
      double wr=1.0 ;
      double wi=0.0 ;
      for (int m=0; m<(mmax/2); m+=1)
      {
        loop2<mmax>(m, wr, wi) ;
        double wrp = wr*wpr - wi*wpi + wr ;
        double wip = wi*wpr + wr*wpi + wi ;
        wr = wrp ;
        wi = wip ;
      } /* endfor */
//    show_afft(cout, *this) ;
   } ;

   template <int isign> void DLSection(void)
   {
       __alignx(16,this) ;

       const double c2p_1   = 1.0 ;
       const double s2p_1   = 0.0 ;

       const double c2p_2   = -1.0 ;
       const double s2p_2   =  0.0 ;

       const double c2p_4   =  0.0 ;
       const double s2p_4   =  1.0 ;

       const double c2p_8   =  COSHALFANGLE(      c2p_4) ;
       const double s2p_8   =  SINHALFANGLE(s2p_4,c2p_8) ;

       const double c2p_16  =  COSHALFANGLE(      c2p_8) ;
       const double s2p_16  =  SINHALFANGLE(s2p_8,c2p_16) ;

       const double c2p_32  =  COSHALFANGLE(       c2p_16) ;
       const double s2p_32  =  SINHALFANGLE(s2p_16,c2p_32) ;

       const double c2p_64  =  COSHALFANGLE(       c2p_32) ;
       const double s2p_64  =  SINHALFANGLE(s2p_32,c2p_64) ;

       const double c2p_128 =  COSHALFANGLE(       c2p_64) ;
       const double s2p_128 =  SINHALFANGLE(s2p_64,c2p_128) ;

       const double c2p_256 =  COSHALFANGLE(        c2p_128) ;
       const double s2p_256 =  SINHALFANGLE(s2p_128,c2p_256) ;

       loop1  <2,isign>(  s2p_2,  s2p_4) ;
       loop1  <4,isign>(  s2p_4,  s2p_8) ;
       loop1  <8,isign>(  s2p_8, s2p_16) ;
       loop1 <16,isign>( s2p_16, s2p_32) ;
       loop1 <32,isign>( s2p_32, s2p_64) ;
       loop1 <64,isign>( s2p_64,s2p_128) ;
       loop1<128,isign>(s2p_128,s2p_256) ;
   } ;

   // Interface
   inline void inline_forward(void) ;
   inline void inline_inverse(void) ;

   void forward(void) ;
   void inverse(void) ;
   } ;


inline void afft::inline_forward(void)
{
   __alignx(16,this) ;
   bitreverse() ;
   DLSection<1>() ;
} ;

inline void afft::inline_inverse(void)
{
   __alignx(16,this) ;
   bitreverse() ;
   DLSection<-1>() ;
} ;

void afft::forward(void)
{
   inline_forward() ;
}

void afft::inverse(void)
{
   inline_inverse() ;
}
// Perform the 'butterfly' (bit-reverse indexing) transform
inline void afft::bitreverse(void)
{
   __alignx(16,this) ;
   // The palindromic indices need rescaling only
   bsc( 0x00 ) ;
   bsc( 0x08 ) ;
   bsc( 0x14 ) ;
   bsc( 0x1c ) ;
   bsc( 0x22 ) ;
   bsc( 0x2a ) ;
   bsc( 0x36 ) ;
   bsc( 0x3e ) ;
   bsc( 0x41 ) ;
   bsc( 0x49 ) ;
   bsc( 0x55 ) ;
   bsc( 0x5d ) ;
   bsc( 0x63 ) ;
   bsc( 0x6b ) ;
   bsc( 0x77 ) ;
   bsc( 0x7f ) ;
   // All the others need rescaling and swapping
   br1( 0x01,0x40 ) ;
   br1( 0x02,0x20 ) ;
   br1( 0x03,0x60 ) ;
   br1( 0x04,0x10 ) ;
   br1( 0x05,0x50 ) ;
   br1( 0x06,0x30 ) ;
   br1( 0x07,0x70 ) ;
   br1( 0x09,0x48 ) ;
   br1( 0x0a,0x28 ) ;
   br1( 0x0b,0x68 ) ;
   br1( 0x0c,0x18 ) ;
   br1( 0x0d,0x58 ) ;
   br1( 0x0e,0x38 ) ;
   br1( 0x0f,0x78 ) ;
   br1( 0x11,0x44 ) ;
   br1( 0x12,0x24 ) ;
   br1( 0x13,0x64 ) ;
   br1( 0x15,0x54 ) ;
   br1( 0x16,0x34 ) ;
   br1( 0x17,0x74 ) ;
   br1( 0x19,0x4c ) ;
   br1( 0x1a,0x2c ) ;
   br1( 0x1b,0x6c ) ;
   br1( 0x1d,0x5c ) ;
   br1( 0x1e,0x3c ) ;
   br1( 0x1f,0x7c ) ;
   br1( 0x21,0x42 ) ;
   br1( 0x23,0x62 ) ;
   br1( 0x25,0x52 ) ;
   br1( 0x26,0x32 ) ;
   br1( 0x27,0x72 ) ;
   br1( 0x29,0x4a ) ;
   br1( 0x2b,0x6a ) ;
   br1( 0x2d,0x5a ) ;
   br1( 0x2e,0x3a ) ;
   br1( 0x2f,0x7a ) ;
   br1( 0x31,0x46 ) ;
   br1( 0x33,0x66 ) ;
   br1( 0x35,0x56 ) ;
   br1( 0x37,0x76 ) ;
   br1( 0x39,0x4e ) ;
   br1( 0x3b,0x6e ) ;
   br1( 0x3d,0x5e ) ;
   br1( 0x3f,0x7e ) ;
   br1( 0x43,0x61 ) ;
   br1( 0x45,0x51 ) ;
   br1( 0x47,0x71 ) ;
   br1( 0x4b,0x69 ) ;
   br1( 0x4d,0x59 ) ;
   br1( 0x4f,0x79 ) ;
   br1( 0x53,0x65 ) ;
   br1( 0x57,0x75 ) ;
   br1( 0x5b,0x6d ) ;
   br1( 0x5f,0x7d ) ;
   br1( 0x67,0x73 ) ;
   br1( 0x6f,0x7b ) ;
}

#if defined(GENERATE_TEST_CASE)
void clear_afft(afft& x)
{
   for (int a=0; a<afft::k_points; a+=1 )
   {
     x.m_table[a].Re = 0.0 ;
     x.m_table[a].Im = 0.0 ;
   } /* endfor */
}

void show_afft(ostream& dest, const afft& x)
{
   dest << endl ;
   for (int a=0; a<afft::k_points; a+=1 )
   {
      dest << setw(4) << a << setw(20) << x.m_table[a].Re << setw(20) << x.m_table[a].Im << endl ;
   }
}

int main(void)
{
   afft x ;
   clear_afft(x) ;
   x.m_table[0].Re = 1.0 ;
   show_afft(cout, x) ;
   x.forward() ;
   show_afft(cout, x) ;
   x.inverse() ;
   show_afft(cout, x) ;
   return 0 ;
}
#endif
