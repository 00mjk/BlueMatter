/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Interface for 'mechanisable' NSQ processing
 */
// 'fsel' is a built-in instruction on PPCGR and above, sometimes we want to force its use
#if 1
#include <builtins.h>
#define fsel(a, x, y) __fsel((a),(x),(y))
#else
#define fsel(a, x, y) ( (a) >= 0.0 ? (x) : (y) )
#endif

#include <math.h> // for 'fabs'
 
// Coordinate geometry
template <class type>
class tXYZ {
	public:
	type mX, mY, mZ ;
  	void Zero(void) { 
  		mX = 0.0 ; 
  		mY = 0.0 ; 
		mZ = 0.0 ; 
	}
	    inline
    tXYZ operator+( const tXYZ& aOther ) const
      {
      tXYZ rc;
      rc.mX = mX + aOther.mX;
      rc.mY = mY + aOther.mY;
      rc.mZ = mZ + aOther.mZ;
      return( rc );
      }
	
    inline
    tXYZ operator-( const tXYZ<type>& aOther ) const
      {
      tXYZ<type> rc;
      rc.mX = mX - aOther.mX;
      rc.mY = mY - aOther.mY;
      rc.mZ = mZ - aOther.mZ;
      return( rc );
      }
     inline
    tXYZ operator*( type aScalar ) const
      {
      tXYZ rc;
      rc.mX = mX * aScalar;
      rc.mY = mY * aScalar;
      rc.mZ = mZ * aScalar;
      return( rc );
      }
          inline
    type LengthSquared() const
    {
      type ls =  mX * mX + mY * mY + mZ * mZ ;
      return( ls );
    } 
      
          
} ;

typedef tXYZ<double> XYZ;
 
// Bond physics ... LJ and Electrostatics constants for each chemical element of interest
class LJParms
{
public:
	double p1 ;
	double p2 ;
} ;
class ESParms
{
public:
	double p1 ;
} ;

class BondPhysics
{
	public: 
	LJParms mLJ ;
	ESParms mES ;
} ;

enum {
		k_MaxElements = 16 
} ;

BondPhysics BondPhysicsArray[k_MaxElements] ;

// All the atoms in the system
class AtomStatic
{
	public: 
	int mElement ;
} ;
class AtomDynamic
{
	public:
	XYZ mLocation ;
} ;

enum {
		k_MaxAtoms = 4096 
} ;

// This implementation keeps the time-varying implementation separate from the invariants.
// Another implementation might keep copies of the invariants along with the time-varying
// items, in an attempt to reduce cache misses when accessing things.
// 'Atom' class hides this
AtomStatic AtomStaticArray[k_MaxAtoms] ;
AtomDynamic AtomDynamicArray[k_MaxAtoms] ;

class Atom {
	public: 
	XYZ& Location(int x) { return AtomDynamicArray[x].mLocation ; }
	const LJParms& LJ(int x) { return BondPhysicsArray[AtomStaticArray[x].mElement].mLJ ; }
	const ESParms& ES(int x) { return BondPhysicsArray[AtomStaticArray[x].mElement].mES ; } 
} ;

Atom AllAtoms ;

// What we know about the fragments that are of interest to this node
class FragmentStatic {
	public:
	int mFirstAtom ;
	int mAtomCount ;
	int mMolecule ; // sequence number of the molecule that this fragment belongs to
	int FmragmentTag ; // sequence number of this fragment within its molecule
} ; 

// What we know about the dynamics of a fragment
class FragmentDynamic {
	public: 
	XYZ mBoundingBoxCentre ;
	XYZ mBoundingBoxSize ;
	XYZ mBoundingSphereCentre ; // Might be different from mBoundingBoxCentre if we try a water optimisation
	double mBoundingSphereRadius ;
} ;

enum {
	k_MaxFragments = 1024 ,
} ;

FragmentStatic FragmentStaticArray[k_MaxFragments] ;
FragmentDynamic FragmentDynamicArray[k_MaxFragments+20] ; // Extra space to let vector square root work efficiently

class Fragment {
	public:
	XYZ& BoundingBoxCentre(int x) { return FragmentDynamicArray[x].mBoundingBoxCentre ; } 
	XYZ& BoundingBoxSize(int x) { return FragmentDynamicArray[x].mBoundingBoxSize ; } 
	XYZ& BoundingSphereCentre(int x) { return FragmentDynamicArray[x].mBoundingSphereCentre ; } 
	double& BoundingSphereRadius(int x) { return FragmentDynamicArray[x].mBoundingSphereRadius ; } 
	FragmentStatic& Static(int x) { return FragmentStaticArray[x] ; } 
	FragmentDynamic& Dynamic(int x) { return FragmentDynamicArray[x] ; } 
} ;

Fragment AllFragments ;

// We keep the fragments by number of atoms.
enum {
	k_MaxFragmentAtomCount = 8 
} ;
int FragIndexNextStart[k_MaxFragmentAtomCount] ;

// A Verlet list is a list of fragment pairs which this node is evaluating the forces for
// Here expressed as indices to the local node's Fragment table, which in general is
// different from the global table.
class VerletListItem
{
	public: 
	int mFrag0 ;
	int mFrag1 ;
} ;

enum { 
	k_VerletListMaxSize = 16384 
} ;

VerletListItem VerletList[k_VerletListMaxSize] ;

class Configuration
{
	public: 
	int mActualFragCount ;
} ;

class NSQ : public Configuration
{
public: 	
	// NSQ gets asked to go through the Verlet list for this node, figuring
	// which fragments are actually in range, and driving IFP for them
	void Process(void) ;
private:
	void EvaluateBoundaries(void) ;
	int PackVerletList(VerletListItem * PackedVerletList) ;
	void RunVerletList(void) ;	
	void IFP(FragmentStatic& Frag0, FragmentStatic& Frag1) ;
} ;
 
void NSQ::Process(void) {
	EvaluateBoundaries() ;
	RunVerletList() ; 
}

void NSQ::RunVerletList(void)
{
   VerletListItem PackedVerletList[k_VerletListMaxSize] ; 
   int PackedListSize = PackVerletList(PackedVerletList) ;
   for (int x=0;x<PackedListSize;x+=1)
   {
   	  IFP(AllFragments.Static(PackedVerletList[x].mFrag0)
   	     ,AllFragments.Static(PackedVerletList[x].mFrag1)) ;
   }
}

template <int AtomCount> void xEvaluateBoundaries(int FragStart, int NextFragStart) ;

void ConvertToRadius(int FragIndexFirst, int FragIndexQuit) ;

void NSQ::EvaluateBoundaries(void)
{ 
	// Find the boundaries of all the size-1 fragments (trivial)
	xEvaluateBoundaries<1>(                   0 ,FragIndexNextStart[0]) ;
	// Then the boundaries of all the size-2 fragments
	xEvaluateBoundaries<2>(FragIndexNextStart[0],FragIndexNextStart[1]) ;
	// Then all the size-3 fragments (includes all the waters)
	xEvaluateBoundaries<3>(FragIndexNextStart[1],FragIndexNextStart[2]) ;
	// and so on
	xEvaluateBoundaries<4>(FragIndexNextStart[2],FragIndexNextStart[3]) ;
	xEvaluateBoundaries<5>(FragIndexNextStart[3],FragIndexNextStart[4]) ;
	xEvaluateBoundaries<6>(FragIndexNextStart[4],FragIndexNextStart[5]) ;
	xEvaluateBoundaries<7>(FragIndexNextStart[5],FragIndexNextStart[6]) ;
	xEvaluateBoundaries<8>(FragIndexNextStart[6],FragIndexNextStart[7]) ;
	// We have been collecting up 'radius squared'; convert all to radius
	ConvertToRadius(FragIndexNextStart[0],FragIndexNextStart[7]) ;
}

//int NSQ::PackVerletList(VerletListItem * PackedVerletList)
//{
//	return -1 ; 
//} 

template <int AtomCount> static inline void EvaluateBoundary(FragmentDynamic& Dynamic, const FragmentStatic& Static) ;


static inline double min(double a, double b)
{
	return fsel(a-b,b,a) ; // ((a-b) >= 0.0)  ? b : a ;
}
static inline double max(double a, double b)
{
	return fsel(a-b,a,b) ; // ((a-b) >= 0.0)  ? a : b ;
}

// 1-atom fragment is a special case ...
template <> inline void EvaluateBoundary<1>(FragmentDynamic& Dynamic, const FragmentStatic& Static)
{
	XYZ Centre = AllAtoms.Location(Static.mFirstAtom) ;
	Dynamic.mBoundingBoxCentre = Centre ;
	Dynamic.mBoundingSphereCentre = Centre ;
	Dynamic.mBoundingBoxSize.Zero() ; 
	Dynamic.mBoundingSphereRadius = 0.0 ;
}

// 2-atom fragment likewise
template <> inline void EvaluateBoundary<2>(FragmentDynamic& Dynamic, const FragmentStatic& Static)
{
	XYZ First = AllAtoms.Location(Static.mFirstAtom) ;
	XYZ Second = AllAtoms.Location(Static.mFirstAtom+1) ;
	XYZ Centre = (First + Second) * 0.5 ;
	XYZ aBox = ( First - Second ) * 0.5 ;
	Dynamic.mBoundingBoxSize.mX = fabs(aBox.mX) ;
	Dynamic.mBoundingBoxSize.mY = fabs(aBox.mY) ;
	Dynamic.mBoundingBoxSize.mZ = fabs(aBox.mZ) ;
	Dynamic.mBoundingBoxCentre = Centre ;
	Dynamic.mBoundingSphereCentre = Centre ;
	Dynamic.mBoundingSphereRadius = aBox.LengthSquared() * 0.25 ;
}

// General case. Exploit the optimisation that we want 'max' and 'min', take atoms in pairs
template <int AtomCount> static inline void EvaluateBoundary(FragmentDynamic& Dynamic, const FragmentStatic& Static)
{
	int FirstAtom = Static.mFirstAtom ;
	XYZ LowerLeft ;
	XYZ UpperRight ;
	int LoopStart ;
	// Arrange for an even number of atoms to be processed in the loop
	if ( AtomCount & 1 )
	{
		LowerLeft = AllAtoms.Location(FirstAtom) ;
		UpperRight = LowerLeft ;
		LoopStart = 1 ;
	} else {
		XYZ First = AllAtoms.Location(FirstAtom) ;
		XYZ Second = AllAtoms.Location(FirstAtom+1) ;
		LowerLeft.mX = min(First.mX,Second.mX) ;
		LowerLeft.mY = min(First.mY,Second.mZ) ;
		LowerLeft.mZ = min(First.mZ,Second.mZ) ;
		UpperRight.mX = max(First.mX,Second.mX) ;
		UpperRight.mY = max(First.mY,Second.mZ) ;
		UpperRight.mZ = max(First.mZ,Second.mZ) ;
		LoopStart = 2 ;
	}
	for (int x=LoopStart;x<AtomCount;x+=1)
	{
		XYZ First = AllAtoms.Location(FirstAtom+x) ;
		XYZ Second = AllAtoms.Location(FirstAtom+x+1) ;
		
		LowerLeft.mX = min(LowerLeft.mX,min(First.mX,Second.mX)) ;
		LowerLeft.mY = min(LowerLeft.mY,min(First.mY,Second.mY)) ;
		LowerLeft.mZ = min(LowerLeft.mZ,min(First.mZ,Second.mZ)) ;
		UpperRight.mX = max(UpperRight.mX,max(First.mX,Second.mX)) ;
		UpperRight.mY = max(UpperRight.mY,max(First.mY,Second.mY)) ;
		UpperRight.mZ = max(UpperRight.mZ,max(First.mZ,Second.mZ)) ;
		
	}
	XYZ Centre = (LowerLeft + UpperRight) * 0.5 ;
	XYZ BoundingBoxSize = (UpperRight - LowerLeft) * 0.5 ;
	Dynamic.mBoundingBoxCentre = Centre ;
	Dynamic.mBoundingBoxSize = BoundingBoxSize ;
	Dynamic.mBoundingSphereCentre = Centre ;
	double maxRadSquared = (AllAtoms.Location(FirstAtom)-Centre).LengthSquared() ;
	for (int xx=1;xx<AtomCount;xx+=1)
	{
		double RadSquared = (AllAtoms.Location(FirstAtom+xx)-Centre).LengthSquared() ;
		maxRadSquared = max(maxRadSquared,RadSquared) ;
	}
	Dynamic.mBoundingSphereRadius = maxRadSquared ;
}

template <int AtomCount> void xEvaluateBoundaries(int FragStart, int NextFragStart) 
{
	for ( int x=FragStart;x<NextFragStart;x+=1)
	{
		EvaluateBoundary<AtomCount>(AllFragments.Dynamic(x),AllFragments.Static(x)) ;
	}
}

void ConvertToRadius(int FragIndexFirst, int FragIndexQuit) 
{
	double p0 = AllFragments.BoundingSphereRadius(FragIndexFirst+0) ;
	double p1 = AllFragments.BoundingSphereRadius(FragIndexFirst+1) ;
	double p2 = AllFragments.BoundingSphereRadius(FragIndexFirst+2) ;
	double p3 = AllFragments.BoundingSphereRadius(FragIndexFirst+3) ;
	double p4 = AllFragments.BoundingSphereRadius(FragIndexFirst+4) ;
	double p5 = AllFragments.BoundingSphereRadius(FragIndexFirst+5) ;
	double p6 = AllFragments.BoundingSphereRadius(FragIndexFirst+6) ;
	double p7 = AllFragments.BoundingSphereRadius(FragIndexFirst+7) ;
	double p8 = AllFragments.BoundingSphereRadius(FragIndexFirst+8) ;
	double p9 = AllFragments.BoundingSphereRadius(FragIndexFirst+9) ;
	
	for ( int x = FragIndexFirst ; x < FragIndexQuit ; x += 10 ) 
	{
		double r0 = p0/sqrt(p0) ;
		double r1 = p1/sqrt(p1) ;
		double r2 = p2/sqrt(p2) ;
		double r3 = p3/sqrt(p3) ;
		double r4 = p4/sqrt(p4) ;
		double r5 = p5/sqrt(p5) ;
		double r6 = p6/sqrt(p6) ;
		double r7 = p7/sqrt(p7) ;
		double r8 = p8/sqrt(p8) ;
		double r9 = p9/sqrt(p9) ;
		
        p0 = AllFragments.BoundingSphereRadius(x+10) ;
        p1 = AllFragments.BoundingSphereRadius(x+11) ;
        p2 = AllFragments.BoundingSphereRadius(x+12) ;
        p3 = AllFragments.BoundingSphereRadius(x+13) ;
        p4 = AllFragments.BoundingSphereRadius(x+14) ;
        p5 = AllFragments.BoundingSphereRadius(x+15) ;
        p6 = AllFragments.BoundingSphereRadius(x+16) ;
        p7 = AllFragments.BoundingSphereRadius(x+17) ;
        p8 = AllFragments.BoundingSphereRadius(x+18) ;
        p9 = AllFragments.BoundingSphereRadius(x+19) ;
        
        AllFragments.BoundingSphereRadius(x+0) = r0 ; 
        AllFragments.BoundingSphereRadius(x+1) = r1 ; 
        AllFragments.BoundingSphereRadius(x+2) = r2 ; 
        AllFragments.BoundingSphereRadius(x+3) = r3 ; 
        AllFragments.BoundingSphereRadius(x+4) = r4 ; 
        AllFragments.BoundingSphereRadius(x+5) = r5 ; 
        AllFragments.BoundingSphereRadius(x+6) = r6 ; 
        AllFragments.BoundingSphereRadius(x+7) = r7 ; 
        AllFragments.BoundingSphereRadius(x+8) = r8 ; 
        AllFragments.BoundingSphereRadius(x+9) = r9 ; 
		
	} ;
}
