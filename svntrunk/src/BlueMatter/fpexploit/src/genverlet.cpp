/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Build an on-the-fly Verlet list
 */

#include <math.h>
// 'fsel' is a built-in instruction on PPCGR and above, sometimes we want to force its use
#if 1
#include <builtins.h>
#define fsel(a, x, y) __fsel((a),(x),(y))
#else
#define fsel(a, x, y) ( (a) >= 0.0 ? (x) : (y) )
#endif

static inline double NearestInteger(const double x)
{
   const double two10 = 1024.0 ;
   const double two50 = two10 * two10 * two10 * two10 * two10 ;
   const double two52 = two50 * 4.0 ;
   const double two51 = two50 * 2.0 ;
   const double offset = two52 + two51 ;

   const double losebits = x + offset ;
   const double result = losebits - offset ;
   return result ;
}

static inline int FracScale(double n, double rd)
{
   double t = n*rd ;
   double ti = NearestInteger(t) ;
   double tr = t-ti ;                  // tr should be in (-0.5, 0.5)
   const double two10 = 1024.0 ;
   const double two32 = two10 * two10 * two10 * 4.0 ;
   double tri = tr*two32 ;
   return tri ;             // should be a 32-bit integer representing the fractional position
}


static inline double NearestDistanceInFullyPeriodicLine(
     const double a
  , const double b
  , const double Period
  , const double ReciprocalPeriod
  )
{
   const double d = b-a ; // 'Regular' distance between them, if small enough the result will be 'b'
   const double d_unit = d * ReciprocalPeriod ; // express with respect to unit periodicity,
                                                // for -0.5 < d_unit < 0.5 result will be 'b'
   const double d_unit_rounded = NearestInteger(d_unit) ;
   const double result = d - d_unit_rounded * Period ;
   return result ;
}

class XYZ {
   public:
   double mX ;
   double mY ;
   double mZ ;
   } ;

__align(16) class NeighbourList
{
   public:
   class remainder
   {
      public:
       double e2 ;
       int    a  ;
       int dummy ;
   } ;

   enum {
      k_FragCount = 1024
      } ;

   const XYZ p ;
   const XYZ k ;

   double x[k_FragCount] ;
   double y[k_FragCount] ;
   double z[k_FragCount] ;
   double e[k_FragCount] ;

   int ix[k_FragCount] ;
   int iy[k_FragCount] ;
   int iz[k_FragCount] ;
   int iex[k_FragCount] ;
   int iey[k_FragCount] ;
   int iez[k_FragCount] ;

   int result[k_FragCount] ;

   NeighbourList(const XYZ& ap, const XYZ& ak): p(ap), k(ak) { } ;

   int Produce(
     const XYZ& aXYZ
     , double e0
     , int qstart
     , int qend
   ) {
       double x0 = aXYZ.mX ;
       double px = p.mX ;
       double kx = k.mX ;
      /*
       * Slice for slab
       */

      remainder xr[k_FragCount] ;
      remainder yr[k_FragCount] ;
      int q1 = 0 ;
      for (int a0=qstart; a0<qend; a0+=1 )
      {
         double dx = NearestDistanceInFullyPeriodicLine(x0,x[a0],px,kx) ;
         double em = e0 + e[a0] ;
         double ex2 = em*em - dx*dx ;
         xr[q1].e2 = ex2 ;
         xr[q1].a = a0 ;
         double FragmentIndexAdd = fsel(ex2,1.0,0.0) ;
         int IndexAdd = FragmentIndexAdd ;
         q1 += IndexAdd ;
      } /* endfor */

     double y0 = aXYZ.mY ;
       double py = p.mY ;
       double ky = k.mY ;
      /*
       * Slice for cylinder
       */
      int q2 = 0 ;
      for (int b1=0; b1<q1; b1+=1 )
      {
         int a1 = xr[b1].a ;
         double dy = NearestDistanceInFullyPeriodicLine(y0,y[a1],py,ky) ;
         double ey2 = xr[b1].e2 - dy*dy ;
         yr[q2].e2 = ey2 ;
         yr[q2].a = a1 ;
         double FragmentIndexAdd = fsel(ey2,1.0,0.0) ;
         int IndexAdd = FragmentIndexAdd ;
         q2 += IndexAdd ;
      } /* endfor */

     double z0 = aXYZ.mZ ;
       double pz = p.mZ ;
       double kz = k.mZ ;
      /*
       * Slice for sphere
       */
      int q3 = 0 ;
      for (int b2=0; b2<q2; b2+=1 )
      {
         int a2 = yr[b2].a ;
         double dz = NearestDistanceInFullyPeriodicLine(z0,z[a2],pz,kz) ;
         double ez2 = yr[b2].e2 - dz*dz ;
         result[q3] = a2 ;
         double FragmentIndexAdd = fsel(ez2,1.0,0.0) ;
         int IndexAdd = FragmentIndexAdd ;
         q3 += IndexAdd ;
      } /* endfor */
      return q3 ;
      } ;

   int iProduce(
     const XYZ& aXYZ
     , double e0
     , int qstart
     , int qend
   ) {
      int aix = FracScale(aXYZ.mX,k.mX) ;
      int aiy = FracScale(aXYZ.mY,k.mY) ;
      int aiz = FracScale(aXYZ.mZ,k.mZ) ;
      int aiex = FracScale(e0,k.mX) ;
      int aiey = FracScale(e0,k.mY) ;
      int aiez = FracScale(e0,k.mZ) ;

      /*
       * Slice for slab
       */

      int xr[k_FragCount] ;
      int q1 = 0 ;
      for (int a0=qstart; a0<qend; a0+=1 )
      {
         int idx = aix - ix[a0] ;
         int iem = aiex + iex[a0] ;
         int nexp = idx - iem ;
         int nexn = idx + iem ;
         unsigned int nex = nexp | nexn ;
         int IndexAdd = nex >> 31 ;
         xr[q1] = a0 ;
         q1 += IndexAdd ;
      }

      /*
       * Slice for square prism
       */
      int yr[k_FragCount] ;
      int q2 = 0 ;
      for (int b1=0; b1<q1; b1+=1 )
      {
         int a1 = xr[b1] ;
         int idy = aiy - iy[a1] ;
         int iem = aiey + iey[a1] ;
         int nexp = idy - iem ;
         int nexn = idy + iem ;
         unsigned int ney = nexp | nexn ;
         int IndexAdd = ney >> 31 ;
         yr[q2] = a1 ;
         q2 += IndexAdd ;
      } /* endfor */

      /*
       * Slice for cube
       */
      int zr[k_FragCount] ;
      int q3 = 0 ;
      for (int b2=0; b2<q2; b2+=1 )
      {
         int a2 = yr[b2] ;
         int idz = aiz - iz[a2] ;
         int iem = aiez + iez[a2] ;
         int nexp = idz - iem ;
         int nexn = idz + iem ;
         unsigned int nez = nexp | nexn ;
         int IndexAdd = nez >> 31 ;
         zr[q3] = a2 ;
         q3 += IndexAdd ;
      } /* endfor */

      /*
       * Examine cuboid for sphere
       */
      int q4 = 0 ;
      double x0=aXYZ.mX ;
      double y0=aXYZ.mY ;
      double z0=aXYZ.mZ ;
      double px = p.mX ;
      double py = p.mY ;
      double pz = p.mZ ;
      double kx = k.mX ;
      double ky = k.mY ;
      double kz = k.mZ ;
      for (int b3=0; b3<q3 ; b3+=1)
      {
         int a3 = zr[b3] ;
         double dx = NearestDistanceInFullyPeriodicLine(x0,x[a3],px,kx) ;
         double dy = NearestDistanceInFullyPeriodicLine(y0,y[a3],py,ky) ;
         double dz = NearestDistanceInFullyPeriodicLine(z0,z[a3],pz,kz) ;
         double em = e0 + e[a3] ;
         double ex2 = em*em - dx*dx - dy*dy - dz*dz ;
         result[b3] = q4 ;
         double FragmentIndexAdd = fsel(ex2,1.0,0.0) ;
         int IndexAdd = FragmentIndexAdd ;
         q4 += IndexAdd ;
      } /* endfor */

      return q4 ;

     } ;

   void SetXYZE(
       int q
     , const XYZ& aXYZ
     , double ae
   ) {
        x[q] = aXYZ.mX ;
        y[q] = aXYZ.mY ;
        z[q] = aXYZ.mZ ;
        e[q] = ae;

        ix[q] = FracScale(aXYZ.mX,k.mX) ;
        iy[q] = FracScale(aXYZ.mY,k.mY) ;
        iz[q] = FracScale(aXYZ.mZ,k.mZ) ;
        iex[q] = FracScale(ae,k.mX) ;
        iey[q] = FracScale(ae,k.mY) ;
        iez[q] = FracScale(ae,k.mZ) ;

      } ;

int Get(int q) const { return result[q] ; } ;

int fProduce(
  const XYZ& aXYZ
  , double e0
  , int qstart
  , int qend
) ;
int fiProduce(
  const XYZ& aXYZ
  , double e0
  , int qstart
  , int qend
) ;

int fmProduce(
  const XYZ& aXYZ
  , double e0
  , int qstart
  , int qend
) ;

int mProduce(
  const XYZ& aXYZ
  , double e0
  , int qstart
  , int qend
) {
       double x0 = aXYZ.mX ;
       double px = p.mX ;
       double kx = k.mX ;
      /*
       * Slice for slab
       */

      typedef double * doublep ;
      doublep xr[k_FragCount] ;
      doublep * q1 = xr ;
      for (int a0=qstart; a0<qend; a0+=1 )
      {
         double dx = x0 - x[a0] ;
         double em = e0 + e[a0] ;
         double adx = abs(dx) ;
         double adxm = adx - 0.5 ;
         double aadxm = abs(adxm) ;
         bool IndexAdd = ( aadxm < em ) ;
         *q1 = x+a0 ;
         q1 += IndexAdd ;
      } /* endfor */
      int rcount = q1-xr ;
      for (int a1=0; a1<rcount; a1+=1)
      {
         result[a1] = xr[a1] - x ;
      } /* endfor */
      return q1-xr ;
  }

} ;


int NeighbourList::fProduce(
  const XYZ& aXYZ
  , double e0
  , int qstart
  , int qend
) {
   return Produce(aXYZ,e0,qstart,qend) ;
   }

int NeighbourList::fiProduce(
  const XYZ& aXYZ
  , double e0
  , int qstart
  , int qend
) {
   return iProduce(aXYZ,e0,qstart,qend) ;
   }

int NeighbourList::fmProduce(
  const XYZ& aXYZ
  , double e0
  , int qstart
  , int qend
) {
   return mProduce(aXYZ,e0,qstart,qend) ;
   }

