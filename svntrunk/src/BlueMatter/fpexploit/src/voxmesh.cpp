/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
// Demo compile with /opt/ibmcmp/vacpp/7.0/bin/blrts_xlC -O3 -qdebug=plst3:cycles -qarch=440d -qsource -qlist -c voxmesh.cpp 

// 'fsel' is a built-in instruction on PPCGR and above, sometimes we want to force its use
#if 1
#include <builtins.h>
#define fsel(a, x, y) __fsel((a),(x),(y))
#else
#define fsel(a, x, y) ( (a) >= 0.0 ? (x) : (y) )
#endif

static inline double max2(double A, double B)
{
	return fsel(A-B,A,B) ;
}
static inline double max3(double A, double B, double C)
{
    return max2(max2(A,B),C) ;
}

static inline double min2(double A, double B)
{
	return fsel(A-B,B,A) ;
}
static inline double min3(double A, double B, double C)
{
    return min2(min2(A,B),C) ;
}


extern double dk1 ;
#if defined(LEAVE_SYMS_EXTERN)
double dk1 = 1.0 ; // The compiler does not know this is constant, so should not 'optimise' away the rounding below
#endif
static inline double NearestInteger(const double x)
{
   const double two10 = 1024.0 ;
   const double two50 = two10 * two10 * two10 * two10 * two10 ;
   const double two52 = two50 * 4.0 ;
   const double two51 = two50 * 2.0 ;
   const double offset = two52 + two51 ;

   // Force add and subtract of appropriate constant to drop lose fractional part
   // .. hide it from the compiler so the optimiser won't reassociate things ..
   const double losebits = (dk1*x) + offset ;
   const double result = (dk1*losebits) - offset ;
   return result ;
}

class XYZ
{
	public: 
	double mX ; 
	double mY ;
	double mZ ;
} ;

extern XYZ ReciprocalBoxSize ;

extern XYZ VoxMeshSize ;

int voxmesh3(const XYZ* A)
{
	// Evaluate the bounding box
	double xMin = min3(A[0].mX,A[1].mX,A[2].mX) ;
	double yMin = min3(A[0].mY,A[1].mY,A[2].mY) ;
	double zMin = min3(A[0].mZ,A[1].mZ,A[2].mZ) ;
	double xMax = max3(A[0].mX,A[1].mX,A[2].mX) ;
	double yMax = max3(A[0].mY,A[1].mY,A[2].mY) ;
	double zMax = max3(A[0].mZ,A[1].mZ,A[2].mZ) ;
	
	// Centroid
	double xCentroid = ( xMin+xMax ) / 2.0 ;
	double yCentroid = ( yMin+yMax ) / 2.0 ;
	double zCentroid = ( zMin+zMax ) / 2.0 ; 
	
	// Map to a unit box
	double xBoxFrac = xCentroid * ReciprocalBoxSize.mX ;
	double yBoxFrac = yCentroid * ReciprocalBoxSize.mY ;
	double zBoxFrac = zCentroid * ReciprocalBoxSize.mZ ;
	
	// Image. This will give numbers in -0.5 <= A < 0.5 . I think .
	double xImFrac = xBoxFrac - NearestInteger(xBoxFrac) ;
	double yImFrac = yBoxFrac - NearestInteger(yBoxFrac) ;
	double zImFrac = zBoxFrac - NearestInteger(zBoxFrac) ;
	
	// Scale to voxmesh
	double xVFrac = ( xBoxFrac+0.5 ) * VoxMeshSize.mX ;
	double yVFrac = ( yBoxFrac+0.5 ) * VoxMeshSize.mY ;
	double zVFrac = ( zBoxFrac+0.5 ) * VoxMeshSize.mZ ;
	
	// Convert to integer
	int xV = xVFrac ;
	int yV = yVFrac ; 
	int zV = zVFrac ;
	
	// Synthesize a scalar result
	return ( xV << 16 ) | ( yV << 8 ) | zV ;
}
