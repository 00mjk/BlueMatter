/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Test cases to explore floating-point efficiency on Blue Light with double hummer
 *
 *  Bond vector computation
 *
 *  This tests the compiler's ability to
 *  1) Assign registers effectively, without causing spills or reloads
 *  2) Pair operations up for issuing Double Hummer parallel instructions
 *  3) Schedule instructions to avoid delays from data dependencies
 *  4) Choose optimally whether to do 'load parallel' and 'store parallel'
 *
 *  Expectations for the loop
 *  1) Automatics and temporaries all in registers
 *  2) No reloads from storage
 *  3) All FP ops parallel
 *  4) All cycles have a FP op, alternatively all cycles have a load or store
 *  5) Compiler chooses not to do 'load parallel' or 'store parallel'
 *
 * Chris Ward
 *  20010821
 */
#include <BlueMatter/fpexploit.hpp>
// #include <../include/fpexploit.hpp>
// Compute a group of bond vectors from their specifications
// Work out vectors in both directions, square lengths, and reciprocal lengths
void ComputeBondVectors(
  MD_BondVector * BondVectorTable
//  , const MD_Atom* AtomTable
  , const MD_BondSpecX* BondSpecTable
//  , unsigned int grouplim
  )
{
#pragma disjoint(*BondVectorTable, *AtomTable)
#pragma disjoint(*BondVectorTable, *BondSpecTable)
/*
 * XYZ AtomLoc0A = AtomTable[BondSpecTable[0].mAtomIndexA].mLoc ;
 * XYZ AtomLoc0B = AtomTable[BondSpecTable[0].mAtomIndexB].mLoc ;
 * XYZ AtomLoc1A = AtomTable[BondSpecTable[1].mAtomLocA ;
 * XYZ AtomLoc1B = AtomTable[BondSpecTable[1].mAtomIndexB].mLoc ;
 * XYZ AtomLoc2A = AtomTable[BondSpecTable[2].mAtomIndexA].mLoc ;
 * XYZ AtomLoc2B = AtomTable[BondSpecTable[2].mAtomIndexB].mLoc ;
 * XYZ AtomLoc3A = AtomTable[BondSpecTable[3].mAtomIndexA].mLoc ;
 * XYZ AtomLoc3B = AtomTable[BondSpecTable[3].mAtomIndexB].mLoc ;
 * XYZ AtomLoc4A = AtomTable[BondSpecTable[4].mAtomIndexA].mLoc ;
 * XYZ AtomLoc4B = AtomTable[BondSpecTable[4].mAtomIndexB].mLoc ;
 * XYZ AtomLoc5A = AtomTable[BondSpecTable[5].mAtomIndexA].mLoc ;
 * XYZ AtomLoc5B = AtomTable[BondSpecTable[5].mAtomIndexB].mLoc ;
 * XYZ AtomLoc6A = AtomTable[BondSpecTable[6].mAtomIndexA].mLoc ;
 * XYZ AtomLoc6B = AtomTable[BondSpecTable[6].mAtomIndexB].mLoc ;
 * XYZ AtomLoc7A = AtomTable[BondSpecTable[7].mAtomIndexA].mLoc ;
 * XYZ AtomLoc7B = AtomTable[BondSpecTable[7].mAtomIndexB].mLoc ;
 * XYZ AtomLoc8A = AtomTable[BondSpecTable[8].mAtomIndexA].mLoc ;
 * XYZ AtomLoc8B = AtomTable[BondSpecTable[8].mAtomIndexB].mLoc ;
 * XYZ AtomLoc9A = AtomTable[BondSpecTable[9].mAtomIndexA].mLoc ;
 * XYZ AtomLoc9B = AtomTable[BondSpecTable[9].mAtomIndexB].mLoc ;
 */
  const unsigned int grouplim=0 ;
  const unsigned int x=0 ;
//  for ( unsigned int x=0 ; x <= grouplim ; x += 1 )
    {
      // Manual 10-way unroll should be right to keep Double Hummer fully busy
      // (adjust to 6-way for POWER3 ...)
      XYZ AtomLoc0A = BondSpecTable[10*x+0].mAtomLocA ;
      XYZ AtomLoc0B = BondSpecTable[10*x+0].mAtomLocB ;
      XYZ AtomLoc1A = BondSpecTable[10*x+1].mAtomLocA ;
      XYZ AtomLoc1B = BondSpecTable[10*x+1].mAtomLocB ;
      XYZ AtomLoc2A = BondSpecTable[10*x+2].mAtomLocA ;
      XYZ AtomLoc2B = BondSpecTable[10*x+2].mAtomLocB ;

      XYZ vec0p = difference(AtomLoc0B , AtomLoc0A) ;
      XYZ vec1p = difference(AtomLoc1B , AtomLoc1A) ;
      double sq0 = sqr(vec0p) ;
      double sq1 = sqr(vec1p) ;
      BondVectorTable[20*x+0].mVec = vec0p ;
      BondVectorTable[20*x+1].mVec = negate(vec0p) ;
      BondVectorTable[20*x+2].mVec = vec1p ;
      BondVectorTable[20*x+3].mVec = negate(vec1p) ;

      XYZ AtomLoc3A = BondSpecTable[10*x+3].mAtomLocA ;
      XYZ AtomLoc3B = BondSpecTable[10*x+3].mAtomLocB ;
      XYZ AtomLoc4A = BondSpecTable[10*x+4].mAtomLocA ;
      XYZ AtomLoc4B = BondSpecTable[10*x+4].mAtomLocB ;

      XYZ vec2p = difference(AtomLoc2B , AtomLoc2A) ;
      XYZ vec3p = difference(AtomLoc3B , AtomLoc3A) ;
      double sq2 = sqr(vec2p) ;
      double sq3 = sqr(vec3p) ;
      BondVectorTable[20*x+4].mVec = vec2p ;
      BondVectorTable[20*x+5].mVec = negate(vec2p) ;
      BondVectorTable[20*x+6].mVec = vec3p ;
      BondVectorTable[20*x+7].mVec = negate(vec3p) ;

      XYZ AtomLoc5A = BondSpecTable[10*x+5].mAtomLocA ;
      XYZ AtomLoc5B = BondSpecTable[10*x+5].mAtomLocB ;
      XYZ AtomLoc6A = BondSpecTable[10*x+6].mAtomLocA ;
      XYZ AtomLoc6B = BondSpecTable[10*x+6].mAtomLocB ;

      XYZ vec4p = difference(AtomLoc4B , AtomLoc4A) ;
      XYZ vec5p = difference(AtomLoc5B , AtomLoc5A) ;
      double sq4 = sqr(vec4p) ;
      double sq5 = sqr(vec5p) ;
      BondVectorTable[20*x+8].mVec = vec4p ;
      BondVectorTable[20*x+9].mVec = negate(vec4p) ;
      BondVectorTable[20*x+10].mVec = vec5p ;
      BondVectorTable[20*x+11].mVec = negate(vec5p) ;

      XYZ AtomLoc7A = BondSpecTable[10*x+7].mAtomLocA ;
      XYZ AtomLoc7B = BondSpecTable[10*x+7].mAtomLocB ;
      XYZ AtomLoc8A = BondSpecTable[10*x+8].mAtomLocA ;
      XYZ AtomLoc8B = BondSpecTable[10*x+8].mAtomLocB ;

      XYZ vec6p = difference(AtomLoc6B , AtomLoc6A) ;
      XYZ vec7p = difference(AtomLoc7B , AtomLoc7A) ;
      double sq6 = sqr(vec6p) ;
      double sq7 = sqr(vec7p) ;
      BondVectorTable[20*x+12].mVec = vec6p ;
      BondVectorTable[20*x+13].mVec = negate(vec6p) ;
      BondVectorTable[20*x+14].mVec = vec7p ;
      BondVectorTable[20*x+15].mVec = negate(vec7p) ;

      XYZ AtomLoc9A = BondSpecTable[10*x+9].mAtomLocA ;
      XYZ AtomLoc9B = BondSpecTable[10*x+9].mAtomLocB ;

      XYZ vec8p = difference(AtomLoc8B , AtomLoc8A) ;
      XYZ vec9p = difference(AtomLoc9B , AtomLoc9A) ;
      double sq8 = sqr(vec8p) ;
      double sq9 = sqr(vec9p) ;
      BondVectorTable[20*x+16].mVec = vec8p ;
      BondVectorTable[20*x+17].mVec = negate(vec8p) ;
      BondVectorTable[20*x+18].mVec = vec9p ;
      BondVectorTable[20*x+19].mVec = negate(vec9p) ;

      BondVectorTable[20*x+0].mSquareLength = sq0 ;
      BondVectorTable[20*x+1].mSquareLength = sq0 ;
      BondVectorTable[20*x+2].mSquareLength = sq1 ;
      BondVectorTable[20*x+3].mSquareLength = sq1 ;
      BondVectorTable[20*x+4].mSquareLength = sq2 ;
      BondVectorTable[20*x+5].mSquareLength = sq2 ;
      BondVectorTable[20*x+6].mSquareLength = sq3 ;
      BondVectorTable[20*x+7].mSquareLength = sq3 ;
      BondVectorTable[20*x+8].mSquareLength = sq4 ;
      BondVectorTable[20*x+9].mSquareLength = sq4 ;
      BondVectorTable[20*x+10].mSquareLength = sq5 ;
      BondVectorTable[20*x+11].mSquareLength = sq5 ;
      BondVectorTable[20*x+12].mSquareLength = sq6 ;
      BondVectorTable[20*x+13].mSquareLength = sq6 ;
      BondVectorTable[20*x+14].mSquareLength = sq7 ;
      BondVectorTable[20*x+15].mSquareLength = sq7 ;
      BondVectorTable[20*x+16].mSquareLength = sq8 ;
      BondVectorTable[20*x+17].mSquareLength = sq8 ;
      BondVectorTable[20*x+18].mSquareLength = sq9 ;
      BondVectorTable[20*x+19].mSquareLength = sq9 ;

      double r0 = 1.0 / sqrt(sq0) ;
      double r1 = 1.0 / sqrt(sq1) ;
      double r2 = 1.0 / sqrt(sq2) ;
      double r3 = 1.0 / sqrt(sq3) ;
      double r4 = 1.0 / sqrt(sq4) ;
      double r5 = 1.0 / sqrt(sq5) ;
      double r6 = 1.0 / sqrt(sq6) ;
      double r7 = 1.0 / sqrt(sq7) ;
      double r8 = 1.0 / sqrt(sq8) ;
      double r9 = 1.0 / sqrt(sq9) ;

      BondVectorTable[20*x+0].mRecipLength = r0 ;
      BondVectorTable[20*x+1].mRecipLength = r0 ;
      BondVectorTable[20*x+2].mRecipLength = r1 ;
      BondVectorTable[20*x+3].mRecipLength = r1 ;
      BondVectorTable[20*x+4].mRecipLength = r2 ;
      BondVectorTable[20*x+5].mRecipLength = r2 ;
      BondVectorTable[20*x+6].mRecipLength = r3 ;
      BondVectorTable[20*x+7].mRecipLength = r3 ;
      BondVectorTable[20*x+8].mRecipLength = r4 ;
      BondVectorTable[20*x+9].mRecipLength = r4 ;
      BondVectorTable[20*x+10].mRecipLength = r5 ;
      BondVectorTable[20*x+11].mRecipLength = r5 ;
      BondVectorTable[20*x+12].mRecipLength = r6 ;
      BondVectorTable[20*x+13].mRecipLength = r6 ;
      BondVectorTable[20*x+14].mRecipLength = r7 ;
      BondVectorTable[20*x+15].mRecipLength = r7 ;
      BondVectorTable[20*x+16].mRecipLength = r8 ;
      BondVectorTable[20*x+17].mRecipLength = r8 ;
      BondVectorTable[20*x+18].mRecipLength = r9 ;
      BondVectorTable[20*x+19].mRecipLength = r9 ;
    }
}
