/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Evaluator and setup for chebyshev-polynomial complementary error function and derivarive
 */


#include <BlueMatter/math.hpp>

#include <iostream>
#include <iomanip>
using namespace std ;

// Evaluate a Chebyshev polynomial by Clenshaw recurrence
// Note .. the terms are required in reverse order in the array, to give
//  ascending address sequence
class ChebyshevEvaluator
{
  public:
  enum {
     k_Terms = 16
     } ;

  static double RawEvaluate(double x, double*c)
  {
     double dpp = 0.0 ;
     double dp = 0.0 ;
     for (int j=0; j<k_Terms-1; j+=1)
     {
        double d=(2.0*x)*dp - dpp + c[j] ;
        dpp = dp ;
        dp = d ;
     } /* endfor */
     // Term 0 is a special case; POWER 'multiply-add' makes this same efficiency as rewriting the table
     double result = x*dp - dpp + 0.5*(c[k_Terms-1]) ;
     return result ;
  }

} ;


// We start with the analytic representation of the derivative of the error function
class DerivativeErrorFunction
{
   public:

   static double FunctionToFit(double x) {
      double result = (2.0/sqrt(M_PI)) * exp(-x*x) ; // Evaluate the analytic function
      return result ;
      } ;

} ;

// Fit a Chebyshev polynomial to the function over a subrange. See for example Numerical Recipes
// This selects N=128 points to evaluate the function; evaluates the function at these points;
// and produces the Chebyshev coefficients
class ChebyshevFit: public DerivativeErrorFunction
{
   public :
   double m_bma, m_bpa ;
   void SetBounds(double a, double b)
   {
      m_bma = 0.5*(b-a) ;
      m_bpa = 0.5*(b+a) ;
   }
   double func_sub(double y)
   {
     return FunctionToFit(y*m_bma+m_bpa) ;
   }
   enum {
      k_Points = 128
      } ;
   double f[k_Points] ;
   double c[k_Points] ;

   void EvaluateN(void)
   {
      for (int k=0; k<k_Points; k+=1)
      {
         double y=cos(M_PI*(k+0.5)/k_Points) ;
         f[k] = func_sub(y) ;
      } /* endfor */
   }

   void EvaluateC(void)
   {
      for (int j=0; j<k_Points; j+=1)
      {
         double sum=0.0 ;

         for (int k=0; k < k_Points; k+=1)
         {
            sum += f[k]*cos(M_PI*j*(k+0.5)/k_Points) ;
         } /* endfor */
         c[j] = (2.0/k_Points)*sum ;
      } /* endfor */
   }

} ;


// We look at 8 domains
// 0..1, 1..2, 2..3, ... , 7..8
// and produce 8 Chebyshev polynomials.
// The polynomial for 'erfc' is produced from the polynomial for 'derfc'
// by applying the integration transform (Numerical Recipes)
// Negative numbers are handled by symmetry. Numbers >= 8 are
// special-cased (erfc == 0)
// For a given parameter, we choose the appropriate domain,
// evaluate the Chebyshev polynomial, and fix up for symmetry and range

class ErfEvaluator: public ChebyshevEvaluator
{
   public:
   enum {
      k_Slices = 8 ,
      } ;

static double NErfTable[k_Slices][k_Terms] ;
static double DErfcTable[k_Slices][k_Terms] ;

static double NearestInteger(const double x)
{
   const double two10 = 1024.0 ;
   const double two50 = two10 * two10 * two10 * two10 * two10 ;
   const double two52 = two50 * 4.0 ;
   const double two51 = two50 * 2.0 ;
   const double offset = two52 + two51 ;

   const double losebits = x + offset ;
   const double result = losebits - offset ;
   return result ;
}

static void Evaluate(const double x, double& f, double& df)
{

   double xam = abs(x) - 0.5 ;

   double xi = NearestInteger(xam) ;
   double xf = xam-xi ;                 // -0.5 < x < 0.5
   int ix = (int) xi ;
   int ixmask = ix & 7 ;

   double * MyNErfTable = NErfTable[ixmask] ;
   double * MyDErfcTable = DErfcTable[ixmask] ;

   double  r0 = RawEvaluate(2.0*xf, MyNErfTable) ;
   double dr0 = RawEvaluate(2.0*xf, MyDErfcTable) ;
   double  r1 = fsel(xi-7.5,-1.0,  r0) ;
   double dr1 = fsel(xi-7.5, 0.0, dr0) ;
   double   m = fsel(x,1.0, -1.0) ;
   double  r2 = 1.0+m*r1 ;

   f = r2    ;
   df = dr1 ;

}

void Setup(double x_lo, double x_hi, int slice, double& f_at_x_lo, double& f_at_x_hi)
{
   ChebyshevFit afit ;
   afit.SetBounds(x_lo, x_hi) ;
   afit.EvaluateN() ;
   afit.EvaluateC() ;
   DErfcTable[slice][k_Terms-1] = -afit.c[0] ;
   NErfTable[slice][k_Terms-1] = 0.0 ;
   double dq=4.0 ;
   for (int q=1; q<k_Terms; q+=1)
   {
      DErfcTable[slice][(k_Terms-1)-q] = -afit.c[q] ;
      NErfTable[slice][(k_Terms-1)-q] = -(afit.c[q-1] - afit.c[q+1])/dq  ;
      dq += 4.0 ;
   } /* endfor */

   f_at_x_lo = RawEvaluate(-1.0, NErfTable[slice]) ;
   f_at_x_hi = RawEvaluate( 1.0, NErfTable[slice]) ;
} ;

ErfEvaluator(void)
{
   double f0l, f0h ;
   double f1l, f1h ;
   double f2l, f2h ;
   double f3l, f3h ;
   double f4l, f4h ;
   double f5l, f5h ;
   double f6l, f6h ;
   double f7l, f7h ;
   Setup( 0.0, 1.0, 0, f0l, f0h ) ;
   Setup( 1.0, 2.0, 1, f1l, f1h ) ;
   Setup( 2.0, 3.0, 2, f2l, f2h ) ;
   Setup( 3.0, 4.0, 3, f3l, f3h ) ;
   Setup( 4.0, 5.0, 4, f4l, f4h ) ;
   Setup( 5.0, 6.0, 5, f5l, f5h ) ;
   Setup( 6.0, 7.0, 6, f6l, f6h ) ;
   Setup( 7.0, 8.0, 7, f7l, f7h ) ;

   // Set up the constants of integration to set up for f(0)=0
   NErfTable[0][k_Terms-1] = 2.0*(   -f0l) ;
   NErfTable[1][k_Terms-1] = 2.0*(f0h-f1l) + NErfTable[0][k_Terms-1] ;
   NErfTable[2][k_Terms-1] = 2.0*(f1h-f2l) + NErfTable[1][k_Terms-1] ;
   NErfTable[3][k_Terms-1] = 2.0*(f2h-f3l) + NErfTable[2][k_Terms-1] ;
   NErfTable[4][k_Terms-1] = 2.0*(f3h-f4l) + NErfTable[3][k_Terms-1] ;
   NErfTable[5][k_Terms-1] = 2.0*(f4h-f5l) + NErfTable[4][k_Terms-1] ;
   NErfTable[6][k_Terms-1] = 2.0*(f5h-f6l) + NErfTable[5][k_Terms-1] ;
   NErfTable[7][k_Terms-1] = 2.0*(f6h-f7l) + NErfTable[6][k_Terms-1] ;


}

} ;

double ErfEvaluator::DErfcTable[ErfEvaluator::k_Slices][ErfEvaluator::k_Terms] ;
double ErfEvaluator::NErfTable[ErfEvaluator::k_Slices][ErfEvaluator::k_Terms] ;

ErfEvaluator ErfEval ;

void ShowErfEvaluator(void)
{
   for (int slice=0; slice<ErfEvaluator::k_Slices; slice+=1)
   {
     for (int qq=0; qq<ErfEvaluator::k_Terms; qq+=1)
     {
        cout << '\n' << setw(4) <<  qq
             << ' ' << setw(20) << ErfEvaluator::DErfcTable[slice][(ErfEvaluator::k_Terms-1)-qq]
             << ' ' << setw(20) << ErfEvaluator::NErfTable[slice][(ErfEvaluator::k_Terms-1)-qq]
             ;
     } /* endfor */
   } /* endfor */
}

int main(void)
{

   double x=0.0 ;
   ShowErfEvaluator() ;
   for (int t=0; t<100; t+=1)
   {
     double f0, df0 ;
     double f1, df1 ;
     ErfEvaluator::Evaluate( x,f0,df0) ;
     ErfEvaluator::Evaluate(-x,f1,df1) ;
     cout << '\n' << setw(8) << x
          << ' ' << setw(16) << setprecision(10) << f0
          << ' ' << setw(16) << setprecision(10) << DerivativeErrorFunction::FunctionToFit( x)
          << ' ' << setw(16) << setprecision(10) << df0
          << ' ' << setw(16) << setprecision(10) << f1
          << ' ' << setw(16) << setprecision(10) << DerivativeErrorFunction::FunctionToFit(-x)
          << ' ' << setw(16) << setprecision(10) << df1
          ;
     x += 0.1 ;
   } /* endfor */
   return 0 ;
}
