/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Test cases to explore floating-point efficiency on Blue Light with double hummer
 *
 *  Bond vector computation
 *
 *  This tests the compiler's ability to
 *  1) Assign registers effectively, without causing spills or reloads
 *  2) Pair operations up for issuing Double Hummer parallel instructions
 *  3) Schedule instructions to avoid delays from data dependencies
 *  4) Choose optimally whether to do 'load parallel' and 'store parallel'
 *
 *  Expectations for the loop
 *  1) Automatics and temporaries all in registers
 *  2) No reloads from storage
 *  3) All FP ops parallel
 *  4) All cycles have a load or store
 *  5) Compiler chooses to do 'load parallel' and 'store parallel' for (x,y) coordinates
 *
 * Chris Ward
 *  20010822
 */
#include <BlueMatter/fpexploit.hpp>
void forcesum5 (
  XYZA* TotalForceTable
  , const XYZA* PartialForceTable
  , const unsigned int* RAMap
  , unsigned int groupcount
) {
#pragma disjoint(* TotalForceTable, * PartialForceTable)
#pragma disjoint(* TotalForceTable, * RAMap)
   for (unsigned int x=0; x<=groupcount; x+=1)
   {
      XYZ r0 = PartialForceTable[50*x+5*0+0].mXYZ ;
      XYZ r1 = PartialForceTable[50*x+5*1+0].mXYZ ;
      XYZ r2 = PartialForceTable[50*x+5*2+0].mXYZ ;
      XYZ r3 = PartialForceTable[50*x+5*3+0].mXYZ ;
      XYZ r4 = PartialForceTable[50*x+5*4+0].mXYZ ;
      XYZ r5 = PartialForceTable[50*x+5*5+0].mXYZ ;
      XYZ r6 = PartialForceTable[50*x+5*6+0].mXYZ ;
      XYZ r7 = PartialForceTable[50*x+5*7+0].mXYZ ;
      XYZ r8 = PartialForceTable[50*x+5*8+0].mXYZ ;
      XYZ r9 = PartialForceTable[50*x+5*9+0].mXYZ ;

      r0 = r0 + PartialForceTable[50*x+5*0+1].mXYZ ;
      r1 = r1 + PartialForceTable[50*x+5*1+1].mXYZ ;
      r2 = r2 + PartialForceTable[50*x+5*2+1].mXYZ ;
      r3 = r3 + PartialForceTable[50*x+5*3+1].mXYZ ;
      r4 = r4 + PartialForceTable[50*x+5*4+1].mXYZ ;
      r5 = r5 + PartialForceTable[50*x+5*5+1].mXYZ ;
      r6 = r6 + PartialForceTable[50*x+5*6+1].mXYZ ;
      r7 = r7 + PartialForceTable[50*x+5*7+1].mXYZ ;
      r8 = r8 + PartialForceTable[50*x+5*8+1].mXYZ ;
      r9 = r9 + PartialForceTable[50*x+5*9+1].mXYZ ;

      r0 = r0 + PartialForceTable[50*x+5*0+2].mXYZ ;
      r1 = r1 + PartialForceTable[50*x+5*1+2].mXYZ ;
      r2 = r2 + PartialForceTable[50*x+5*2+2].mXYZ ;
      r3 = r3 + PartialForceTable[50*x+5*3+2].mXYZ ;
      r4 = r4 + PartialForceTable[50*x+5*4+2].mXYZ ;
      r5 = r5 + PartialForceTable[50*x+5*5+2].mXYZ ;
      r6 = r6 + PartialForceTable[50*x+5*6+2].mXYZ ;
      r7 = r7 + PartialForceTable[50*x+5*7+2].mXYZ ;
      r8 = r8 + PartialForceTable[50*x+5*8+2].mXYZ ;
      r9 = r9 + PartialForceTable[50*x+5*9+2].mXYZ ;

      r0 = r0 + PartialForceTable[50*x+5*0+3].mXYZ ;
      r1 = r1 + PartialForceTable[50*x+5*1+3].mXYZ ;
      r2 = r2 + PartialForceTable[50*x+5*2+3].mXYZ ;
      r3 = r3 + PartialForceTable[50*x+5*3+3].mXYZ ;
      r4 = r4 + PartialForceTable[50*x+5*4+3].mXYZ ;
      r5 = r5 + PartialForceTable[50*x+5*5+3].mXYZ ;
      r6 = r6 + PartialForceTable[50*x+5*6+3].mXYZ ;
      r7 = r7 + PartialForceTable[50*x+5*7+3].mXYZ ;
      r8 = r8 + PartialForceTable[50*x+5*8+3].mXYZ ;
      r9 = r9 + PartialForceTable[50*x+5*9+3].mXYZ ;

      r0 = r0 + PartialForceTable[50*x+5*0+4].mXYZ ;
      r1 = r1 + PartialForceTable[50*x+5*1+4].mXYZ ;
      r2 = r2 + PartialForceTable[50*x+5*2+4].mXYZ ;
      r3 = r3 + PartialForceTable[50*x+5*3+4].mXYZ ;
      r4 = r4 + PartialForceTable[50*x+5*4+4].mXYZ ;
      r5 = r5 + PartialForceTable[50*x+5*5+4].mXYZ ;
      r6 = r6 + PartialForceTable[50*x+5*6+4].mXYZ ;
      r7 = r7 + PartialForceTable[50*x+5*7+4].mXYZ ;
      r8 = r8 + PartialForceTable[50*x+5*8+4].mXYZ ;
      r9 = r9 + PartialForceTable[50*x+5*9+4].mXYZ ;

      unsigned int a0 = RAMap[10*x+0];
      unsigned int a1 = RAMap[10*x+1];
      unsigned int a2 = RAMap[10*x+2];
      unsigned int a3 = RAMap[10*x+3];
      unsigned int a4 = RAMap[10*x+4];
      unsigned int a5 = RAMap[10*x+5];
      unsigned int a6 = RAMap[10*x+6];
      unsigned int a7 = RAMap[10*x+7];
      unsigned int a8 = RAMap[10*x+8];
      unsigned int a9 = RAMap[10*x+9];

      TotalForceTable[a0].mXYZ = r0 ;
      TotalForceTable[a1].mXYZ = r1 ;
      TotalForceTable[a2].mXYZ = r2 ;
      TotalForceTable[a3].mXYZ = r3 ;
      TotalForceTable[a4].mXYZ = r4 ;
      TotalForceTable[a5].mXYZ = r5 ;
      TotalForceTable[a6].mXYZ = r6 ;
      TotalForceTable[a7].mXYZ = r7 ;
      TotalForceTable[a8].mXYZ = r8 ;
      TotalForceTable[a9].mXYZ = r9 ;
   } /* endfor */
   }
