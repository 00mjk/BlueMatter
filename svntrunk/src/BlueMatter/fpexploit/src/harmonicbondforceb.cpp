/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Test cases to explore floating-point efficiency on Blue Light with double hummer
 *
 *  Bond vector computation
 *
 *  This tests the compiler's ability to
 *  1) Assign registers effectively, without causing spills or reloads
 *  2) Pair operations up for issuing Double Hummer parallel instructions
 *  3) Schedule instructions to avoid delays from data dependencies
 *  4) Choose optimally whether to do 'load parallel' and 'store parallel'
 *
 *  Expectations for the loop
 *  1) Automatics and temporaries all in registers
 *  2) No reloads from storage
 *  3) All FP ops parallel
 *  4) All cycles have a FP op, alternatively all cycles have a load or store
 *  5) Compiler chooses not to do 'load parallel' or 'store parallel'
 *
 *  Additional expectation
 *  At the end of the loop, the compiler will use the fact that addition is associative to rearrange the
 *  energy sum as (((0+1)+(2+3))+((4+5)+(6+7)))+(8+9) or something similar, to best hide the 5-cycle
 *  adder pipeline delay, and to exploit Double Hummer if appropriate
 *
 *  Note: I have not checked whether register pressure is such as to logically require spilling. If it
 *  does spill, and if the spillage costs cycles, try deleting the 'energy' calculations.
 * Chris Ward
 *  20010822
 */
#include <BlueMatter/fpexploit.hpp>

void HarmonicBondForce(
   XYZA* PartialForceTable
   , double& TotalEnergy
   , const MD_BondVector* BondVectorTable
   , const MD_HarmonicBondSpec* HarmonicBondSpecTable
//   , unsigned int groupcount
   )
{
#pragma disjoint(* PartialForceTable, * BondVectorTable)
#pragma disjoint(* PartialForceTable, * HarmonicBondSpecTable)
  QuadWordAligned(PartialForceTable) ;
  QuadWordAligned(BondVectorTable) ;
  QuadWordAligned(HarmonicBondSpecTable) ;
  double energy0 = 0.0 ;
  double energy1 = 0.0 ;
  double energy2 = 0.0 ;
  double energy3 = 0.0 ;
  double energy4 = 0.0 ;
  double energy5 = 0.0 ;
  double energy6 = 0.0 ;
  double energy7 = 0.0 ;
  double energy8 = 0.0 ;
  double energy9 = 0.0 ;
  // Reciprocal length
  double rr0 = BondVectorTable[0].mRecipLength ;
  double rr1 = BondVectorTable[1].mRecipLength ;
  double rr2 = BondVectorTable[2].mRecipLength ;
  double rr3 = BondVectorTable[3].mRecipLength ;
  double rr4 = BondVectorTable[4].mRecipLength ;
  double rr5 = BondVectorTable[5].mRecipLength ;
  double rr6 = BondVectorTable[6].mRecipLength ;
  double rr7 = BondVectorTable[7].mRecipLength ;
  double rr8 = BondVectorTable[8].mRecipLength ;
  double rr9 = BondVectorTable[9].mRecipLength ;
  // Square length
  double r20 = BondVectorTable[0].mSquareLength ;
  double r21 = BondVectorTable[1].mSquareLength ;
  double r22 = BondVectorTable[2].mSquareLength ;
  double r23 = BondVectorTable[3].mSquareLength ;
  double r24 = BondVectorTable[4].mSquareLength ;
  double r25 = BondVectorTable[5].mSquareLength ;
  double r26 = BondVectorTable[6].mSquareLength ;
  double r27 = BondVectorTable[7].mSquareLength ;
  double r28 = BondVectorTable[8].mSquareLength ;
  double r29 = BondVectorTable[9].mSquareLength ;
//  for ( unsigned int x=0; x<=groupcount; x+=1)
  unsigned int x=0 ;
  {
     // Compute the length
     double ra0 = rr0 * r20 ;
     double ra1 = rr1 * r21 ;
     double ra2 = rr2 * r22 ;
     double ra3 = rr3 * r23 ;
     double ra4 = rr4 * r24 ;
     double ra5 = rr5 * r25 ;
     double ra6 = rr6 * r26 ;
     double ra7 = rr7 * r27 ;
     double ra8 = rr8 * r28 ;
     double ra9 = rr9 * r29 ;
     // Compute the distance from equilibrium
     double DeltaFromEquilibrium0 = ra0 - HarmonicBondSpecTable[10*x+0].mr0 ;
     double DeltaFromEquilibrium1 = ra1 - HarmonicBondSpecTable[10*x+1].mr0 ;
     double DeltaFromEquilibrium2 = ra2 - HarmonicBondSpecTable[10*x+2].mr0 ;
     double DeltaFromEquilibrium3 = ra3 - HarmonicBondSpecTable[10*x+3].mr0 ;
     double DeltaFromEquilibrium4 = ra4 - HarmonicBondSpecTable[10*x+4].mr0 ;
     double DeltaFromEquilibrium5 = ra5 - HarmonicBondSpecTable[10*x+5].mr0 ;
     double DeltaFromEquilibrium6 = ra6 - HarmonicBondSpecTable[10*x+6].mr0 ;
     double DeltaFromEquilibrium7 = ra7 - HarmonicBondSpecTable[10*x+7].mr0 ;
     double DeltaFromEquilibrium8 = ra8 - HarmonicBondSpecTable[10*x+8].mr0 ;
     double DeltaFromEquilibrium9 = ra9 - HarmonicBondSpecTable[10*x+9].mr0 ;
     // Bond stiffness
     double k0 = HarmonicBondSpecTable[10*x+0].mk ;
     double k1 = HarmonicBondSpecTable[10*x+1].mk ;
     double k2 = HarmonicBondSpecTable[10*x+2].mk ;
     double k3 = HarmonicBondSpecTable[10*x+3].mk ;
     double k4 = HarmonicBondSpecTable[10*x+4].mk ;
     double k5 = HarmonicBondSpecTable[10*x+5].mk ;
     double k6 = HarmonicBondSpecTable[10*x+6].mk ;
     double k7 = HarmonicBondSpecTable[10*x+7].mk ;
     double k8 = HarmonicBondSpecTable[10*x+8].mk ;
     double k9 = HarmonicBondSpecTable[10*x+9].mk ;
     // Force
     double DEDR0 = -2.0 * ( k0 * DeltaFromEquilibrium0 ) * rr0 ;
     double DEDR1 = -2.0 * ( k1 * DeltaFromEquilibrium1 ) * rr1 ;
     double DEDR2 = -2.0 * ( k2 * DeltaFromEquilibrium2 ) * rr2 ;
     double DEDR3 = -2.0 * ( k3 * DeltaFromEquilibrium3 ) * rr3 ;
     double DEDR4 = -2.0 * ( k4 * DeltaFromEquilibrium4 ) * rr4 ;
     double DEDR5 = -2.0 * ( k5 * DeltaFromEquilibrium5 ) * rr5 ;
     double DEDR6 = -2.0 * ( k6 * DeltaFromEquilibrium6 ) * rr6 ;
     double DEDR7 = -2.0 * ( k7 * DeltaFromEquilibrium7 ) * rr7 ;
     double DEDR8 = -2.0 * ( k8 * DeltaFromEquilibrium8 ) * rr8 ;
     double DEDR9 = -2.0 * ( k9 * DeltaFromEquilibrium9 ) * rr9 ;
     XYZ Force0 = BondVectorTable[10*x+0].mVec * DEDR0 ;
     XYZ Force1 = BondVectorTable[10*x+1].mVec * DEDR1 ;
     XYZ Force2 = BondVectorTable[10*x+2].mVec * DEDR2 ;
     XYZ Force3 = BondVectorTable[10*x+3].mVec * DEDR3 ;
     XYZ Force4 = BondVectorTable[10*x+4].mVec * DEDR4 ;
     XYZ Force5 = BondVectorTable[10*x+5].mVec * DEDR5 ;
     XYZ Force6 = BondVectorTable[10*x+6].mVec * DEDR6 ;
     XYZ Force7 = BondVectorTable[10*x+7].mVec * DEDR7 ;
     XYZ Force8 = BondVectorTable[10*x+8].mVec * DEDR8 ;
     XYZ Force9 = BondVectorTable[10*x+9].mVec * DEDR9 ;
     // Save the forces away as partial sums
     PartialForceTable[HarmonicBondSpecTable[10*x+0].mPartialForceRegisterIndexA].mXYZ = Force0 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+1].mPartialForceRegisterIndexA].mXYZ = Force1 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+2].mPartialForceRegisterIndexA].mXYZ = Force2 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+3].mPartialForceRegisterIndexA].mXYZ = Force3 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+4].mPartialForceRegisterIndexA].mXYZ = Force4 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+5].mPartialForceRegisterIndexA].mXYZ = Force5 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+6].mPartialForceRegisterIndexA].mXYZ = Force6 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+7].mPartialForceRegisterIndexA].mXYZ = Force7 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+8].mPartialForceRegisterIndexA].mXYZ = Force8 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+9].mPartialForceRegisterIndexA].mXYZ = Force9 ;
     PartialForceTable[HarmonicBondSpecTable[10*x+0].mPartialForceRegisterIndexB].mXYZ = negate(Force0) ;
     PartialForceTable[HarmonicBondSpecTable[10*x+1].mPartialForceRegisterIndexB].mXYZ = negate(Force1) ;
     PartialForceTable[HarmonicBondSpecTable[10*x+2].mPartialForceRegisterIndexB].mXYZ = negate(Force2) ;
     PartialForceTable[HarmonicBondSpecTable[10*x+3].mPartialForceRegisterIndexB].mXYZ = negate(Force3) ;
     PartialForceTable[HarmonicBondSpecTable[10*x+4].mPartialForceRegisterIndexB].mXYZ = negate(Force4) ;
     PartialForceTable[HarmonicBondSpecTable[10*x+5].mPartialForceRegisterIndexB].mXYZ = negate(Force5) ;
     PartialForceTable[HarmonicBondSpecTable[10*x+6].mPartialForceRegisterIndexB].mXYZ = negate(Force6) ;
     PartialForceTable[HarmonicBondSpecTable[10*x+7].mPartialForceRegisterIndexB].mXYZ = negate(Force7) ;
     PartialForceTable[HarmonicBondSpecTable[10*x+8].mPartialForceRegisterIndexB].mXYZ = negate(Force8) ;
     PartialForceTable[HarmonicBondSpecTable[10*x+9].mPartialForceRegisterIndexB].mXYZ = negate(Force9) ;
     // Energy
     //energy0 += ( k0 * DeltaFromEquilibrium0 ) * DeltaFromEquilibrium0 ;
     //energy1 += ( k1 * DeltaFromEquilibrium1 ) * DeltaFromEquilibrium1 ;
     //energy2 += ( k2 * DeltaFromEquilibrium2 ) * DeltaFromEquilibrium2 ;
     //energy3 += ( k3 * DeltaFromEquilibrium3 ) * DeltaFromEquilibrium3 ;
     //energy4 += ( k4 * DeltaFromEquilibrium4 ) * DeltaFromEquilibrium4 ;
     //energy5 += ( k5 * DeltaFromEquilibrium5 ) * DeltaFromEquilibrium5 ;
     //energy6 += ( k6 * DeltaFromEquilibrium6 ) * DeltaFromEquilibrium6 ;
     //energy7 += ( k7 * DeltaFromEquilibrium7 ) * DeltaFromEquilibrium7 ;
     //energy8 += ( k8 * DeltaFromEquilibrium8 ) * DeltaFromEquilibrium8 ;
     //energy9 += ( k9 * DeltaFromEquilibrium9 ) * DeltaFromEquilibrium9 ;
  } /* endfor */
//  TotalEnergy += energy0
//             + energy1
//             + energy2
//             + energy3
//             + energy4
//             + energy5
//             + energy6
//             + energy7
//             + energy8
//             + energy9 ;
}
