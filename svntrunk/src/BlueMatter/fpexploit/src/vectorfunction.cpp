/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include <math.h>
#include <builtins.h>

#define fsel(a,b,c) __fsel(a,b,c)

class vector_function
{
   public:
   enum {
      k_VectorLength = 100
      } ;
   double f[k_VectorLength] ;
} ;

class unary_vector_function: public vector_function
{
   public:
   double x[k_VectorLength] ;
   void reciprocal(void) ;
   void reciprocal_square_root(void) ;
   void square_root(void) ;
   void erfc(void) ;
   void hexp(void) ;
} ;

class binary_vector_function: public vector_function
{
   public:
   double x[k_VectorLength] ;
   double y[k_VectorLength] ;
   void atrig(void) ;
} ;

/*
 *
 * f(x) = 1.0/x
 *
 */
static inline double reciprocal(double x)
{
   return 1.0/x ;
}

void unary_vector_function::reciprocal(void)
{
   for (int a=0; a<k_VectorLength; a+=1)
   {
      f[a] = ::reciprocal(x[a]) ;
   } /* endfor */
}

/*
 * f(x) = 1.0/sqrt(x)
 */
static inline double reciprocal_square_root(double x)
{
   return 1.0/sqrt(x) ;
}

void unary_vector_function::reciprocal_square_root(void)
{
   for (int a=0; a<k_VectorLength; a+=1)
   {
      f[a] = ::reciprocal_square_root(x[a]) ;
   } /* endfor */
}

/*
 * f(x) = sqrt(x)
 */
static inline double square_root(double x)
{
   return sqrt(x) ;
}

void unary_vector_function::square_root(void)
{
   for (int a=0; a<k_VectorLength; a+=1)
   {
      f[a] = ::square_root(x[a]) ;
   } /* endfor */
}

/*
 * f(x) = erfc(x)
 */
class ChebyshevEvaluator
{
  public:
  enum {
     k_Terms = 16
     } ;

  static double RawEvaluate(double x, double*c)
  {
     double dpp = 0.0 ;
     double dp = 0.0 ;
     for (int j=0; j<k_Terms-1; j+=1)
     {
        double d=(2.0*x)*dp - dpp + c[j] ;
        dpp = dp ;
        dp = d ;
     } /* endfor */
     // Term 0 is a special case; POWER 'multiply-add' makes this same efficiency as rewriting the table
     double result = x*dp - dpp + 0.5*(c[k_Terms-1]) ;
     return result ;
  }
} ;

class ErfEvaluator: public ChebyshevEvaluator
{
   public:
   enum {
      k_Slices = 8 ,
      } ;

    static double NErfTable[k_Slices][k_Terms] ;

    static double NearestInteger(const double x)
    {
       const double two10 = 1024.0 ;
       const double two50 = two10 * two10 * two10 * two10 * two10 ;
       const double two52 = two50 * 4.0 ;
       const double two51 = two50 * 2.0 ;
       const double offset = two52 + two51 ;

       const double losebits = x + offset ;
       const double result = losebits - offset ;
       return result ;
    }

    static double Evaluate(const double x )
    {

       double xam = abs(x) - 0.5 ;

       double xi = NearestInteger(xam) ;
       double xf = xam-xi ;                 // -0.5 < x < 0.5
       int ix = (int) xi ;
       int ixmask = ix & 7 ;

       double * MyNErfTable = NErfTable[ixmask] ;

       double  r0 = RawEvaluate(2.0*xf, MyNErfTable) ;
       double  r1 = fsel(xi-7.5,-1.0,  r0) ;
       double   m = fsel(x,1.0, -1.0) ;
       double  r2 = 1.0+m*r1 ;

       return r2    ;

    }

} ;

void unary_vector_function::erfc(void)
{
   for (int a=0; a<k_VectorLength; a+=1)
   {
      f[a] = ErfEvaluator::Evaluate(x[a]) ;
   } /* endfor */
}


/*
 * f(x) = exp(x)
 */
/*
 * Storage mapping of an IEEE double-precision number, for access to parts of it as integers or bits
 * This is big-endian specific, for little-endian you have to swap m_hi and m_lo, then test it !
 * The intended use of this is in calculating exp(x)
 */
class DoubleMap
{
  public:
  class UIntPair
  {
     public:
    unsigned int m_hi ;
    unsigned int m_lo ;
  } ;
   union {
      double m_d ;
      UIntPair m_u ;
      } m_value ;
  DoubleMap(void) { } ;
  DoubleMap(double X) { m_value.m_d = X ; } ;
  DoubleMap(
    unsigned int Xsign ,   // 0 for positive, 1 for negative
    unsigned int Xexponent ,
    unsigned int Xsignificand_hi ,  // The 0x00100000 bit had better be set, to get the right answer
    unsigned int Xsignificand_lo
    ) {
       m_value.m_u.m_hi = ( ( Xsign << 31 )                & 0x80000000 )
                        | ( ( (Xexponent + 1023 )  << 20 ) & 0x7ff00000 )
                        | ( Xsignificand_hi                & 0x000fffff ) ;
       m_value.m_u.m_lo = Xsignificand_lo ;
   } ;
  double GetValue(void) const { return m_value.m_d ; } ;

  void SetValue(double X) { m_value.m_d = X ; } ;
  void SetValue(
    unsigned int Xsign ,   // 0 for positive, 1 for negative
    unsigned int Xexponent ,
    unsigned int Xsignificand_hi ,  // The 0x00100000 bit had better be set, to get the right answer
    unsigned int Xsignificand_lo
    ) {
       m_value.m_u.m_hi = ( ( Xsign << 31 )                & 0x80000000 )
                        | ( ( (Xexponent + 1023 )  << 20 ) & 0x7ff00000 )
                        | ( Xsignificand_hi                & 0x000fffff ) ;
       m_value.m_u.m_lo = Xsignificand_lo ;
   } ;

  unsigned int HiWord(void) const { return m_value.m_u.m_hi ; } ;
  unsigned int LoWord(void) const { return m_value.m_u.m_lo ; } ;

  unsigned int SignBit(void) const { return HiWord() & 0x80000000 ; } ;
  unsigned int ExponentBits(void) const { return HiWord() & 0x7ff00000 ; } ;
  unsigned int SignificandHiBits(void) const { return HiWord() & 0x000fffff ; } ;
  unsigned int SignificandLoBits(void) const { return LoWord() ; } ;

  void SetSignificandHiBits(unsigned int new_hi_bits) { m_value.m_u.m_hi = ( m_value.m_u.m_hi & 0xfff00000 )
                                                                            | ( new_hi_bits & 0x000fffff ) ; }
  int Exponent(void) const { return ( ExponentBits() >> 20 ) - 1023 ; } ;
  unsigned int SignificandHi(void) const { return SignificandHiBits() | 0x00100000 ; } ;
  unsigned int SignificandLo(void) const { return SignificandLoBits() ; } ;
  bool IsNegative(void) const { return  0 != SignBit() ; } ;
} ;

  /*
   * Constants involved in exp(x)
   */
  double Infinity ;
  double ExpTable1[16] ;
  double ExpTable2[16] ;

  static inline double hexp(double x)
  {

    const double tp10 = 1024.0 ;
    const double tp20 = tp10*tp10 ;
    const double tp40 = tp20*tp20 ;

     // Dividing by ln(2) gives a value such that we can put the integer part into an exponent.
     // Adding (2**44+2**43) aligns and rounds this so that
     // bottom 8 bits can be used for lookup
     // higher bits can be stuffed into exponent
     // truncated bits (recovered by subtraction) can be fed to power series
    const double x1 = x * ( 1.0 / M_LN2 ) + ( tp40 * ( 16.0 + 8.0 ) ) ;
    const DoubleMap m1(x1) ;
    // Figure the appropriate power of 2 from the significand high bits
    const unsigned int sig_lo = m1.SignificandLoBits() ;
    const DoubleMap m2(0,sig_lo >> 8, 0, 0) ;
    // Recover the number that we will have 'exponentiated' by the bit twiddling
    const double xl2 =  x1 - ( tp40 * ( 16.0 + 8.0 ) ) ;
    // Can range-check xl2 to see if sig_lo put a sensible value in m2
    const double xx4 = xl2 * M_LN2 ;

    // Look up the next several bits (4) in a multiplication table
    const unsigned int tabits =(sig_lo >> 4) & 0x0f ;
    const double x31 = ExpTable1[tabits] ;

    // And the next 4 bits in another table
    const unsigned int tabits2=sig_lo & 0x0f ;
    const double x32 = ExpTable2[tabits2] ;

    const double x3 = x31*x32 ;

    // Figure the remaining part of the original number
    const double z = x - xx4 ;
    // z should be between +- (2**-8); feed in to polynomial for exp(z)

    const double f5 =          1.0/(2.0*3.0*4.0*5.0) ;
    const double f4 = z * f5 + 1.0/(2.0*3.0*4.0) ;
    const double f3 = z * f4 + 1.0/(2.0*3.0) ;
    const double f2 = z * f3 + 1.0/2.0 ;
    const double f1 = z * f2 + 1.0 ;
    const double f0 = z * f1 + 1.0 ;

    const double p0 = f0 * x3 ;

    const double x2=m2.GetValue() ;

    const double r0 = p0 * x2 ;

    // Fixup for out-of-range parameter
    const double resultl = fsel(x+709.0, r0, 0.0) ;
    const double resulth = fsel(x-709.0, Infinity, resultl) ;

    return resulth ;
  }

void unary_vector_function::hexp(void)
{
   for (int a=0; a<k_VectorLength; a+=1)
   {
      f[a] = ::hexp(x[a]) ;
   } /* endfor */
}

/*
 * 'atrig', given sin and cos of an angle, evaluate the angle
 */

static inline double asin_small(double x)
    {
       const double ap0 = 1.0           , aq0 = 1.0       ;
       const double ap1 = ap0 * 1.0     , aq1 = aq0 * 2.0 ;
       const double ap2 = ap1 * 3.0     , aq2 = aq1 * 4.0 ;
       const double ap3 = ap2 * 5.0     , aq3 = aq2 * 6.0 ;
       const double ap4 = ap3 * 7.0     , aq4 = aq3 * 8.0 ;
       const double ap5 = ap4 * 9.0     , aq5 = aq4 * 10.0 ;
       const double ap6 = ap5 * 11.0    , aq6 = aq5 * 12.0 ;
       const double ap7 = ap6 * 13.0    , aq7 = aq6 * 14.0 ;
       const double ap8 = ap7 * 15.0    , aq8 = aq7 * 16.0 ;
       const double ap9 = ap8 * 17.0    , aq9 = aq8 * 18.0 ;
       const double apa = ap9 * 19.0    , aqa = aq9 * 20.0 ;
       const double apb = apa * 21.0    , aqb = aqa * 22.0 ;
       const double apc = apb * 23.0    , aqc = aqb * 24.0 ;
       const double apd = apc * 25.0    , aqd = aqc * 26.0 ;
       const double ape = apd * 27.0    , aqe = aqd * 28.0 ;
       const double apf = ape * 29.0    , aqf = aqe * 30.0 ;
       const double a14 =  apf / ( aqf * 31.0 ) ;
       const double a13 =  ape / ( aqe * 29.0 ) ;
       const double a12 =  apd / ( aqd * 27.0 ) ;
       const double a11 =  apc / ( aqc * 25.0 ) ;      ;
       const double a10 =  apb / ( aqb * 23.0 ) ;
       const double a9  =  apa / ( aqa * 21.0 ) ;
       const double a8  =  ap9 / ( aq9 * 19.0 ) ;
       const double a7  =  ap8 / ( aq8 * 17.0 ) ;
       const double a6  =  ap7 / ( aq7 * 15.0 ) ;
       const double a5  =  ap6 / ( aq6 * 13.0 ) ;
       const double a4  =  ap5 / ( aq5 * 11.0 ) ;
       const double a3  =  ap4 / ( aq4 * 9.0 ) ;
       const double a2  =  ap3 / ( aq3 * 7.0 ) ;
       const double a1  =  ap2 / ( aq2 * 5.0 ) ;
       const double a0  =  ap1 / ( aq1 * 3.0 ) ;

      double b = x*x;
      double t0 = a14 * b + a13;
      double s = b * b;
      t0 = (((((t0*s + a11)*s + a9)*s + a7)*s + a5)*s +a3)*s
        + a1;
      double t1 = (((((a12*s + a10)*s + a8)*s + a6)*s + a4)*s + a2);
      return ( x + (x*b)*(a0 + b*(t0 + b*t1)));
    }

    // Given the sin and cos of an angle, return the angle.
    // Returns an angle in (-PI, PI)

    inline static double atrig ( double sinang, double cosang )
    {
      const double piby8 = M_PI / 8.0 ; // 22.5 degrees, in radians;
      const double pi3by8 = M_PI * ( 3.0 / 8.0 ) ; // 3*22.5 degrees, in radians;
      const double pi5by8 = M_PI * ( 5.0 / 8.0 ) ; // 5*22.5 degrees, in radians;
      const double pi7by8 = M_PI * ( 7.0 / 8.0 ) ; // 7*22.5 degrees, in radians;
      const double cospiby4 = sqrt(2.0) * 0.5 ;
      const double cospiby8 = sqrt((1+cospiby4) * 0.5) ;
      const double sinpiby8 = sqrt(1-cospiby8*cospiby8) ;
      double abscos = fabs(cosang) ; // abscos in (0,1)
      double abssin = fabs(sinang) ; // abssin in (0,1)
      double coslarge = abscos - abssin ;
      // Now we have the sin and cos of an angle between 0 and 90 degrees
      double sincand1 = abssin * cospiby8 - abscos * sinpiby8 ; // sin of an angle in (-22.5,+67.5 degrees)
      double coscand2 = abscos * cospiby8 - abssin * sinpiby8 ; // cos of an angle in (+22.5, 112.5 degrees)
                                                                // which is sin of an angle in (+67.5, -22.5 degrees)

      double trigang = fsel( coslarge , sincand1 , coscand2 ); // reduced-range item ready for 'arcsin'
      double ang = asin_small(trigang) ;
      // Now we have an angle which is piecewise-linear related to the wanted one, over the whole circle
      // Compute the multiplier and addend to stitch the angle back together
      // according as which octant we are in; this computation is interleavable
      // since both are branchless
      double km0 = fsel( sinang, 1.0, -1.0 ) ;
      double km1 = fsel( sinang, -1.0, 1.0 ) ;
      double kma = fsel(  coslarge , km0 , km1  ) ;
      double kmb = fsel(  coslarge , km1 , km0 ) ;

      double km  = fsel( cosang , kma , kmb ) ;

      double kaa = fsel( coslarge , piby8, pi3by8 ) ;
      double kab = fsel( coslarge , pi7by8, pi5by8 ) ;
      double ka  = fsel( cosang , kaa , kab ) * km0 ;

      // And stitch the angle back together
      return (ang*km) + ka ;

    } ;

void binary_vector_function::atrig(void)
{
   for (int a=0; a<k_VectorLength; a+=1)
   {
      f[a] = ::atrig(y[a],x[a]) ;
   } /* endfor */
}

