/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #include <BlueMatter/fpexploit.hpp>

typedef double* doubleptr ;
static inline double chebev_term (
    double twox
  , double dj1
  , double dj2
  , doubleptr& c
) {
   c += 1 ;
   double result = twox*dj1 + dj2 + *c ;
   return result ;
   }

static inline void chebev10( double* results, double*  x, double** c, unsigned int terms )
{
   QuadWordAligned(results) ;
   QuadWordAligned(x) ;

   volatile double storeforce[10] ;

   double x0 = x[0] ;
   double x1 = x[1] ;
   double x2 = x[2] ;
   double x3 = x[3] ;
   double x4 = x[4] ;
   double x5 = x[5] ;
   double x6 = x[6] ;
   double x7 = x[7] ;
   double x8 = x[8] ;
   double x9 = x[9] ;

   double* c0 = c[0] ;
   double* c1 = c[1] ;
   double* c2 = c[2] ;
   double* c3 = c[3] ;
   double* c4 = c[4] ;
   double* c5 = c[5] ;
   double* c6 = c[6] ;
   double* c7 = c[7] ;
   double* c8 = c[8] ;
   double* c9 = c[9] ;

   double twox0 = 2.0*x0 ;
   double twox1 = 2.0*x1 ;
   double twox2 = 2.0*x2 ;
   double twox3 = 2.0*x3 ;
   double twox4 = 2.0*x4 ;
   double twox5 = 2.0*x5 ;
   double twox6 = 2.0*x6 ;
   double twox7 = 2.0*x7 ;
   double twox8 = 2.0*x8 ;
   double twox9 = 2.0*x9 ;

   double dma0 = *c0 ;
   double dma1 = *c1 ;
   double dma2 = *c2 ;
   double dma3 = *c3 ;
   double dma4 = *c4 ;
   double dma5 = *c5 ;
   double dma6 = *c6 ;
   double dma7 = *c7 ;
   double dma8 = *c8 ;
   double dma9 = *c9 ;

             storeforce[0] = dma0 ;
             storeforce[1] = dma1 ;
             storeforce[2] = dma2 ;
             storeforce[3] = dma3 ;
             storeforce[4] = dma4 ;
             storeforce[5] = dma5 ;
             storeforce[6] = dma6 ;
             storeforce[7] = dma7 ;
             storeforce[8] = dma8 ;
             storeforce[9] = dma9 ;


   double dmb0 = twox0*dma0 + (*(c0+1)) ;
   double dmb1 = twox1*dma1 + (*(c1+1)) ;
   double dmb2 = twox2*dma2 + (*(c2+1)) ;
   double dmb3 = twox3*dma3 + (*(c3+1)) ;
   double dmb4 = twox4*dma4 + (*(c4+1)) ;
   double dmb5 = twox5*dma5 + (*(c5+1)) ;
   double dmb6 = twox6*dma6 + (*(c6+1)) ;
   double dmb7 = twox7*dma7 + (*(c7+1)) ;
   double dmb8 = twox8*dma8 + (*(c8+1)) ;
   double dmb9 = twox9*dma9 + (*(c9+1)) ;

             storeforce[0] = dmb0 ;
             storeforce[1] = dmb1 ;
             storeforce[2] = dmb2 ;
             storeforce[3] = dmb3 ;
             storeforce[4] = dmb4 ;
             storeforce[5] = dmb5 ;
             storeforce[6] = dmb6 ;
             storeforce[7] = dmb7 ;
             storeforce[8] = dmb8 ;
             storeforce[9] = dmb9 ;

   c0 += 2 ;
   c1 += 2 ;
   c2 += 2 ;
   c3 += 2 ;
   c4 += 2 ;
   c5 += 2 ;
   c6 += 2 ;
   c7 += 2 ;
   c8 += 2 ;
   c9 += 2 ;


   for (unsigned int tx=0; tx<=terms;tx+=1 )
   {
      double dmc0 = chebev_term(twox0, dmb0, dma0, c0) ;
      double dmc1 = chebev_term(twox1, dmb1, dma1, c1) ;
      double dmc2 = chebev_term(twox2, dmb2, dma2, c2) ;
      double dmc3 = chebev_term(twox3, dmb3, dma3, c3) ;
      double dmc4 = chebev_term(twox4, dmb4, dma4, c4) ;
      double dmc5 = chebev_term(twox5, dmb5, dma5, c5) ;
      double dmc6 = chebev_term(twox6, dmb6, dma6, c6) ;
      double dmc7 = chebev_term(twox7, dmb7, dma7, c7) ;
      double dmc8 = chebev_term(twox8, dmb8, dma8, c8) ;
      double dmc9 = chebev_term(twox9, dmb9, dma9, c9) ;

             storeforce[0] = dmc0 ;
             storeforce[1] = dmc1 ;
             storeforce[2] = dmc2 ;
             storeforce[3] = dmc3 ;
             storeforce[4] = dmc4 ;
             storeforce[5] = dmc5 ;
             storeforce[6] = dmc6 ;
             storeforce[7] = dmc7 ;
             storeforce[8] = dmc8 ;
             storeforce[9] = dmc9 ;

             dma0 = chebev_term(twox0, dmc0, dmb0, c0) ;
             dma1 = chebev_term(twox1, dmc1, dmb1, c1) ;
             dma2 = chebev_term(twox2, dmc2, dmb2, c2) ;
             dma3 = chebev_term(twox3, dmc3, dmb3, c3) ;
             dma4 = chebev_term(twox4, dmc4, dmb4, c4) ;
             dma5 = chebev_term(twox5, dmc5, dmb5, c5) ;
             dma6 = chebev_term(twox6, dmc6, dmb6, c6) ;
             dma7 = chebev_term(twox7, dmc7, dmb7, c7) ;
             dma8 = chebev_term(twox8, dmc8, dmb8, c8) ;
             dma9 = chebev_term(twox9, dmc9, dmb9, c9) ;

             storeforce[0] = dma0 ;
             storeforce[1] = dma1 ;
             storeforce[2] = dma2 ;
             storeforce[3] = dma3 ;
             storeforce[4] = dma4 ;
             storeforce[5] = dma5 ;
             storeforce[6] = dma6 ;
             storeforce[7] = dma7 ;
             storeforce[8] = dma8 ;
             storeforce[9] = dma9 ;

             dmb0 = chebev_term(twox0, dma0, dmc0, c0) ;
             dmb1 = chebev_term(twox1, dma1, dmc1, c1) ;
             dmb2 = chebev_term(twox2, dma2, dmc2, c2) ;
             dmb3 = chebev_term(twox3, dma3, dmc3, c3) ;
             dmb4 = chebev_term(twox4, dma4, dmc4, c4) ;
             dmb5 = chebev_term(twox5, dma5, dmc5, c5) ;
             dmb6 = chebev_term(twox6, dma6, dmc6, c6) ;
             dmb7 = chebev_term(twox7, dma7, dmc7, c7) ;
             dmb8 = chebev_term(twox8, dma8, dmc8, c8) ;
             dmb9 = chebev_term(twox9, dma9, dmc9, c9) ;

             storeforce[0] = dmb0 ;
             storeforce[1] = dmb1 ;
             storeforce[2] = dmb2 ;
             storeforce[3] = dmb3 ;
             storeforce[4] = dmb4 ;
             storeforce[5] = dmb5 ;
             storeforce[6] = dmb6 ;
             storeforce[7] = dmb7 ;
             storeforce[8] = dmb8 ;
             storeforce[9] = dmb9 ;
   } /* endfor */
   double r0 = x0*dmb0 - dma0 + *c0 ;
   double r1 = x1*dmb1 - dma1 + *c1 ;
   double r2 = x2*dmb2 - dma2 + *c2 ;
   double r3 = x3*dmb3 - dma3 + *c3 ;
   double r4 = x4*dmb4 - dma4 + *c4 ;
   double r5 = x5*dmb5 - dma5 + *c5 ;
   double r6 = x6*dmb6 - dma6 + *c6 ;
   double r7 = x7*dmb7 - dma7 + *c7 ;
   double r8 = x8*dmb8 - dma8 + *c8 ;
   double r9 = x9*dmb9 - dma9 + *c9 ;
   results[0] = r0 ;
   results[1] = r1 ;
   results[2] = r2 ;
   results[3] = r3 ;
   results[4] = r4 ;
   results[5] = r5 ;
   results[6] = r6 ;
   results[7] = r7 ;
   results[8] = r8 ;
   results[9] = r9 ;
}

void chebev10_x( double* results, double*  x, double** c, unsigned int terms )
{
  chebev10( results,  x,  c,  terms ) ;
}

void chebev10_3( double* results, double*  x, double** c )
{
  chebev10( results,  x,  c,  2 ) ;
}


void chebev2( double* results, double*  x, double** c, unsigned int terms )
{
   QuadWordAligned(results) ;
   QuadWordAligned(x) ;
   double x0 = x[0] ;
   double x1 = x[1] ;

   double twox0 = 2.0*x0 ;
   double twox1 = 2.0*x1 ;

   double dma0 = 0.0 ;
   double dma1 = 0.0 ;

   double dmb0 = 0.0 ;
   double dmb1 = 0.0 ;

   double* c0 = c[0] ;
   double* c1 = c[1] ;

   volatile double storeforce[2] ;

   for (unsigned int tx=0; tx<=terms;tx+=1 )
   {
      double dmc0 = chebev_term(twox0, dmb0, dma0, c0) ;
      double dmc1 = chebev_term(twox1, dmb1, dma1, c1) ;
//    c0 += 2 ;
//    c1 += 2 ;

             storeforce[0] = dmc0 ;
             storeforce[1] = dmc1 ;

             dma0 = chebev_term(twox0, dmc0, dmb0, c0) ;
             dma1 = chebev_term(twox1, dmc1, dmb1, c1) ;
//    c0 += 2 ;
//    c1 += 2 ;

             storeforce[0] = dma0 ;
             storeforce[1] = dma1 ;

             dmb0 = chebev_term(twox0, dma0, dmc0, c0) ;
             dmb1 = chebev_term(twox1, dma1, dmc1, c1) ;
//    c0 += 2 ;
//    c1 += 2 ;

             storeforce[0] = dmb0 ;
             storeforce[1] = dmb1 ;
   } /* endfor */
   double r0 = x0*dmb0 - dma0 + *c0 ;
   double r1 = x1*dmb1 - dma1 + *c1 ;

   results[0] = r0 ;
   results[1] = r1 ;
}


void chebev1( double* results, double*  x, double** c, unsigned int terms )
{
   double x0 = x[0] ;
   double twox0 = 2.0*x0 ;
   double dma0 = 0.0 ;
   double dmb0 = 0.0 ;
   double* c0 = c[0] ;
   volatile double storeforce ;
   for (unsigned int tx=0; tx<=terms;tx+=1 )
   {
      double dmc0 = chebev_term(twox0, dmb0, dma0, c0) ;
//    c0 += 2 ;
             storeforce = dmc0 ;
             dma0 = chebev_term(twox0, dmc0, dmb0, c0) ;
//    c0 += 2 ;
             storeforce = dma0 ;
             dmb0 = chebev_term(twox0, dma0, dmc0, c0) ;
//    c0 += 2 ;
             storeforce = dmb0 ;
   } /* endfor */
   double r0 = x0*dmb0 - dma0 + *c0 ;
   results[0] = r0 ;
}
