/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 // Bonded forces for a group of water molecules
#include <BlueMatter/fpexploit.hpp>

#define WaterBondK  1.1
#define WaterBondR0  1.2
#define WaterAngleK  1.3
#define WaterAngleTh0  1.4

static MD_BondSpec WaterBondSpec[] = {
   { 0, 1 } , { 1, 2 }
  ,{ 3, 4 } , { 4, 5 }
  ,{ 6, 7 } , { 7, 8 }
  ,{ 9,10 } , {10,11 }
  ,{12,13 } , {13,14 }
  ,{15,16 } , {16,17 }
  ,{18,19 } , {19,20 }
  ,{21,22 } , {22,23 }
  ,{24,25 } , {25,26 }
  ,{27,28 } , {28,29 }
     // 'cool down' at the end, the loop will access but ignore these
  ,{ 0, 0 } , { 0, 0 }
  ,{ 0, 0 } , { 0, 0 }
  ,{ 0, 0 } , { 0, 0 }
  ,{ 0, 0 } , { 0, 0 }
  ,{ 0, 0 } , { 0, 0 }
   } ;
static MD_HarmonicBondSpec WaterHarmonicBondSpec[] = {
   { WaterBondK, WaterBondR0, 0, 0, 40 }
  ,{ WaterBondK, WaterBondR0, 2, 2, 41 }
  ,{ WaterBondK, WaterBondR0, 4, 4, 43 }
  ,{ WaterBondK, WaterBondR0, 6, 6, 44 }
  ,{ WaterBondK, WaterBondR0, 8, 8, 46 }
  ,{ WaterBondK, WaterBondR0,10,10, 47 }
  ,{ WaterBondK, WaterBondR0,12,12, 49 }
  ,{ WaterBondK, WaterBondR0,14,14, 50 }
  ,{ WaterBondK, WaterBondR0,16,16, 52 }
  ,{ WaterBondK, WaterBondR0,18,18, 53 }
  ,{ WaterBondK, WaterBondR0,20,20, 55 }
  ,{ WaterBondK, WaterBondR0,22,22, 56 }
  ,{ WaterBondK, WaterBondR0,24,24, 58 }
  ,{ WaterBondK, WaterBondR0,26,26, 59 }
  ,{ WaterBondK, WaterBondR0,28,28, 61 }
  ,{ WaterBondK, WaterBondR0,30,30, 62 }
  ,{ WaterBondK, WaterBondR0,32,32, 64 }
  ,{ WaterBondK, WaterBondR0,34,34, 65 }
  ,{ WaterBondK, WaterBondR0,36,36, 67 }
  ,{ WaterBondK, WaterBondR0,38,38, 68 }
  // 'cool down' will access and ignore these
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
  ,{ 0.0       , WaterBondR0, 0, 0,  0 }
   } ;
static MD_HarmonicAngleSpec WaterHarmonicAngleSpec[] = {
   { WaterAngleK, WaterAngleTh0, 1, 3, 42 }
  ,{ WaterAngleK, WaterAngleTh0, 5, 7, 45 }
  ,{ WaterAngleK, WaterAngleTh0, 9,11, 48 }
  ,{ WaterAngleK, WaterAngleTh0,13,15, 51 }
  ,{ WaterAngleK, WaterAngleTh0,17,19, 54 }
  ,{ WaterAngleK, WaterAngleTh0,21,23, 57 }
  ,{ WaterAngleK, WaterAngleTh0,25,27, 60 }
  ,{ WaterAngleK, WaterAngleTh0,29,31, 63 }
  ,{ WaterAngleK, WaterAngleTh0,33,35, 66 }
  ,{ WaterAngleK, WaterAngleTh0,37,39, 69 }
  // 'cool down' will access and ignore these
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
  ,{ 0.0        , WaterAngleTh0, 0, 0,  0 }
   } ;
static unsigned int RAMap2[] = {
   0, 2
 , 3, 5
 , 6, 8
 , 9,11
 ,12,14
 ,15,17
 ,18,20
 ,21,23
 ,24,26
 ,27,29
 ,0,0,0,0,0,0,0,0,0,0
   } ;
static unsigned int RAMap3[] = {
   1
  ,4
  ,7
  ,10
  ,13
  ,16
  ,19
  ,22
  ,25
  ,28
 ,0,0,0,0,0,0,0,0,0,0
   } ;

enum {
     kBondVectors
   , kForceSum2
   , kForceSum3
   , kHarmonicBondForces
   , kHarmonicAngleForces
   } ;

static const int kInstrLengths[] = {
   4, 4, 4, 3, 3
   } ;

static const int WaterBondInstructions[] = {
    kBondVectors, 0, 0, 1
  , kHarmonicBondForces, 0, 0
  , kHarmonicAngleForces, 0, 0
  , kForceSum2, 0, 0, 1
  , kForceSum3, 40, 0, 0
   } ;

enum {
   kWaterBondInstructionCount = 5
   } ;

void WaterBond(
   XYZA* TotalForceTable
  ,const MD_Atom* AtomTable
  , double StretchEnergy
  , double AngleEnergy
  )
{
   MD_BondVector BondVectors[40] ;          // Make 40 bond vectors, in the small example
   XYZA PartialForceTable[70] ;             // 20 hydrogens with 2 forces, and 10 oxygens with 3 forces
   StretchEnergy = 0.0 ;
   AngleEnergy = 0.0 ;

   unsigned int InstrIndex = 0 ;
   for (unsigned int x=0; x<kWaterBondInstructionCount; x+=1)
   {
      unsigned int Instruction = WaterBondInstructions[InstrIndex] ;
      switch(Instruction) {
case kBondVectors :
   // Run a group of bond length calculations
   ComputeBondVectors(
      BondVectors+WaterBondInstructions[InstrIndex+1]
    , AtomTable
    , WaterBondSpec+WaterBondInstructions[InstrIndex+2]
    , WaterBondInstructions[InstrIndex+3]
    ) ;
//    1                   // 30 atoms, 10 molecules, 20 bonds, produces 40 vectors (i.e. including reverse)
   break;
case kForceSum2 :
   forcesum2(
     TotalForceTable
    ,PartialForceTable+WaterBondInstructions[InstrIndex+1]
    ,RAMap2+WaterBondInstructions[InstrIndex+2]
    , WaterBondInstructions[InstrIndex+3]
    ) ;
    // 20 atoms
   break;
case kForceSum3 :
   forcesum3(
     TotalForceTable
    ,PartialForceTable+WaterBondInstructions[InstrIndex+1]
    ,RAMap3+WaterBondInstructions[InstrIndex+2]
    , WaterBondInstructions[InstrIndex+3]
    ) ;
   break;
case kHarmonicBondForces :
   // Run a group of bond stretch calculations
   HarmonicBondForce(
     PartialForceTable
    ,StretchEnergy
    ,BondVectors
    ,WaterHarmonicBondSpec+WaterBondInstructions[InstrIndex+1]
    , WaterBondInstructions[InstrIndex+2]
   ) ;
   break;
case kHarmonicAngleForces :
   // Run a group of bond angle calculations
   HarmonicAngleForce(
     PartialForceTable
    ,AngleEnergy
    ,BondVectors
    ,WaterHarmonicAngleSpec+WaterBondInstructions[InstrIndex+1]
    , WaterBondInstructions[InstrIndex+2]
   ) ;
   break;
     } ;
     InstrIndex += kInstrLengths[Instruction] ;

   } /* endfor */
   // In this test case, we have cleared out the working storage (bond vectors and partial force table);
   // we could loop and reuse for more water molecules

}

