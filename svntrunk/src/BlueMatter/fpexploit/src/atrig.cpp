/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Test cases to explore floating-point efficiency on Blue Light with double hummer
 *
 *  Angle computation from sin and cos
 *
 *  This tests the compiler's ability to
 *  1) Assign registers effectively, without causing delays from spills or reloads
 *  2) Pair operations up for issuing Double Hummer parallel instructions
 *  3) Schedule instructions to avoid delays from data dependencies
 *  4) Choose optimally whether to do 'load parallel' and 'store parallel'
 *
 *  Expectations for the loop
 *  1) Automatics and temporaries all in registers
 *  2) No reloads of automatics and temporaries from storage, maybe reloads of constants from storage
 *  3) All FP ops parallel
 *  4) All cycles have a FP op
 *  5) Compiler's choice whether to parallelise loads and stores does not introduce delays
 *
 * Chris Ward
 *  20010821
 */
// 'fsel' is a built-in instruction on PPCGR and above, sometimes we want to force its use
#if defined(ARCH_HAS_FSEL)
#include <builtins.h>
#define fsel(a, x, y) __fsel((a),(x),(y))
#else
#define fsel(a, x, y) ( (a) >= 0.0 ? (x) : (y) )
#endif
#include <math.h>
#include <BlueMatter/fpatrig.hpp>
// #include <BlueMatter/fpexploit.hpp>

class SinCos {
   public:
   double mSin ;
   double mCos ;
   } ;


void vatrig(double * Angles, const SinCos* Parms, unsigned int groupcount)
{
#pragma disjoint(*Angles, *Parms)
   double s0 = Parms[0].mSin ;
   double c0 = Parms[0].mCos ;
   double s1 = Parms[1].mSin ;
   double c1 = Parms[1].mCos ;
   double s2 = Parms[2].mSin ;
   double c2 = Parms[2].mCos ;
   double s3 = Parms[3].mSin ;
   double c3 = Parms[3].mCos ;
   double s4 = Parms[4].mSin ;
   double c4 = Parms[4].mCos ;
   double s5 = Parms[5].mSin ;
   double c5 = Parms[5].mCos ;
   double s6 = Parms[6].mSin ;
   double c6 = Parms[6].mCos ;
   double s7 = Parms[7].mSin ;
   double c7 = Parms[7].mCos ;
   double s8 = Parms[8].mSin ;
   double c8 = Parms[8].mCos ;
   double s9 = Parms[9].mSin ;
   double c9 = Parms[9].mCos ;
   for (unsigned int x=0; x<=groupcount; x+=1)
   {
      double a0=atrig(s0, c0) ;
      double a1=atrig(s1, c1) ;
      double a2=atrig(s2, c2) ;
      double a3=atrig(s3, c3) ;
      double a4=atrig(s4, c4) ;
      double a5=atrig(s5, c5) ;
      double a6=atrig(s6, c6) ;
      double a7=atrig(s7, c7) ;
      double a8=atrig(s8, c8) ;
      double a9=atrig(s9, c9) ;
      s0 = Parms[10*x+10].mSin ;
      c0 = Parms[10*x+10].mCos ;
      s1 = Parms[10*x+11].mSin ;
      c1 = Parms[10*x+11].mCos ;
      s2 = Parms[10*x+12].mSin ;
      c2 = Parms[10*x+12].mCos ;
      s3 = Parms[10*x+13].mSin ;
      c3 = Parms[10*x+13].mCos ;
      s4 = Parms[10*x+14].mSin ;
      c4 = Parms[10*x+14].mCos ;
      s5 = Parms[10*x+15].mSin ;
      c5 = Parms[10*x+15].mCos ;
      s6 = Parms[10*x+16].mSin ;
      c6 = Parms[10*x+16].mCos ;
      s7 = Parms[10*x+17].mSin ;
      c7 = Parms[10*x+17].mCos ;
      s8 = Parms[10*x+18].mSin ;
      c8 = Parms[10*x+18].mCos ;
      s9 = Parms[10*x+19].mSin ;
      c9 = Parms[10*x+19].mCos ;
      Angles[10*x+0] = a0 ;
      Angles[10*x+1] = a1 ;
      Angles[10*x+2] = a2 ;
      Angles[10*x+3] = a3 ;
      Angles[10*x+4] = a4 ;
      Angles[10*x+5] = a5 ;
      Angles[10*x+6] = a6 ;
      Angles[10*x+7] = a7 ;
      Angles[10*x+8] = a8 ;
      Angles[10*x+9] = a9 ;
   } /* endfor */
}
