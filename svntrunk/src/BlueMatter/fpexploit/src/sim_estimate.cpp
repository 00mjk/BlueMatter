/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Simulate the Double Hummer estimation ops, and subsequenr recip
 */

#include <stdio.h>
#include <math.h>

int slope_table_rsqrt[2][32] = {
   {
0x7d1  , 0x778  , 0x725  , 0x6d8  , 0x691  , 0x64e  , 0x610  , 0x5d5  ,
0x59e  , 0x56a  , 0x53a  , 0x50c  , 0x4e0  , 0x4b8  , 0x491  , 0x46c  ,
0x449  , 0x428  , 0x409  , 0x7d6  , 0x79d  , 0x766  , 0x732  , 0x701  ,
0x6d1  , 0x6a4  , 0x679  , 0x64f  , 0x627  , 0x601  , 0x5dc  , 0x5b9
  },
  {
0x587  , 0x548  , 0x50d  , 0x4d7  , 0x4a4  , 0x475  , 0x449  , 0x420  ,
0x7f2  , 0x7a9  , 0x764  , 0x723  , 0x6e6  , 0x6ac  , 0x675  , 0x641  ,
0x610  , 0x5e1  , 0x5b5  , 0x58a  , 0x562  , 0x53b  , 0x517  , 0x4f4  ,
0x4d2  , 0x4b2  , 0x493  , 0x476  , 0x45a  , 0x43f  , 0x425  , 0x40c
}
  } ;

int slope_exponent_table_rsqrt[2][32] = {
   {
0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 ,
0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 , 0-2 ,
0-2 , 0-2 , 0-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 ,
-1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2
   },
   {
-1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 , -1-2 ,
-2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 ,
-2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 ,
-2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2 , -2-2
  }

   } ;
int offset_table_rsqrt[2][32] = {
   {
0xbe86 , 0xbba8 , 0xb8e6 , 0xb644 , 0xb3c5 , 0xb15a , 0xaf0d , 0xaccd ,
0xaaa7 , 0xa892 , 0xa69a , 0xa4ac , 0xa2c7 , 0xa105 , 0x9f45 , 0x9d92 ,
0x9bee , 0x9a5a , 0x98d6 , 0x9757 , 0x95e5 , 0x9478 , 0x9319 , 0x91c8 ,
0x9078 , 0x8f38 , 0x8e00 , 0x8cca , 0x8b9e , 0x8a7c , 0x895d , 0x884a
  }, {
0x86b9 , 0x84b1 , 0x82bc , 0x80e3 , 0xfe31 , 0xfacb , 0xf786 , 0xf467 ,
0xf15b , 0xee6f , 0xeb9a , 0xe8df , 0xe640 , 0xe3b4 , 0xe13b , 0xded8 ,
0xdc8c , 0xda4c , 0xd826 , 0xd602 , 0xd3fa , 0xd1f5 , 0xd00f , 0xce2d ,
0xcc51 , 0xca89 , 0xc8c8 , 0xc71c , 0xc578 , 0xc3dc , 0xc249 , 0xc0bf

  }
   } ;

int offset_exponent_table_rsqrt[2][32] = {
   {
-0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 ,
-0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 ,
-0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 ,
-0 , -0 , -0 , -0 , -0 , -0 , -0 , -0
   }, {
-0 , -0 , -0 , -0 , -1 , -1 , -1 , -1 ,
-1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ,
-1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ,
-1 , -1 , -1 , -1 , -1 , -1 , -1 , -1
  }
   } ;

int slope_table_recip[32] = {
0xf83 , 0xe9a , 0xdc4 , 0xd00 , 0xc4c , 0xba7 , 0xb0e , 0xa80 ,
0x9fd , 0x983 , 0x912 , 0x8a8 , 0x846 , 0xfd4 , 0xf28 , 0xe86 ,
0xdee , 0xd5f , 0xcd9 , 0xc5b , 0xbe3 , 0xb73 , 0xb08 , 0xaa3 ,
0xa44 , 0x9e9 , 0x993 , 0x941 , 0x8f3 , 0x8aa , 0x863 , 0x820

   } ;
int slope_exponent_table_recip[32] = {
-1 , -1 , -1 , -1 , -1 , -1 , -1 , -1 ,
-1 , -1 , -1 , -1 , -1 , -2 , -2 , -2 ,
-2 , -2 , -2 , -2 , -2 , -2 , -2 , -2 ,
-2 , -2 , -2 , -2 , -2 , -2 , -2 , -2

   } ;

int offset_table_recip[32] = {
 0xfc142 , 0xf4920 , 0xed773 , 0xe6c45 , 0xe0705 , 0xda7a2 , 0xd4ccc , 0xcf646 ,
 0xca466 , 0xc563e , 0xc0c15 , 0xbc4dd , 0xb817c , 0xb40cc , 0xb02fd , 0xac782 ,
 0xa8e82 , 0xa57c4 , 0xa236b , 0x9f137 , 0x9c077 , 0x99217 , 0x964f4 , 0x9398d ,
 0x90ffd , 0x8e777 , 0x8c07f , 0x89ab3 , 0x87622 , 0x85357 , 0x830f3 , 0x80ff8
   } ;


class doublemap
{
  public:
  class uintpair
  {
     public:
    unsigned int m_hi ;
    unsigned int m_lo ;
  } ;
   union {
      double m_d ;
      uintpair m_u ;
      } m_value ;
  doublemap(double X) { m_value.m_d = X ; } ;
  doublemap(
    unsigned int Xsign ,   // 0 for positive, 1 for negative
    unsigned int Xexponent ,
    unsigned int Xsignificand_hi ,  // The 0x00100000 bit had better be set, to get the right answer
    unsigned int Xsignificand_lo
    ) {
       m_value.m_u.m_hi = ( ( Xsign << 31 )                & 0x80000000 )
                        | ( ( (Xexponent + 1023 )  << 20 ) & 0x7ff00000 )
                        | ( Xsignificand_hi                & 0x000fffff ) ;
       m_value.m_u.m_lo = Xsignificand_lo ;
   } ;
  double get_value(void) const { return m_value.m_d ; } ;

  unsigned int hiword(void) const { return m_value.m_u.m_hi ; } ;
  unsigned int loword(void) const { return m_value.m_u.m_lo ; } ;

  unsigned int sign_bit(void) const { return hiword() & 0x80000000 ; } ;
  unsigned int exponent_bits(void) const { return hiword() & 0x7ff00000 ; } ;
  unsigned int significand_hi_bits(void) const { return hiword() & 0x000fffff ; } ;
  unsigned int significand_lo_bits(void) const { return loword() ; } ;

  int exponent(void) const { return ( exponent_bits() >> 20 ) - 1023 ; } ;
  unsigned int significand_hi(void) const { return significand_hi_bits() | 0x00100000 ; } ;
  unsigned int significand_lo(void) const { return significand_lo_bits() ; } ;
  bool is_negative(void) const { return  0 != sign_bit() ; } ;
} ;

double estimate_reciprocal_square_root(double X)
{
   doublemap in_map(X) ;
   int in_exponent = in_map.exponent() ;
   int in_exponent_lobit = in_exponent & 1 ;
   int in_exponent_half = in_exponent >> 1 ;
   unsigned int in_index = ( in_map.significand_hi() >> 15 ) & 0x1f ; // in_index should be in (0,31)
   doublemap mid_map(0,in_exponent_lobit,in_map.significand_hi(),in_map.significand_lo()) ;  // mid_map should be in (1,4)

   int slope_significand = slope_table_rsqrt[in_exponent_lobit][in_index] ;
   int slope_exponent = slope_exponent_table_rsqrt[in_exponent_lobit][in_index] ;

   int offset_significand = offset_table_rsqrt[in_exponent_lobit][in_index] ;
   int offset_exponent    = offset_exponent_table_rsqrt[in_exponent_lobit][in_index] ;

   doublemap slope(1,slope_exponent,slope_significand << 10,0) ;
   doublemap offset(0,offset_exponent,offset_significand << 5, 0) ;

   doublemap mid_result(mid_map.get_value() * slope.get_value() + offset.get_value() ) ;

   int mid_exponent = mid_result.exponent() ;

   int out_exponent = mid_exponent - in_exponent_half ;
   doublemap out_result(0, out_exponent,mid_result.significand_hi(),mid_result.significand_lo()) ;
   double result = out_result.get_value() ;

//   printf("in-exponent %d in-index %d\n",in_exponent, in_index) ;
//   printf("Calculating %0.17e * %0.17e + %0.17e\n",mid_map.get_value(),slope.get_value(),offset.get_value()) ;
//   printf("Giving %0.17e\n",mid_result.get_value()) ;

//   double f = 1.0 / sqrt(X) ;
//   double ff = -0.5 * ( 1.0/sqrt(X*X*X)) ;
//   double fo = f - ( ff * X ) ;

//   printf("%0.6e %0.6e %0.6e %0.6e %0.6e %0.6e %0.6e %0.6e\n",X,ff,slope.get_value(),fo,offset.get_value(),f,out_result.get_value(),X*result*result) ;
   return result ;
}

double estimate_reciprocal(double X)
{
   doublemap in_map(X) ;
   int in_exponent = in_map.exponent() ;
   int in_sign = in_map.sign_bit() ;
   unsigned int in_index = ( in_map.significand_hi() >> 15 ) & 0x1f ; // in_index should be in (0,31)
   doublemap mid_map(0,0,in_map.significand_hi(),in_map.significand_lo()) ;  // mid_map should be in (1,2)

   int slope_significand = slope_table_recip[in_index] ;
   int slope_exponent = slope_exponent_table_recip[in_index] ;

   int offset_significand = offset_table_recip[in_index] ;

   doublemap slope(1,slope_exponent,slope_significand << 9,0) ;
   doublemap offset(0,0,offset_significand << 1, 0) ;

   doublemap mid_result(mid_map.get_value() * slope.get_value() + offset.get_value() ) ;
   int mid_exponent = mid_result.exponent() ;

   int out_exponent = mid_exponent - in_exponent ;
   doublemap out_result(in_sign, out_exponent,mid_result.significand_hi(),mid_result.significand_lo()) ;
   double result = out_result.get_value() ;

//   printf("in-exponent %d in-index %d\n",in_exponent, in_index) ;
//   printf("Calculating %0.17e * %0.17e + %0.17e\n",mid_map.get_value(),slope.get_value(),offset.get_value()) ;
//   printf("Giving %0.17e\n",mid_result.get_value()) ;

   double f = 1.0 / X ;
   double ff = -1.0 / (X*X) ;
   double fo = f - ( ff * X ) ;

   printf("%0.6e %0.6e %0.6e %0.6e %0.6e %0.6e %0.6e %0.6e\n",X,ff,slope.get_value(),fo,offset.get_value(),f,out_result.get_value(),X*result) ;
   return result ;
}

int mainx(void)
{
   double a=1.0 ;
   for (int b=0;b<=1500 ;b+=1 )
   {
      (void) estimate_reciprocal(a) ;
      a += 0.01 ;
   } /* endfor */
   return 1;
}

int main(int argc, const char** argv)
{
   if (argc >= 2)
   {
      char* dummy0 ;
      double a = strtod(argv[1],&dummy0) ;
      double re = estimate_reciprocal(a) ;
      printf("Parameter %0.17e recip-estimate %0.17e should-be-1 %0.17e\n", a, re, a*re) ;
      return 0 ;
   } else {
      printf("%s 2.0 : simulate Double Hummer reciprocal estimate"
             "\n", argv[0]) ;
     return 1 ;
   } /* endif */
}
