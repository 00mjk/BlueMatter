%
% Basic block rescheduler to generate double hummer code
%





% Read a stream into a character list

stream_list(S,[]) :- at_end_of_stream(S), !.
stream_list(S,[H|T]) :- get_char(S,H), !, stream_list(S,T).

% Write a list, one element per line
write_l([]) :- !.
write_l([H|T]) :- write(H), write('\n'), write_l(T).

write_list(X) :- length(X,L), !, write('Length '), write(L), write('\n'), write_l(X).
write_list(X) :- write('Non-list\n'), write(X), write('\n').

write_list_list([]).
write_list_list([H|T]) :- write_list(H),  write('\n'), write_list_list(T).

nwrite_list_list(_).

write_list_indent([]).
write_list_indent([H|T]) :- length(H,L), write('Length '), write(L), write('\n'),write_indent(0,H),  write('\n'), write_list_indent(T).

% write_file(F) :- file_indep(F,P), write_list(P).

% Read a file into a character list ...
file_list(F,L) :- open(F,read,S), stream_list(S,L), close(S).


indent(N) :- N > 0, !, write(' '), N1 is N - 1, indent(N1).
indent(_).

write_indent(_,[]).

write_indent(N,[meta(X,1)|T]) :- !,
  indent(N), write(meta(X,1)), write('\n'),
  N1 is N + 1, write_indent(N1,T).

write_indent(N,[meta(X,-1)|T]) :- !,
  N1 is N - 1,
  indent(N1), write(meta(X,-1)), write('\n'),
  write_indent(N1,T).

write_indent(N,[meta(X,0)|T]) :- !,
  N1 is N - 1,
  indent(N1), write(meta(X,0)), write('\n'),
  write_indent(N,T).

write_indent(N,[H|T]) :-
  indent(N), write(H), write('\n'),
  write_indent(N,T).





% Predicates which take a file through various rescheduling partials
file_pgm(F,P) :- file_list(F,L), in_pgm(P,L,[]).
file_pgm_d(F,P) :- file_list(F,L), in_pgm_d(P,L,[]).

file_spgm(F,S) :- file_pgm(F,P), pgm_spgm(P,S).
write_spgm(F) :- file_spgm(F,S), write_list(S).

file_apgm(F,A) :- file_spgm(F,S), spgm_apgm(S,A,[]).
write_apgm(F) :- file_apgm(F,A), write_list(A).

file_sdep(F,D,E) :- file_apgm(F,S), pgm_dep(S,D,[],0,[],E).
write_sdep(F) :- file_sdep(F,D,E), write_list(D), write_list(E).

file_used(F,U,E) :- file_sdep(F,D,E), dep_used(D,U).
write_used(F) :- file_used(F,U,E), write_list(U), write_list(E).

file_useda(F,A,E,S) :- file_used(F,U,E),!,annotate_temps(U,A0,S),!, annotate_temps_only(A0,A1,S),!, annotate_regcount(A1,A,[],[]),!.

write_useda(F) :- file_useda(F,A,E,S),
                  write('Substitutions\n'), write_list(E),
                  write('Sources\n'), write_list(S),
                  write('Annotated ops\n'), write_list(A)
                  .

%file_indep(F,I) :- file_sdep(F,D), dep_indep(D,I).
%write_indep(F) :- file_indep(F,I), write_list_list(I).

file_i(F,I,Stores,Constants,Externals) :- file_sdep(F,S,Externals), d_i(S,I,Stores,Constants).
write_i(F) :- file_i(F,I,S,K,E), write_list_list(I), write_list(S), write_list(K), write_list(E).
file_m(F,M,C,S,K,Invar) :- file_i(F,I,S,K,_), i_m_vector(I,M0,C), drop_invariants_all(M0,M,C,Invar).

write_m(F) :- file_m(F,M,C,_,_,_), write_list_list(C), write_list_list(M).
%file_inevitable(F,A,C,S,K,I) :- file_m(F,M,C,S,K,I), matchstream_inevitable_all(M,A).
%write_inevitable(F) :- file_inevitable(F,A,C,_,_,_), nwrite_list_list(C), write_list(A).
%file_si(F,X,C,S,K,I) :- file_inevitable(F,X0,C,S,K,I), schedule_inevitable_all(X0,X).
%write_si(F) :- file_si(F,X,C,_,_,_), nwrite_list_list(C), write_list_list(X).
%file_sia(F,A,C,S,K,I) :- file_si(F,X,C,S,K,I), !, c_alc_all(X,A).
%write_sia(F) :- file_sia(F,A,C,S,K,I), write_list_list(C), write_list_list(A), write_list(S), write_list(K), write_list_list(I).
file_s(F,X,C,T) :- file_m(F,M,C,_,_,_),!, temp0(Temp0), s_schedule(M,X,T,Temp0).
write_s(F) :- file_s(F,X,C,T), write_list_list(C), write_list_list(X), write(T).
%file_matchstreams(F,S) :- file_indep(F,I),        matchup_streams(I,[],S).
%write_matchstreams(F) :- file_matchstreams(F,S), write_list_list(S).
%write_diag_matchstreams(F) :- file_matchstreams(F,S), write_list_list(S), diag_match_stream(S).
%file_s_schedule(F,X,T) :- file_matchstreams(F,S),!, temp0(Temp0), s_schedule(S,X,T,Temp0).
%write_s_schedule(F) :- file_s_schedule(F,X,T), write_list_list(X), write(T).

%file_scalarise(F,S) :- file_s_schedule(F,X,_), !, scalarise(X,S).
%write_scalarise(F) :- file_scalarise(F,S), write_list_list(S).


file_mi(F,A,C,S,K,I) :- file_m(F,M,C,S,K,I), m_i_all(M,A).
write_mi(F) :- file_mi(F,A,_,_,_,_), write_list_indent(A).




% Parser for (slice of) compiler-generated assembly language






% A program is a sequence of lines; and a debug version of the parser to show how far we get in case of not completing.
in_pgm([]) --> [] .
in_pgm(T)  --> in_dummy, in_pgm(T).
in_pgm([H|T]) --> in_line(H), { ! } , in_pgm(T).

in_pgm_d([]) --> [] .
in_pgm_d(T)  --> in_dummy, in_pgm_d(T).
in_pgm_d([H|T]) --> in_line_d(H), { write(H), write('\n'), ! } , in_pgm_d(T).

% A dummy line begins with a '#'
in_dummy --> ['#'], noneols, ['\n'].


% A line can be straight from the assembly listing
in_line(op(Opcode,Operand)) --> skippast('|'),
                                [' '],
                                hex_number(_),    % code address
                                [' '],
                                nonspaces(_     ),
                                spaces,
                                hex_number(_  ),    % binary machine instruction
                                spaces,
                                number(_ ),        % cycle count estimate
                                spaces,
                                opcode(Opcode),     % alternate view of opcode
                                spaces,
                                operand(Operand),
                                ['\n'].
% A line can be an opcode, an operand, and an end-of-line mark
in_line(op(Opcode,Operand)) --> opcode(Opcode), spaces, operand(Operand), ['\n'].

% or in this format ..
in_line(op(Opcode,Operand)) --> maybe_spaces, unsigned_number(_), [':'], spaces, opcode(Opcode), spaces, operand(Operand), ['\n'].

in_line_d(op(Opcode,Operand)) --> skippast('|'),
                                [' '],
                                hex_number(_),    % code address
                                [' '],
                                nonspaces(AOP),
                                { write(AOP) },
                                spaces,
                                hex_number(MOP),    % binary machine instruction
                                { write(MOP) },
                                spaces,
                                number(CY),        % cycle count estimate
                                { write(CY) } ,
                                spaces,
                                opcode(Opcode),     % alternate view of opcode
                                { write(Opcode) } ,
                                spaces,
                                operand(Operand),
                                ['\n'].
% A line can be an opcode, an operand, and an end-of-line mark
in_line_d(op(Opcode,Operand)) --> opcode(Opcode), spaces, operand(Operand), ['\n'].

% or in this format ..
in_line_d(op(Opcode,Operand)) --> maybe_spaces, unsigned_number(_), [':'], spaces, opcode(Opcode), spaces, operand(Operand), ['\n'].

% An opcode is a sequence of nonspace characters, and we represent it as an atom
opcode(N) --> nonspaces(L), { atom_chars(N,L) } .

skippast(X) --> [ X ].
skippast(X) --> [ _ ], skippast(X).


nonspacesl([H|T]) --> nonspacel(H), nonspacesl(T).
nonspacesl([]) --> [] .

nonspaces([H|T]) --> nonspace(H), nonspaces(T).
nonspaces([]) --> [] .

spaces --> [' '], maybe_spaces.
maybe_spaces --> [' '], maybe_spaces.
maybe_spaces --> [].

nonspace(X) --> [ X ], { X \== ' ' }.
nonspacel(X) --> [ X0 ], { X0 \== ' ', lower_upper(X,X0) }.

noneol --> [ X ], { X \== '\n' }.
noneols --> noneol, noneols.
noneols --> [] .


%  Simple operand parsing - 'accept any string of nonspaces' - available for debugging
%operand([H|T]) --> nonspace(H), operand(T).
%operand([],S,S).

% A binary operand has targets, an '=', and sources.
% Better operand parsing
operand(binary(Targets,Sources)) --> u_operand(Targets), [=], u_operand(Sources).
% Or, can be a register (like BA lr)
operand(binary([dummy],Sources)) --> u_operand(Sources).

% Targets/sources can be 1,2,3,4 or 6 registers, or an index specification.
u_operand([R]) --> register(R), maybe_fcr .
u_operand([R1,R2]) --> register(R1), [','], register(R2), maybe_fcr .
u_operand([R1,R2,R3]) --> register(R1), [','], register(R2), [','], register(R3), maybe_fcr .
u_operand([R1,R2,R3]) --> register(R1), ['-'], register(R3), maybe_fcr, { regtriple(R1, R2, R3) } .
u_operand([R1,R2,R3,R4]) --> register(R1), [','], register(R2), [','], register(R3), [','], register(R4), maybe_fcr.
u_operand([R1,R2,R3,R4,R5,R6]) --> register(R1), [','], register(R2), [','],
                                   register(R3), [','], register(R4), [','],
                                   register(R5), [','], register(R6), maybe_fcr.
u_operand([ix(R,k(X))]) --> ix_operand(R,X).
u_operand([ixx(R1,R2,k(X))]) --> ixx_operand(R1,R2,X).
% or a register and an integer
u_operand([R,k(X)]) --> register(R), [','], number(X), maybe_ca .
% or a register and 2 integers
u_operand([R,k(X1),k(X2)]) --> register(R), [','], number(X1), [','], number(X2), maybe_ca .
% or an integer
u_operand([k(X)]) --> number(X).
%% or 2 registers and an integer
%% u_operand([R1,R2,k(X)]) --> register(R1), [','], register(R2), [','], number(X).

% or a conditional branch
u_operand([R]) --> label, [','], register(R), [','], skippast(',').

label --> [ 'C', 'L', '.' ], number(_).
% An index specification looks like '(register,number)', and may have junk before it.
ix_operand(R,X) --> ['('], register(R), [','], number(X), [')'] .
ix_operand(R,X) --> nonspace(_), ix_operand(R,X) .

% An indexx specification looks like '(register,number)', and may have junk before it.
% It may also have a 'trap specification' before the ')'
ixx_operand(R1,R2,X) --> ['('], register(R1), [','], register(R2), [','], number(X), trapspec, [')'] .
ixx_operand(R1,R2,X) --> nonspace(_), ixx_operand(R1,R2,X) .

% A trapspec is like ',trap=32', and is optional.
trapspec --> [',',t,r,a,p,=], number(_).
trapspec --> [] .

% A register name looks like this
register(gr(X)) --> [g,r], number(X),maybe_prime.
register(fp(X)) --> [f,p], number(X),maybe_prime.
register(cr(X)) --> [c,r], number(X),maybe_prime.
register(lr) --> [l,r].

regtriple(fp(N0),fp(N1),fp(N2)) :- N1 is N0+1, N2 is N0+2.

% Sometimes we get a junk ',fcr' on the end.
maybe_fcr --> [',',f,c,r].
maybe_fcr --> [',','1',',',f,c,r].
maybe_fcr --> [] .

maybe_ca --> [',',c,a,'"'].
maybe_ca --> [] .

maybe_prime --> ['\''].
maybe_prime --> [] .

% A number looks like this, and is evaluated
number(X) --> ['-'], number(X0), { X is -X0 }.
number(X) --> ['0','x'], hex_number(X).
number(X) --> number(0,X).
number(N0,N) --> digit(D), { N1 is N0*10 + D }, number(N1,N).
number(N,N) --> [] .

unsigned_number(X) --> number(0,X).

digit(0) --> ['0']. digit(1) --> ['1']. digit(2) --> ['2']. digit(3) --> ['3']. digit(4) --> ['4'].
digit(5) --> ['5']. digit(6) --> ['6']. digit(7) --> ['7']. digit(8) --> ['8']. digit(9) --> ['9'].

hex_number(X) --> hex_number(0,X).
hex_number(N0,N) --> hex_digit(D), { N1 is N0*16 + D }, hex_number(N1,N).
hex_number(N,N) --> [] .

hex_digit(0) --> ['0']. hex_digit(1) --> ['1']. hex_digit(2) --> ['2']. hex_digit(3) --> ['3'].
hex_digit(4) --> ['4']. hex_digit(5) --> ['5']. hex_digit(6) --> ['6']. hex_digit(7) --> ['7'].
hex_digit(8) --> ['8']. hex_digit(9) --> ['9']. hex_digit(10) --> ['A']. hex_digit(11) --> ['B'].
hex_digit(12) --> ['C']. hex_digit(13) --> ['D']. hex_digit(14) --> ['E']. hex_digit(15) --> ['F'].


% Split out any instructions with multiple targets, to multiple instructions each with a single target
pgm_spgm([],[]).
pgm_spgm([op(Opcode,binary(Targets,Sources))|T0],P) :-
  pgm_spgm(T0,P0),!,
  expand_op(Opcode,Targets,Sources,P0,P)
  .


% Expand the multi-target ops, also rename/specialise ops where more than one operand is the same
% (Double Hummer ops are types of multi-target ops)
     % Double Hummer parallel store (assume 8-byte stores !)
expand_op(Opcode0,[ixx(Ra,Rb,k(0))],[Fp,Fs],P0,[
              op(Opcode,ixx(Ra,Rb,k(OffP)),[Fp]),
              op(Opcode,ixx(Ra,Rb,k(OffS)),[Fs])
                  |P0]) :- pstore_opcode(Opcode0,Opcode,OffP,OffS).
expand_op(Opcode0,[ix(Ra,k(0))],[Fp,Fs],P0,[
              op(Opcode,ix(Ra,k(OffP)),[Fp]),
              op(Opcode,ix(Ra,k(OffS)),[Fs])
                  |P0]) :- pstore_opcode(Opcode0,Opcode,OffP,OffS).
     % Double Hummer parallel load (assume 8-byte loads !)
expand_op(Opcode0,[Fp,Fs],[ixx(Ra,Rb,k(0))],P0,[
              op(Opcode,Fp,[ixx(Ra,Rb,k(OffP))]),
              op(Opcode,Fs,[ixx(Ra,Rb,k(OffS))])
                  |P0]) :- pload_opcode(Opcode0,Opcode,OffP,OffS).
expand_op(Opcode0,[Fp,Fs],[ix(Ra,k(0))],P0,[
              op(Opcode,Fp,[ix(Ra,k(OffP))]),
              op(Opcode,Fs,[ix(Ra,k(OffS))])
              |P0]) :- pload_opcode(Opcode0,Opcode,OffP,OffS).
     % Double Hummer computation   --- assume targets are not crossover sources, for now.
% Handle possibility of targets being crossover sources by building in a dummy 'move register' op
expand_op(Opcode,[Fp,Fs],[FpA,FsA],P0,[
              op(OpcodeP,fp(-1),[FpA]),
              op(OpcodeS,Fs,[FsA]),
              op(fmr,Fp,[fp(-1)])
                 | P0]) :-
              pri_sec(Opcode,OpcodeP,OpcodeS).

expand_op(Opcode,[Fp,Fs],[FpA,FsA,FpB,FsB],P0,[
              op(OpcodeP,fp(-1),Sp),
              op(OpcodeS,Fs,Ss),
              op(fmr,Fp,[fp(-1)])
                 | P0]) :-
              rebuild_matchop(Opcode,Opcode1,[FpA,FpB],Sp),
              rebuild_matchop(Opcode,Opcode1,[FsA,FsB],Ss),
              pri_sec(Opcode1,OpcodeP,OpcodeS).
expand_op(Opcode,[Fp,Fs],[FpA,FsA,FpB,FsB,FpC,FsC],P0,[
              op(OpcodeP,fp(-1),Sp),
              op(OpcodeS,Fs,Ss),
              op(fmr,Fp,[fp(-1)])
                 | P0]) :-
              rebuild_matchop(Opcode,Opcode1,[FpA,FpB,FpC],Sp),
              rebuild_matchop(Opcode,Opcode1,[FsA,FsB,FsC],Ss),
              pri_sec(Opcode1,OpcodeP,OpcodeS).

expand_op(Opcode0,[Target0],Sources0,P0,[op(Opcode0,Target0,Sources),op(Opcode1,Target1,Sources)|P0]) :-
  reexpress_sources(Target0,Sources0,Sources),
  double_store_call_second(Opcode0,Opcode1),
  second_half_target(Target0,Target1), !.

expand_op(Opcode0,[Target],Sources0,P0,[op(Opcode,Target,Sources)|P0]) :-
  reexpress_sources(Target,Sources0,Sources1),
  rebuild_matchop(Opcode0,Opcode1,Sources1,Sources),
  translate_opcode(Opcode1,Opcode),
%  write('expressed as '),write(op(Opcode,Target,Sources)), write('\n'), trace,
  !.

%expand_op(Opcode0,[Target],Sources0,P0,[op(Opcode0,Target,Sources0)|P0]) :- trace.
%expand_op(A,B,C,D,junk) :- trace, write(A), write(B), write(C), write(D).

double_store_call_second('STFL',secondhalf('STFL')).
second_half_target(ix(R,k(K0)),ix(R,k(K))) :- K is K0+4.

% Any index registers required for evaluation of the target are also sources ...
reexpress_sources(ix(gr(1),_),S,S) :- !.      % ... but not the stack pointer ...
reexpress_sources(ix(R,_),S0,[R|S0]) :- !.
reexpress_sources(ixx(gr(1),R2,_),S0,[R2|S0]) :- !.  % ... but not the stack pointer
reexpress_sources(ixx(R1,gr(1),_),S0,[R1|S0]) :- !.  % ... but not the stack pointer
reexpress_sources(ixx(R1,R2,_),S0,[R1,R2|S0]) :- !.

% Source memory may also imply source registers
reexpress_sources(_,[ix(gr(1),K)],[ix(gr(1),K)]) :-  !.
reexpress_sources(_,[ix(R,K)],[R,ix(R,K)]) :- !.
reexpress_sources(_,[ixx(gr(1),R,K)],[R,ixx(gr(1),R,K)]) :- !.
reexpress_sources(_,[ixx(R,gr(1),K)],[R,ixx(R,gr(1),K)]) :- !.
reexpress_sources(_,[ixx(R1,R2,K)],[R1,R2,ixx(R1,R2,K)]) :- !.

reexpress_sources(_,S,S).


% Parallel-to-serial opcode translation
% pstore_opcode(stfpdx,stfd,0,8).
% pload_opcode(lfpdx,lfd,0,8).

pstore_opcode('SFPL','STFL',0,8).
pload_opcode('LFPL','LFL',0,8).

% Here should follow expansions for the multi-target ops (lfdu, and so on); not handled at present.

rebuild_matchop(Opcode,unary(Opcode),[S,S],[S]) :- !.   % multiply --> square, add --> double, etc.
rebuild_matchop(Opcode,unary(Opcode),[S,S,S],[S]) :- !. % maf --> square-and-add-self (unlikely, but possible)
rebuild_matchop(Opcode,binary(Opcode),[A,S,S],[A,S]) :- !. % maf --> square-and-add (vector length)
rebuild_matchop(Opcode,binary12(Opcode),[S,S,A],[S,A]) :- !. % unlikely
rebuild_matchop(Opcode,binary12(Opcode),[S,A,S],[S,A]) :- commutative(Opcode), !. % unlikely
rebuild_matchop(Opcode,binary13(Opcode),[S,A,S],[S,A]) :- !. % unlikely
rebuild_matchop(Opcode,Opcode,Sources,Sources).  % Normal case, all feeds to an op differ

% Some opcodes ( particularly, loads and stores) we want to rename.
translate_opcode(lfsdx,lfd).
translate_opcode(lfdx,lfd).
translate_opcode(lfssx,lfs).
translate_opcode(stfsd,stfd).
translate_opcode(stfsdx,stfd).
translate_opcode(stfdx,stfd).
translate_opcode(X,X).

pri_sec(X, X, X) :- symmetric(X), !.
pri_sec(X, pri(X), sec(X)).

symmetric(_).

% Find cases where an integer register holds a constant, and the constant is used to index a load or store
% Substitute a modified form of the load  or store op
spgm_apgm([],[],_).       % Empty program remains empty ...
spgm_apgm([H0|T0],[H|T],L) :-
    translate_indexed_op(H0,H,L),!,
    spgm_apgm(T0,T,L).
spgm_apgm([H|T0],[H|T],L) :-
    sets_integer_register(H,R),!,
    spgm_apgm(T0,T,[reg(R,H)|L]).
spgm_apgm([H|T0],[H|T],L) :- spgm_apgm(T0,T,L).

% Not the whole truth, becuase there are circumstances where '0' is literal, i.e. doesn't mean gr(0)
%translate_indexed_op(
%  op(Opcode,ixx(Ra,Rb,k(K0)),Sources),
%  op(Opcode,ix(Ra,k(K)),Sources),
%  L ) :-
%    memberchk(reg(Rb,H),L),
%    H = op(addi,Rb,[k(K1)]),
%    K is K0+K1.
%
%translate_indexed_op(
%  op(Opcode,Target,[ixx(Ra,Rb,k(K0))]),
%  op(Opcode,Target,[ix(Ra,k(K))]),
%  L ) :-
%    memberchk(reg(Rb,H),L),
%    H = op(addi,Rb,[k(K1)]),
%    K is K0+K1.

translate_indexed_op(
  op(Opcode,ixx(Ra,Rb,k(K0)),Sources),
  op(Opcode,ix(Ra,k(K)),Sources),
  L ) :-
    memberchk(reg(Rb,H),L),
    H = op('LI',Rb,[k(K1)]),
    K is K0+K1.

translate_indexed_op(
  op(Opcode,Target,[ixx(Ra,Rb,k(K0))]),
  op(Opcode,Target,[ix(Ra,k(K))]),
  L ) :-
    memberchk(reg(Rb,H),L),
    H = op('LI',Rb,[k(K1)]),
    K is K0+K1.


sets_integer_register(op(_,Target,_),Target) :- is_integer_register(Target).
is_integer_register(gr(_)).




% Undo the register allocation, to produce a pure 'dependencies' representation
pgm_dep([],[],_,_,ExtNames,ExtNames) :- write_list(ExtNames).

% tjcw 2002-11-07 taken out, may need to go back in if we use for scheduling ...
%%  Load (or reload) of constant
%pgm_dep([op(Opcode,Target,[Source])|T0],Program,Renames,NextRename,ExtNames0,ExtNames) :-
%  is_copy_op(Opcode),
%  is_constant(Source),
%  is_temporary(Target),!,
%  write('kload '), write(op(Opcode,Target,[Source])), write('\n'),!,
%  rename_source(Source,RenamedSource,Renames,NextRename,NextRename1,ExtNames0,ExtNames1),
%  pgm_dep(T0,Program,[rename(Target,RenamedSource)|Renames],NextRename1,ExtNames1,ExtNames).

%  Store to spill, or reload from spill
pgm_dep([op(Opcode,Target,[Source])|T0],Program,Renames,NextRename0,ExtNames0,ExtNames) :-
  is_copy_op(Opcode),
  is_temporary(Source),
  is_temporary(Target),!,
  write('spill '), write(op(Opcode,Target,[Source])), write('\n'), !,
  rename_source(Source,RenamedSource,Renames,NextRename0,NextRename,ExtNames0,ExtNames1),
  pgm_dep(T0,Program,[rename(Target,RenamedSource)|Renames],NextRename,ExtNames1,ExtNames).
% Genuine computation
pgm_dep([op(Opcode,Target,Sources)|T0],[op(Opcode,RenamedTarget,RenamedSources)|Program],Renames0,NextRename0,ExtNames0,ExtNames) :-
  write('comp  '), write(op(Opcode,Target,Sources)), write('\n'),
  rename_sources(Sources,RenamedSources,Renames0,NextRename0,NextRename1,ExtNames0,ExtNames1),
  rename_target(Target,RenamedTarget,Renames0,Renames,NextRename1,NextRename,ExtNames1,ExtNames2),
  pgm_dep(T0,Program,Renames,NextRename,ExtNames2,ExtNames).


rename_source(Source,RenamedSource,Renames,N,N,ExtNames,ExtNames) :- memberchk(rename(Source,RenamedSource),Renames),!.
rename_source(Source,N0,_,N0,N,ExtNames,[rename(Source,N0)|ExtNames]) :- next_rename(N0,N), explain_rename(Source,N0).

rename_sources([],[],_,N,N,ExtNames,ExtNames).
rename_sources([H0|T0],[H|T],Renames,N0,N,ExtNames0,ExtNames) :-
  rename_source(H0,H,Renames,N0,N1,ExtNames0,ExtNames1),
  rename_sources(T0,T,Renames,N1,N,ExtNames1,ExtNames).

rename_target(Target,NextRename0,Renames0,[rename(Target,NextRename0)|Renames0],NextRename0,NextRename,ExtNames,ExtNames) :-
  is_temporary(Target),!,
  next_rename(NextRename0,NextRename), explain_rename(Target,NextRename0).
rename_target(Target,NextRename0,Renames0,Renames0,NextRename0,NextRename,ExtNames0,[rename(Target,NextRename0)|ExtNames0]) :-
  next_rename(NextRename0,NextRename), explain_rename(Target,NextRename0).

next_rename(N0,N) :- N is N0+1.

explain_rename(Name,Number) :-
  write('Renaming '), write(Number), write(' from '), write(Name), write('\n').

%is_copy_op(stfd).
%is_copy_op(stw).
%is_copy_op(lfd).
%is_copy_op(lfs).
%is_copy_op(lfdx).
%% is_copy_op(lwz).
%is_copy_op(fmr).   % but this is not likely to be generated for a basic block.
%is_copy_op(fsmr).   % but this is not likely to be generated for a basic block.
%
%% Extra copy ops for more involved code
%is_copy_op(mfspr).
%is_copy_op(mtspr).
%
%% Honorary copy op for getting the low half of a FPU double
%is_copy_op(stfdlo).

is_copy_op('STFL').
is_copy_op('ST4A').
is_copy_op('LFL').
is_copy_op('LFS').
is_copy_op('L4A').
is_copy_op('LRFL').   % but this is not likely to be generated for a basic block.
is_copy_op('LR').
%is_copy_op(fsmr).   % but this is not likely to be generated for a basic block.

% Extra copy ops for more involved code
is_copy_op('LFLR').
is_copy_op('LCTR').
is_copy_op('LLR').

% Honorary copy op for getting the low half of a FPU double
is_copy_op(secondhalf('STFL')).

is_temporary(fp(_)).
is_temporary(ix(gr(1),_)).
is_temporary(gr(_)).

is_constant(ix(gr(X),_)) :- X \== 1.
is_constant(ixx(_,_,_)).





% By now, we should have a set of instructions which are really a set of disjoint sets of instructions.
% Decompose the set to find its independent subsets.
d_i(D0,I,S,[]) :-
  extract_stores(D0,D1,S),          % Take out the stores, leave the arithmetic instructions and the loads
  find_productions(D1,D1,I)
  .

% From a map, find the things which are not consumed, and find how to produce them.
find_productions([],_,[]).
find_productions([H0|T0],M,T) :- op_produces_any(H0,M), !, find_productions(T0,M,T). % this map element is somethings tail
find_productions([H0|T0],M,[P|T]) :- production(H0,M,[],P), !,find_productions(T0,M,T). % this map element is a head.

op_produces_any(op(_,Target,_),Ops) :- produces_any(Target,Ops).

produces_any(Target,Map) :-
  member(op(_,_,Sources),Map),
  memberchk(Target,Sources).


% Find the map which produces a given target
production(H,M,P0,[H|P]) :-
  sources_of(H,S),
  production_list(S,M,P0,P).

production_list([],_,P,P).
production_list([H0|T0],M,P0,P) :-
  produced_already(H0,P0), !,
  production_list(T0,M,P0,P).

production_list([H0|T0],M,P0,P) :-
  find_producer(H0,M,I),!,
  production(I,M,P0,P1),
  production_list(T0,M,P1,P).

production_list([_|T0],M,P0,P) :-
  production_list(T0,M,P0,P).

produced_already(Target,[H|_]) :- op_produces(Target,H).
produced_already(Target,[_|T]) :- produced_already(Target,T).

find_producer(Source,[H|_],H) :- op_produces(Source,H).
find_producer(Source,[_|T],Op) :- !,find_producer(Source,T,Op).

op_produces(Target,op(_,Target,_)).

sources_of(op(_,_,Sources),Sources).

sources_of_list([],[]).
sources_of_list([op(_,_,S0)|T],S) :-
  sources_of_list(T,S1),
  union(S0,S1,S).

targets_of_list([],[]).
targets_of_list([op(_,Target,_)|T0],[Target|T]) :- targets_of_list(T0,T).








extract_stores([],[],[]).
extract_stores([H0|T0],T,[H0|S]) :- is_store(H0),!, extract_stores(T0,T,S).
extract_stores([H|T0],[H|T],S) :- extract_stores(T0,T,S).


dummy_constants([],[],[]).
dummy_constants([op(Opcode,Target,Sources)|T0],
  T
  ,[op(Opcode,Target,Sources)|K]) :-
  is_load(op(Opcode,Target,Sources)), !, dummy_constants(T0,T,K).
dummy_constants([H0|T0],[H0|T],K) :- dummy_constants(T0,T,K).

% is_load(op(lfd,_,_)).
% is_load(op(lfdx,_,_)).
% is_load(op(lfs,_,_)).
% is_load(op(lwz,_,_)).
% is_load(op(lhz,_,_)).

% is_store(op(stfd,_,_)).
% is_store(op(stfdx,_,_)).



is_load(op('LFD',_,_)).
is_load(op('LFS',_,_)).
is_load(op('L4A',_,_)).
is_load(op('L2A',_,_)).

is_store(op('STFL',_,_)).
is_store(op(secondhalf('STFL'),_,_)). % 'honorary' one

is_branch(op('BA',_,_)).
is_branch(op('BT',_,_)).
is_branch(op('BF',_,_)).


% Now we have a set of lists of instructions. Some of these are expected to be copies of each other with substitutions of variables;
% match up the copies and extract the substitutions.
% The copies are not necessarily in the same order, but the heads must match and looking from the head down is a good
% way to pick up constraints fast.

% For each, return a sample of each copy, and the 'matchup' (constraint) vector which matches the copies.
i_m_vector(Streams,Matched,Matchvector) :-
  i_m(Streams,[],Matched,[],Constraint),
  produce_matchlist_all(Constraint,Matchvector).

produce_matchlist_all([],[]).
produce_matchlist_all([H0|T0],[H|T]) :-  produce_matchlist(H0,H), produce_matchlist_all(T0,T).

% i_m(Streams-to-match,Matched-so-far,Matched-result,Constraint-so-far,Constraint-result)
i_m([],S,S,C,C).
i_m([H|T],S0,S,C0,C) :-
  i_m(T,S0,S1,C0,C1),!,
%  write(S1),
  i_m_any(H,S1,S,C1,C).

i_m_any(A,[H|T],[H|T],[C0|Tc],[[C|C0]|Tc]) :- i_matches(A,H,C), !.  % Whole stream matches
i_m_any(A,[H|T],[H|T],[Ch|Tc0],[Ch|Tc]) :- i_m_any(A,T,T,Tc0,Tc), !. % Matches another stream
i_m_any(A,L0,[A|L0],C,[[]|C]). % A new stream with no constraints

% i_m_any(A,[],[H]) :- construct_stream(A,H).

%i_matches([H0|T0],[H1|T1],[H|T]) :-
%  length(T0,A), length(T1,A),              % Lengths of lists must match ... quick duckout for nonmatchers
%  instruction_matches(H0,H1,H,T0,T1,[],C0),      % Top instuction must match, and gives us our first constraint
%  i_matches_rest(T0,T1,T,C0,_).


i_matches([H0|T0],[H1|T1],C) :-
  length(T0,A), length(T1,A),              % Lengths of lists must match ... quick duckout for nonmatchers
  instruction_matches(H0,H1,T0,T1,C0),      % Top instuction must match, and gives us our first constraint
  i_matches_rest(T0,T1,C0,C).              % Rest of stream must match, too

instruction_matches(op(Opcode,T0,S0),op(Opcode,T1,S1),Rest0,Rest1,C) :-
  commutative_operands(Opcode,S0,S0C),
  consistent_operands(S0C,S1,Rest0,Rest1,[match(T1,T0)],C).

i_matches_rest([],[],C,C).                   % Empty list matches, no constraints
i_matches_rest(L0,[op(Opcode,Target,Sources)|M],C0,C) :-
  memberchk(match(Target,Target0),C0),       % Should already have the mapping for the target
  select(op(Opcode,Target0,Sources0),L0,L1), % which should let us pull out the op which produces it
  commutative_operands(Opcode,Sources0,Sources0C), % can run either way if commutative
  consistent_operands(Sources0C,Sources,L1,M,C0,C1), % verify consistency of operands
  i_matches_rest(L1,M,C1,C).                 % and match up the rest


commutative_operands(_,X,X).         % All opcodes work in 'forwards' order
commutative_operands(K,S0,S) :-
  commutative(K),
  commutation(S0,S).

commutative(fmsub).
commutative(fmul).
commutative(fnmsub).
commutative(fadd).
commutative(fmadd).
commutative(fnmadd).

commutation([A,B],[B,A]).
commutation([A,B,C],[A,C,B]).


% Check if operands are consistent with constraints, adding new constraints as needed
consistent_operands([],[],_,_,C,C).                 % No (more) operands, consistent
consistent_operands([H0|T0],[H1|T1],Rest0,Rest1,C0,C) :-
  consistent_operand(H0,H1,Rest0,Rest1,C0,C1),
  consistent_operands(T0,T1,Rest0,Rest1,C1,C).

% Operands are consistent if already listed as such in the constraints
consistent_operand(A,U,_,_,C,C) :- member(match(U,A),C), !.
% ... are not consistent if one of them is listed and the other isn't
consistent_operand(_,U,_,_,C,C) :- member(match(U,_),C), !, fail.
consistent_operand(A,_,_,_,C,C) :- member(match(_,A),C), !, fail.
% Or, if not listed and the same opcode generates both, by generating a new constraint.
consistent_operand(A,U,RestA,RestU,C0,[match(U,A)|C0]) :-
  memberchk(op(Opcode,A,_),RestA), memberchk(op(Opcode,U,_),RestU), !.
% If one is not generated (i.e. is the result of a load we have stripped), then fail if the other is generated
consistent_operand(A,_,RestA,_,C,C) :- memberchk(op(_,A,_),RestA), !, fail.
consistent_operand(_,U,_,RestU,C,C) :- memberchk(op(_,U,_),RestU), !, fail.
% If neither is generated (i.e. both are the result of loads we have stripped), then OK with no more constraints
%consistent_operand(_,_,_,_,C,C).
% If neither is generated, we infer that they are the sources of loads and that they match
consistent_operand(A,U,_,_,C0,[match(U,A)|C0]).

% Targets are consistent if already listed as such in the constraints
consistent_target(A,U,C,C) :- member(match(U,A),C).
% Or if neither listed (i.e. being introduced as the targets).
consistent_target(A,U,[],[match(U,A)]).






% Drop invariants from the stream
drop_invariants_all([],[],_,[]).
drop_invariants_all([H0|T0],[H|T],[Hv|Tv],[Hi|Ti]) :-
  drop_invariants(H0,H,Hv,Hi),
  drop_invariants_all(T0,T,Tv,Ti).

drop_invariants([],[],_,[]).
drop_invariants([H|T0],T,V,[H|I]) :- is_invariant(H,V) ,!, drop_invariants(T0,T,V,I).
drop_invariants([H|T0],[H|T],V,I) :- drop_invariants(T0,T,V,I).

is_invariant(op(_,Target,_),V) :-
  memberchk(vector(Target,L),V),
  represents_invariant(Target,L).

represents_invariant_1(_,[]).
represents_invariant_1(A,[A|T]) :- represents_invariant_1(A,T).

represents_invariant(A,[A,A|T]) :- represents_invariant_1(A,T).



% Here is the register-minimising instruction scheduler

m_i_all([],[]).
m_i_all([H0|T0],[H|T]) :-
  transform_simple(H0,H1),
  ancestry_map(H1,A), write('\nAncestry '), write_list(A), write('---\n'),
  c_alc(H1,Alloc1), write_list(Alloc1),
  m_i(H1,H2,H1,A),
  mserialise(H2,[],H),
  verify_schedule(H),
  m_i_all(T0,T).


% Transform Opcode form to op(simple(...)), for annotation with sources
transform_simple([],[]).
transform_simple([op(Opcode,Target,Sources0)|T0],[op(simple(Opcode,Target,Sources0),Target,Sources)|T]):-
        sources_if_targets(Sources0,Sources,T0),
        transform_simple(T0,T).

sources_if_targets([],[],_).
sources_if_targets([H|T0],[H|T],L) :- memberchk(op(_,H,_),L),!,sources_if_targets(T0,T,L).
sources_if_targets([_|T0],T,L) :- sources_if_targets(T0,T,L).
% Pick out items which can be traced back unshared to loads.
m_i_s(L0,L,All,A) :-
  m_i(L0,L,All,A).
%  i_pick_solesources(L1,L,All,A).

spypoint.
% maybe_trace([group(_,_)]) :- trace, fail.
% maybe_trace([op(_,24,_)|_]) :- spypoint, fail.
maybe_trace(_).


% Serialise a structured op list from the partial scheduler

% This produces a human-readable representation of a schedule list, to
% help with visualising/understanding what the schduler is doing.



serialise([],S,S).
serialise([H0|T0],S0,S) :-
  serialise_h(H0,S0,S1),
  serialise(T0,S1,S).

serialise_h(op(alg(Q,L),Target,Sources),S0,S) :- !
       ,serialise_l(L,S1)
       ,length(L,A)
       ,append([meta(alg(A,Q,Target,Sources),1)|S1],[meta(endalg(A,Q,Target,Sources),-1)|S0],S).
serialise_h(op(seq(TempCount,L),Target,Sources),S0,S) :- !
       ,serialise_l(L,S1)
       , append([meta(seq(TempCount,Target,Sources),1)|S1],[meta(endseq(TempCount,Target,Sources),-1)|S0],S).
serialise_h(op(solesource(X),Target,Sources),S0,S) :- !
       , serialise_h(X,[],S1)
       , append([meta(sol(Target,Sources),1)|S1],[meta(endsol(Target,Sources),-1)|S0],S).
serialise_h(X,S0,[X|S0]).

serialise_l([],[]).
serialise_l([H|T],S) :- serialise_h(H,[],S0), serialise_l(T,S1), append(S0,S1,S).

% serialise for machine readability
mserialise([],S,S).
mserialise([H0|T0],S0,S) :-
  mserialise_h(H0,S0,S1),
  mserialise(T0,S1,S).

mserialise_h(op(alg(_,L),_,_),S0,S) :- !
       ,mserialise_l(L,S1)
       ,append(S1,S0,S).
mserialise_h(op(seq(_,L),_,_),S0,S) :- !
       ,mserialise_l(L,S1)
       , append(S1,S0,S).

mserialise_h(op(solesource(X),_,_),S0,S) :- !
       , mserialise_h(X,[],S1)
       , append(S1,S0,S).

mserialise_h(X,S0,[X|S0]).

mserialise_l([],[]).
mserialise_l([H|T],S) :- mserialise_h(H,[],S0), mserialise_l(T,S1), append(S0,S1,S).



% Pick out items which can be traced back to loaded data with no shared computations



% Given a list of instructions, apply scheduling techniques to schedule them
% 1) Separate out 'nosource' groups, i.e. groups to schedule independently with no dependencies
% 2) Separate out 'solesource' groups, i.e. groups to schedule independently with a single dependency

m_i([],[],_,_).



m_i([H0|T0],[S|T],All,A) :-
  ancestors_nonancestors(H0,T0,Ancestors,T1,A),
  only_sources_ancestors(All,H0,Ancestors,A), !,
  m_i_s(Ancestors,G,[H0|Ancestors],A),        % Apply recursively
  isch(H0,G,S),
  !,m_i(T1,T,All,A),!.

m_i([H0|T0],[op(solesource(S),Target,[Sole])|T],All,Ancestry) :-
  solesource_nonsolesource(All,H0,T0,SoleAncestors,Rest,Ancestry,Sole),!,
  target_is(H0,Target),
  write('\nFound sole source  ')
  , write(H0)
  , write(' ---> '), write(Sole)
  , write('---\n')
  ,
  m_i_s(SoleAncestors,G,[H0|SoleAncestors],Ancestry),
  isch(H0,G,S),
  !,m_i(Rest,T,All,Ancestry)
  .


m_i([H0|T0],[H0|T],All,A) :- !,m_i(T0,T,All,A),!.


% A is a sole source of B (in map Map with ancestry Ancestry), partitioning Map into SoleAncestors and Rest

% A is a sole source of B if ...
% A is an ancestor of B, and
%    for all C, either
%      B is an ancestor of C, or
%      C is an ancestor of B and A is an ancestor of C, or
%      for all D such that D is an ancestor of B and D is not an ancestor of A,
%         D is not a source of C, or
%      C is B



solesource_nonsolesource(All,op(_,B,_),Map,Ancestors,Rest,Ancestry,A) :-
  memberchk(ancestors(B,AncB),Ancestry),
  member(A,AncB),
  cannot_disprove_solesource(All,B,Map,Ancestry,A),
  !,
  memberchk(ancestors(A,AncA),Ancestry),
  setdiff(AncB,[A|AncA],InGroup),
  partition(Map,InGroup,Ancestors,Rest)
  .

reversemember(X,[_|T]) :- reversemember(X,T).
reversemember(X,[X|_]).

cannot_disprove_solesource(All,B,Map,Ancestry,A) :- can_disprove_solesource(All,B,Map,Ancestry,A), !, fail.
cannot_disprove_solesource(_,_,_,_,_).

% We'll try to find a counterexample C to disprove the hypothesis that A is an ancestor of B
%can_disprove_solesource(All,B,Map,Ancestry,A) :-
can_disprove_solesource(All,B,Map,Ancestry,A) :-
  member(ancestors(A,AncA),Ancestry),
  member(ancestors(B,AncB),Ancestry),
  member(ancestors(C,AncC),Ancestry),
  C \== A,
  nonmember(C, AncA),
  is_counterexample(B,Map,A,C,AncB,AncC,AncA,All), !
  .

is_counterexample(B,Map,A,C,AncB,AncC,AncA,_  ) :- is_goodexample(B,Map,A,C,AncB,AncC,AncA), !, fail.
is_counterexample(_,_  ,_,C,AncB,_   ,_   ,_  ) :- memberchk(C,AncB).
is_counterexample(_,_  ,_,C,AncB,_   ,AncA,All) :-
  memberchk(op(_,C,SourcesC),All),
  member(D,AncB),
  nonmember(D,AncA),
  memberchk(D,SourcesC)
  .



% is_goodexample(B,Map,A,C,AncB,AncC,AncA)
% C is B
is_goodexample(X,_,_,X,_,_,_).
% B is an ancestor of C
is_goodexample(B,_,_,_,_,AncC,_) :- memberchk(B,AncC).
% C is an ancestor of B and A is an ancestor of C
is_goodexample(_,_  ,A,C,AncB,AncC,_   ) :-
  memberchk(C,AncB), memberchk(A, AncC).




seq_target_is([op(_,Target,_)|_],Target).


depends_only(op(_,_,Sources),L) :-
        all_in_targets(Sources,L).

all_in_targets([],_).
all_in_targets([H|T],L) :-
        memberchk(op(_,H,_),L),
        all_in_targets(T,L).

% 'isch' recognises what sort of block we are scheduling, and uses the appropriate scheduler
% 1) A single op producing a result just from loads, claim 'sequenntial'
% 2) An op with all sources traceable to loads, use 'sequential' scheduler
% 3) A single op with sources, leave alone
% 4) An op with a single op following, call it inevitable
% 5) Something else, use the heavyweight scheduler

isch(H,[],op(seq(1,[H]),Target,[])) :- depends_only(H,[]), !
    , verify_schedule([H])       % surely OK
    , target_of(H,Target)
    .         % Just a 'load' -- easy to schedule, use 1 temporary

isch(H,L0,op(seq(N,[H|L]),Target,[])) :-      % An op with all sources traceable to loads
  all_seq(L0),
  depends_only(H,L0),!,
  target_of(H,Target),
  min_reg_seq(L0,L,N)
  , verify_schedule([H|L])
  .

% Instruction on its own, no grouping to be done
isch(H,[],H) :- ! .

isch(H,G0,op(alg(Q,S),Target,Sources)) :-
  target_of(H,Target),
  sources_of(H,S0),
  sources_of_list(G0,S1),
  union(S0,S1,S2),
  targets_of_list(G0,Targets),
  setdiff(S2,Targets,Sources),
  algorithm_scheduler([H|G0],S,Q)
  , verify_schedule(S)
  .



% Check if everything is traceable to loads ...
all_seq([]).
all_seq([op(seq(_,_),_,[])|T]) :-  all_seq(T). % alternative representation of 'seq' as an op with no sources

min_reg_seq([],[],0).
min_reg_seq(L0,S,N) :-
  select(op(seq(N0,S0),_,[]),L0,L1),
  none_thinner(N0,L1),
  min_reg_seq(L1,S1,N1),
  append(S0,S1,S),
  new_reg_count(N0,N1,N)
  .

new_reg_count(N0,N1,N1) :- N1 > N0, !.
new_reg_count(N0,0,N0) :- !.
new_reg_count(N0,_,N) :- N is N0+1.

none_thinner(N,[op(seq(N1,_),_,_)|_]) :- N1 < N, !, fail.
none_thinner(N,[_|T]) :- none_thinner(N,T).
none_thinner(_,[]).



nonancestor(op(_,A,_), op(_,B,_), Ancestry) :-
  memberchk(ancestors(B,AncestorsB),Ancestry),
  memberchk(A,AncestorsB),
  !, fail.
nonancestor(_,_,_).

ancestors_nonancestors(op(_,Target,_),All,Ancestors,Rest,Ancestry) :-
  memberchk(ancestors(Target,AncestorTargets),Ancestry),
  partition(All,AncestorTargets,Ancestors,Rest).

partition([],_,[],[]).
partition([H|T0],I,[H|A],R) :- target_is(H,Target), memberchk(Target,I), !, partition(T0,I,A,R).
partition([H|T0],I,A,[H|R]) :- partition(T0,I,A,R).

target_is(op(_,Target,_),Target).

% Determine whether the ancestors of an item only source other ancestors; i.e. whether computation is unshared
%

only_sources_ancestors(All,H,Ancestors,Ancestry) :- any_source_nonancestor(All,H,Ancestors,Ancestry), !, fail.
only_sources_ancestors(_,_,_,_).

any_source_nonancestor(All,H,Ancestors,Ancestry) :-
  member(X,All),
  X \== H,
  nonmember(X, Ancestors),
  source_of(S,X),
  memberchk(op(_,S,_),Ancestors),
  nonancestor(H,X,Ancestry)
  .

nonmember(X,L) :- memberchk(X,L), !, fail.
nonmember(_,_).

source_of(S,op(_,_,Sources)) :- member(S,Sources).


% Translate a descendency map (L) to an ancestry map (A)
% Note ... we only put something in the ancestry map if it is generated in the tree.
ancestry_map([],[]).
ancestry_map([op(_,Target,Sources)|T0],[ancestors(Target,A)|T]) :-
  ancestry_map(T0,T),
  ancestor_sources(Sources,T,A,T0).

ancestor_sources([],_,[],_).
ancestor_sources([H|T],M,A,L) :-
  memberchk(ancestors(H,A0),M), !,
  ancestor_sources(T,M,A1,L),
  set_union([H],A0,A2),
  set_union(A1,A2,A).
ancestor_sources([H|T],M,[H|A],L) :-
  memberchk(op(_,H,_),L), !,
  ancestor_sources(T,M,A,L).
ancestor_sources([_|T],M,A,L) :- ancestor_sources(T,M,A,L).

% For 2 lists representing sets, produce the list representing the union.
union([],L,L).
union([H|T],L0,L) :- memberchk(H,L0), !, union(T,L0,L).
union([H|T],L0,[H|L1]) :- union(T,L0,L1).


setdiff([],_,[]).
setdiff([H|T],L0,L) :-
  memberchk(H,L0),!,
  setdiff(T,L0,L).
setdiff([H|T0],L,[H|T]) :- setdiff(T0,L,T).

intersection([],_,[]).
intersection([H|T0],L,[H|T]) :- memberchk(H,L), !, intersection(T0,L,T).
intersection([_|T0],L,T) :- intersection(T0,L,T).



target_of(op(_,Target,_),Target).

% Scheduler accouting for the 'inevitabilities'

schedule_inevitable_all([],[]).
schedule_inevitable_all([H0|T0],[H|T]) :-
  schedule_inevitable(H0,H),
  schedule_inevitable_all(T0,T).

% Take a list of ops, some of which carry 'inevitable schedule' groups, and do the instruction scheduling
schedule_inevitable(L0,L) :-
  flatten_inevitable(L0,L1),
  schedule_i(xxx,L1,L2),
  transform_xxx(L2,L).

transform_xxx(sch(_,[xxx|T]),T).


flatten_inevitable([],[]).
flatten_inevitable([op(group(Opcode,Sources0,G0),Target,_,_)|T0],
                   [L|T]) :- !,
  flatten_inevitable(G0,L0),
  schedule_i(op(Opcode,Target,Sources0),L0,L),
  flatten_inevitable(T0,T).
flatten_inevitable([H|T0],[H|T]) :- flatten_inevitable(T0,T).

% 'inevitable sequence' scheduler
schedule_i(BaseOp,SourceOps,Result) :-
  simple_schedule_i(BaseOp,SourceOps,Result)
  .

max(A,B,A) :- A > B, !.
max(_,B,B).

simple_schedule_i(BaseOp,[],sch(1,[BaseOp])) :- !.
simple_schedule_i(BaseOp,[sch(Q,R)],sch(Q,[BaseOp|R])) :- !.

simple_schedule_i(BaseOp,[sch(Q1,R1),sch(Q2,R2)],sch(Q,[BaseOp|R])) :-
 Q1 >= Q2, !,
 Q2A is Q2+1,
 max(Q1,Q2A,Q),
 append(R2,R1,R).
simple_schedule_i(BaseOp,[sch(Q1,R1),sch(Q2,R2)],sch(Q,[BaseOp|R])) :- !,
 Q1A is Q1+1,
 max(Q1A,Q2,Q),
 append(R1,R2,R).

simple_schedule_i(BaseOp,[sch(Q1,R1),sch(Q2,R2),sch(Q3,R3)],sch(Q,[BaseOp|R])) :-
 Q1 >= Q2, Q2 >= Q3,!, simple_resolve(Q1,R1,Q2,R2,Q3,R3,Q,R).                       % Q1 >= Q2 >= Q3
simple_schedule_i(BaseOp,[sch(Q1,R1),sch(Q2,R2),sch(Q3,R3)],sch(Q,[BaseOp|R])) :-
 Q1 >= Q3, Q3 >= Q2,!, simple_resolve(Q1,R1,Q3,R3,Q2,R2,Q,R).                       % Q1 >= Q3 >= Q3
simple_schedule_i(BaseOp,[sch(Q1,R1),sch(Q2,R2),sch(Q3,R3)],sch(Q,[BaseOp|R])) :-
 Q2 >= Q3, Q3 >= Q1,!, simple_resolve(Q2,R2,Q3,R3,Q1,R1,Q,R).                       % Q2 >= Q3 >= Q1
simple_schedule_i(BaseOp,[sch(Q1,R1),sch(Q2,R2),sch(Q3,R3)],sch(Q,[BaseOp|R])) :-
 Q2 >= Q1, Q1 >= Q3,!, simple_resolve(Q2,R2,Q1,R1,Q3,R3,Q,R).                       % Q2 >= Q1 >= Q3
simple_schedule_i(BaseOp,[sch(Q1,R1),sch(Q2,R2),sch(Q3,R3)],sch(Q,[BaseOp|R])) :-
 Q3 >= Q1, Q1 >= Q2,!, simple_resolve(Q3,R3,Q1,R1,Q2,R2,Q,R).                       % Q3 >= Q1 >= Q2
simple_schedule_i(BaseOp,[sch(Q1,R1),sch(Q2,R2),sch(Q3,R3)],sch(Q,[BaseOp|R])) :-
 Q3 >= Q2, Q2 >= Q1,!, simple_resolve(Q3,R3,Q2,R2,Q1,R1,Q,R).                       % Q3 >= Q2 >= Q1
% ... and that should cover all pre-scheduled cases ... anything else, pass to heavyweight scheduler

simple_resolve(Qa,Ra,Qb,Rb,Qc,Rc,Q,R) :-
 Qb1 is Qb+1, Qc2 is Qc+2,
 max(Qa,Qb1,QQ), max(QQ,Qc2,Q),
 append(Rc,Rb,RR),
 append(RR,Ra,R).



% Transform an operation list into an 'aop' list, for the algorithm scheduler to work on
op_aop_lista([],[]).
op_aop_lista([H0|T0],[H|T]) :- op_aop(H0,H), op_aop_lista(T0,T).

%mtrace(6) :- !, trace.
%mtrace(_).

op_aop(X,aop(X,Q,Targets,Sources)) :-
        mserialise_h(X,[],M),
%       all_targets(M,Targets),
%       all_sources(M,Sources0),
        all_targets(X,Targets),
        all_sources(X,Sources0),
        write_list(X), write_list(M), write_list(Targets), write_list(Sources0),
        set_difference(Sources0,Targets,Sources),
        c_alc_part(M,R),
        highest_temp_target(R,0,Q),
%       mtrace(Q),
%        Q is Q0+1,
        write('\nAllocation of '), write(aop(xxx,Q,Targets,Sources)), write(' '), write_list(R).
%
%       .
%       Q = 0.

%highest_temp([],Z,Z).
%highest_temp([op(_,_,_,ASources)|T],Z0,Z) :-
%        highest_temp_l(ASources,Z0,Z1), highest_temp(T,Z1,Z).
%
%highest_temp_l([],Z,Z).
%highest_temp_l([t(Z0)|T],Z1,Z) :- max(Z0,Z1,Z2), highest_temp_l(T,Z2,Z).

highest_temp_target([],Z,Z).
highest_temp_target([op(_,_,t(Z0),_)|T],Z1,Z) :- !,max(Z0,Z1,Z2), highest_temp_target(T,Z2,Z).
highest_temp_target([op(_,_,storage(_),_)|T],Z0,Z) :- highest_temp_target(T,Z0,Z).

aop_all_st([],[],[]).
aop_all_st([aop(_,_,Targets,Sources)|T],AllTargets,AllSources) :-
        aop_all_st(T,AllTargets0,AllSources0),
        set_union(Targets,AllTargets0,AllTargets),
        set_union(Sources,AllSources0,AllSources).

op_aop_list(L0,L) :-
        op_aop_lista(L0,L1),
        aop_all_st(L1,AllTargets,AllSources),
        aop_intersection(L1,L,AllTargets,AllSources).

aop_intersection([],[],_,_).
aop_intersection([aop(X,N,Targets0,Sources0)|T0],[aop(X,N,Targets,Sources)|T],AT,AS) :-
        set_intersection(Targets0,AS,Targets),
        set_intersection(Sources0,AT,Sources),
        aop_intersection(T0,T,AT,AS).



all_targets(X,Targets) :- findall(Target,any_target(X,Target),Targets0),list_set(Targets0,Targets).
all_sources(X,Sources) :- findall(Source,any_source(X,Source),Sources0),list_set(Sources0,Sources).

% And transform back; we could in principle define the first reversibly, but seems messy.
aop_op_list([],[]).
aop_op_list([aop(X,_,_,_)|T0],[X|T]) :- aop_op_list(T0,T).

%% Algorithmic scheduler, unscheduled instruction list --> scheduled instruction list

algorithm_scheduler(Instructions,Schedule,Quantity) :-
  op_aop_list(Instructions,Ainstructions),
  report_if_interesting('\nUsing algorithm scheduler on\n',Instructions,Ainstructions),
  widest_sources(Ainstructions,0,MinQ),
  ut_schedule(Ainstructions,Aschedule,MinQ,Quantity,_),
  aop_op_list(Aschedule,Schedule),
  report_if_interesting('\nAlgorithm scheduler results in\n',Schedule,Aschedule)
  .

report_if_interesting(_,Instructions,_) :- length(Instructions,Q), Q < 3, !.
report_if_interesting(Header,Instructions,Ainstructions) :-
  write(Header), show_structured(Instructions), show_aop_list(Ainstructions), write('\n'),
  mserialise_l(Instructions,Minstructions), c_alc(Minstructions,Rinstructions), show_structured(Rinstructions),!.
report_if_interesting(_,_,_).


widest_sources([],Q,Q).
% Following not logically correct, but produces credible schedule
widest_sources([aop(_,N,_,Sources)|T],Q0,Q) :- length(Sources,Q1), Q2 is Q1+N, max(Q0,Q2,Q3), widest_sources(T,Q3,Q).
%widest_sources([aop(_,_,_,Sources)|T],Q0,Q) :- length(Sources,Q1), max(Q0,Q1,Q2), widest_sources(T,Q2,Q).

show_aop_list([]).
show_aop_list([H|T]) :- show_aop(H), show_aop_list(T).

show_aop(aop(_,Sequence,Targets,Sources)) :- !,
        write('\n')
        ,write(aop(xxx,Sequence,Targets,Sources)).
show_aop(aop(_,Sequence,Targets,Atargets,Asources)) :- !,
        write('\n')
        ,write(aop(xxx,Sequence,Targets,Atargets,Asources)).
show_aop(X) :- write('\n'), trace, write(X).

show_structured(X) :- s_structured(X), fail.
show_structured(_).

%show_structured_1(X) :- serialise_h(X,[],Xs),write_indent(0,Xs).
%show_structured_1(X) :- mserialise_h(X,[],Xs),write_indent(0,Xs).

s_structured(X) :- serialise_l(X,Xs), !, length(X,Lx), write('Length '), write(Lx), write('\n'),
                   write_indent(0,Xs).
%s_structured(X) :- mserialise_l(X,Xs), !, length(X,Lx), write('Length '), write(Lx), write('\n'),
%                   write_indent(0,Xs).

s_structured(X) :- write_list(X).

bad_schedule([],[]).
bad_schedule([H|T0],[X|T]) :- target_in_any_source(H,T0,X), !, bad_schedule(T0,T).
bad_schedule([_|T0],T) :-  bad_schedule(T0,T).


%% old implementation before structured ops
%target_in_any_source(op(_,Target0,_),[op(Opcode,Target,Sources)|_],op(Opcode,Target,Sources)) :- memberchk(Target0,Sources),!.
%target_in_any_source(A,[_|T],X) :- target_in_any_source(A,T,X).

target_in_any_source(A,[B|_],bad(X,A,B)) :- any_target(A,X), any_source(B,X), !.
target_in_any_source(A,[_|T],X) :- target_in_any_source(A,T,X).

verify_schedule(X) :- bad_schedule(X,B), show_bad_schedule(X,B), fail.

verify_schedule(_).

show_bad_schedule(_,[]) :- !.
show_bad_schedule(X,B) :-
        write('\nInstruction scheduling error, fault list is ')
       ,write_list(B)
       ,write('\n')
       ,write_indent(0,X)
       .



% Instruction scheduler.
% Logically, 'An instruction schedule is a permutation of the set of required instructions, such that
% no instruction is run after its result is required, and such that there is an assignment of logical temporaries
% to registers'.
% This is fine as a specification, but requires design to produce an algorithm; there are N! permutations of
% N instructions, we would hope for a more efficient implementation.

s_schedule([],[],[],_).
s_schedule([H0|T0],[Hs|Ts],[Hn|Tn],Temp0) :-
  ut_schedule(H0,Hs,Temp0,Hn,_),
  s_schedule(T0,Ts,Tn,Temp0).

temp_count([],0).
temp_count([t(A)|_],B) :- B is A+1.

% Instruction scheduler.
% This one schedules from the end backwards.
% 'You can choose any instruction, provided it doesn't generate a result which is required by an
% instruction which hasn't been scheduled yet'
ut_schedule(L,S,Q,Q,M) :-
  write('\n'), write(Q), flush_output,
  q_schedule(L,S,M,Q).
ut_schedule(L,S,Q0,Q,M) :-
    Q1 is Q0+1,
    ut_schedule(L,S,Q1,Q,M).


% Schedule from the end backwards.
% "You can choose any instruction, provided it doesn't generate a result which is required by an
% instruction which hasn't been scheduled yet"
% By this time, we only have the arithmetic; the loads and stores have been taken away.

a_schedule(Instructions,Schedule,Map,Temporaries) :-
   c_schedule(Instructions,Schedule,[],Map,Temporaries,_).

q_schedule(Instructions,Schedule,Map,Quantity) :-
   temp_list(Quantity,[],Temporaries),
   a_schedule(Instructions,Schedule,Map,Temporaries).

temp_list(0,L,L) :- !.
temp_list(N0,L0,L) :- N0 > 0, N1 is N0-1, temp_list(N1,[t(N1)|L0],L).



% Register allocator. (Reuse the scheduler's allocation logic, this time remember the result)
c_alc_all([],[]).
c_alc_all([H0|T0],[H|T]) :- c_alc(H0,H), c_alc_all(T0,T).


% .. verify that nothing needs to be in regs before the call, and that all temps are returned ...
c_alc(Schedule0,Schedule) :-
  tempmany(100,0,Temps0),
  c_allocate(Schedule0,Schedule,[],[],Temps0,Temps),
  length(Temps0,N),length(Temps,N).

c_alc_part(Schedule0,Schedule) :-
  tempmany(100,0,Temps0),
  c_allocate(Schedule0,Schedule,[],_,Temps0,_).


c_allocate([],[],Map,Map,Free,Free) :- !.
c_allocate([Op0|Schedule0],[Op|Schedule],Map0,Map,Free0,Free) :-
  t_allocate(detail,Op0,Op,Map0,Map1,Free0,Free1,Schedule0),
  c_allocate(Schedule0,Schedule,Map1,Map,Free1,Free).



c_select_nosource(Op,Ops,Rest,Map) :-
  c_select(Op,Ops,Rest),
  c_allocates(Op,Map,0).

c_select_onesource(Op,Ops,Rest,Map) :-
  c_select(Op,Ops,Rest),
  c_allocates(Op,Map,1).

c_select_manysource(Op,Ops,Rest,Map) :-
  c_select(Op,Ops,Rest),
  c_allocates(Op,Map,Q),
  Q > 1.




% Guts of the scheduler.
c_schedule([],[],Map,Map,Free,Free) :- !.
c_schedule(Ops,[Op|Schedule],Map0,Map,Free0,Free) :-
  c_select_nosource(Op,Ops,Rest,Map0),!, %write('Nosource '), write(Op), write('\n'), trace,
  t_allocate(quick,Op,_,Map0,Map1,Free0,Free1,Rest),
  c_schedule(Rest,Schedule,Map1,Map,Free1,Free).
c_schedule(Ops,[Op|Schedule],Map0,Map,Free0,Free) :-
  c_select_onesource(Op,Ops,Rest,Map0),!, %write('Onesource '), write(Op), write('\n'), trace,
  t_allocate(quick,Op,_,Map0,Map1,Free0,Free1,Rest),
  c_schedule(Rest,Schedule,Map1,Map,Free1,Free).
c_schedule(Ops,[Op|Schedule],Map0,Map,Free0,Free) :-
  c_select_manysource(Op,Ops,Rest,Map0),
  t_allocate(quick,Op,_,Map0,Map1,Free0,Free1,Rest),
  c_schedule(Rest,Schedule,Map1,Map,Free1,Free).



c_select(Op,Ops,Rest) :-
   select(Op,Ops,Rest),
   c_can_schedule_now(Op,Rest)
  .
%c_select_m(Op,Ops,Rest,Map,FreeCount,AllocCount) :-
%  select(Op,Ops,Rest),
%%  trace,
%  c_can_schedule_now(Op,Rest),
%%  write('\nExamining '), write(Op), write('\n'), write_list(Map), trace,
%%  trace,
%  c_returns(Op,FreeCount),
%  c_allocates(Op,Map,AllocCount).
%%  write('\nCandidate '), write([FreeCount,AllocCount,Op]).
%%  trace.
%%  FreeCount =:= FreeCount1,
%%  AllocCount =:= AllocCount1
%%  .

c_returns(aop(_,_,_,_),1). % temporarily ...

c_returns(op(_,Target,_),N) :-  c_returns_target(Target,N).
c_returns_target(Target,0) :- is_exttarget(Target).
c_returns_target(Target,1) :- is_temptarget(Target).


is_exttarget(ext(_)).
is_temptarget(H) :- integer(H).

c_allocates(aop(op(_,_,Sources),_,_,_),Map,AllocCount) :- count_allocated(Sources,Map,AllocCount).
c_allocates(op(_,_,Sources),Map,AllocCount) :-
  count_allocated(Sources,Map,AllocCount).

count_allocated([],_,0).
count_allocated([H|T0],Map,N) :-
  memberchk(map(_,logical(H)),Map),!,
  delete(T0,H,T1),
  count_allocated(T1,Map,N).
count_allocated([H|T0],Map,N) :-
  delete(T0,H,T1),
  count_allocated(T1,Map,N0),
  N is N0+1.


c_can_schedule_now(Op,Ops) :-
  c_returns(Op,0),                    % If it's a store, we can only schedule it if we are in a position to produce its source
  c_can_produce_source(Op,Ops).

c_can_schedule_now(Op,Ops) :-
  c_returns(Op,1),                    % If it computes a temporary, we can only schedule it if nothing else needs the result.
  c_can_follow_all(Op,Ops).

c_can_produce_source(op(_,_,[Source]),Ops) :-        % We can produce it if nothing (or only duplicate stores) needs the source
  c_can_produce_s(Source,Ops).
c_can_produce_source(op(_,_,[Source],_),Ops) :-        % We can produce it if nothing (or only duplicate stores) needs the source
  c_can_produce_s(Source,Ops).

c_can_produce_s(_,[]).
c_can_produce_s(Source,[H|T]) :- c_can_produce_h(Source,H), !, c_can_produce_s(Source,T).

c_can_produce_h(_,op(_,Target,_)) :- is_exttarget(Target).   % stores don't forbid ...
c_can_produce_h(Source,op(_,_,Sources)) :- memberchk(Source,Sources), !, fail.  % No, something else would have to come later.
c_can_produce_h(_,_).


c_can_follow_all(_,[]).
c_can_follow_all(Op,[H|T]) :-
  c_can_follow(Op,H),
  c_can_follow_all(Op,T).


c_can_follow(X,op(_,_,Sources)) :- any_target(X,Target), memberchk(Target,Sources), !, fail.
c_can_follow(aop(_,_,Targets,_),aop(_,_,_,Sources)) :- set_intersects(Targets,Sources), !, fail.
c_can_follow(_,_).



lead_target(op(_,T,_),T) :- T \== -1, !.      % -1 used as dummy target for compound ops
lead_target(op(seq(_,L),_,_),T) :- !,lead_target_l(L,T).
lead_target(op(inev(A,_),_,_),T) :- !,lead_target(A,T).
lead_target(op(inev(_,B),_,_),T) :- !,lead_target(B,T).
lead_target(op(alg(_,L),_,_),T) :- !,lead_target_l(L,T).
lead_target(op(solesource(L),_,_),T) :- !,lead_target_l(L,T).

lead_target_l([H|_],T) :- !,lead_target(H,T).


any_target(op(_,T,_),T) :- T \== -1.      % -1 used as dummy target for compound ops
any_target(op(seq(_,L),_,_),T) :- any_target_l(L,T).
any_target(op(inev(A,_),_,_),T) :- any_target(A,T).
any_target(op(inev(_,B),_,_),T) :- any_target(B,T).
any_target(op(alg(_,L),_,_),T) :- any_target_l(L,T).
any_target(op(solesource(L),_,_),T) :- any_target_l(L,T).

delete_targets_of(_,[],[]).
delete_targets_of(Z,[H|T0],T) :- any_target(Z,H), !, delete_targets_of(Z,T0,T).
delete_targets_of(Z,[_|T0],T) :- delete_targets_of(Z,T0,T).

any_target_l([H|_],T) :- any_target(H,T).
any_target_l([_|T0],T) :- any_target_l(T0,T).


any_source(op(_,_,Sources),Source) :- member(Source,Sources).
any_source(op(seq(_,L),_,_),T) :- any_source_l(L,T).
any_source(op(inev(A,_),_,_),T) :- any_source(A,T).
any_source(op(inev(_,B),_,_),T) :- any_source(B,T).
any_source(op(alg(_,L),_,_),T) :- any_source_l(L,T).
any_source(op(solesource(L),_,_),T) :- any_source_l(L,T).


any_source_l([H|_],T) :- any_source(H,T).
any_source_l([_|T0],T) :- any_source_l(T0,T).


% Register allocator
t_allocate(X,op(Code,Target,Sources)
          ,op(Code,Target,ATarget,ASources)
          ,Map0,Map,Free0,Free,
          Rest) :-
   t_register_map_one(Target,ATarget,Map0),
   t_free_register(X,ATarget,Map0,Map1,Free0,Free1),
   t_allocate_registers(Sources,Map1,Map,Free1,Free,Rest,0),
   t_register_map(Sources,ASources,Map).

t_allocate(X,aop(K,Q,Targets,Sources)
          ,aop(K,Q,Targets,Atargets,Asources)
          ,Map0,Map,Free0,Free,
          Rest) :-
   t_register_map(Targets,Atargets,Map0),
   t_free_register_list(X,Atargets,Map0,Map1,Free0,Free1),
   length(Free1,LF), LF >= Q,                                 % Check that there are enough temporaries available for internals
   t_allocate_registers(Sources,Map1,Map,Free1,Free,Rest,0),
   t_register_map(Sources,Asources,Map).


% Find the logical-to-physical mapping for a list of registers
% register_map(LogicalList,PhysicalList,AllocationList)
t_register_map([],[],_).
t_register_map([H0|T0],[H|T],M) :- t_register_map_one(H0,H,M), t_register_map(T0,T,M).

% register_map_one(Logical,Physical,AllocationList)
t_register_map_one(X,X,_) :- t_external_value(X), !.
t_register_map_one(L,L,_) :- is_load_list(L), !.
t_register_map_one(L,storage(L),[]) :- ! . % stores are stripped out
t_register_map_one(L,P,[map(P,logical(L))|_]) :- !.
t_register_map_one(L,P,[_|T]) :- t_register_map_one(L,P,T).

is_load_list([load(_)|_]).

t_external_value([ext(_)|_]) .
t_external_value([x|_]).


t_free_register_list(_,[],M,M,P,P).
t_free_register_list(X,[H|T],M0,M,P0,P) :- t_free_register(X,H,M0,M1,P0,P1), t_free_register_list(X,T,M1,M,P1,P).
t_free_register(_,storage(_),M,M,P,P).         %  values to be stored are not tagged as occupying a register
t_free_register(detail,L,M0,M,P,F) :- t_choose_physical(M0,L,M), t_merge(L,P,F). % lowest-numbered temp at front ...
t_free_register(quick,L,M0,M,P,[L|P]) :- t_choose_physical(M0,L,M).
% note ... if we produce anything which isn't used, 'allocation' for where it should go will fail here.

t_merge(X,[],[X]).
t_merge(t(A),[t(B)|T],[t(A),t(B)|T]) :- A < B, !.
t_merge(X,[H|T0],[H|T]) :- t_merge(X,T0,T).

t_choose_physical([map(H,_)|T],H,T).
t_choose_physical([H0|T0],H,[H0|T]) :- t_choose_physical(T0,H,T).

% Find a temporary in registers, or require it to be in a register
% allocate_registers(SourcesList,AllocationWithoutSources,AllocationWithSources,FreeWithoutSources,FreeWithSources,RemainingOperations)
t_allocate_registers([],Map,Map,Free,Free,_,_).
t_allocate_registers([H|T],M0,M,F0,F,Rest,LoadCount0) :-
    t_allocate_register(H,M0,M1,F0,F1,Rest,LoadCount0,LoadCount1),
    t_allocate_registers(T,M1,M,F1,F,Rest,LoadCount1).

% First see if the requested item is already in a register
t_allocate_register(H,M,M,F,F,_,L,L) :- t_already_allocated(H,M),!.

% In the 'block scheduler' case, always take a free register
t_allocate_register(H,M,[map(P,logical(H))|M],[P|F],F,_,L,L).
% If nothing produces it, it must be the result of a 'load'; don't allocate a register, but do check there
% are enough that we could run some immediately-precedent loads. (If it's a constant, i.e. same for all paths,
% don't even count the temporaries)
%   (don't currently have information about 'constants')
%   t_allocate_register([A,A|_],M,M,F,F,_,L,L) :- !.
%
%t_allocate_register(_,M,M,F,F,_,L0,L) :-
%  length(F,LF),
%  LF > L0,
%  L is L0+1.


% Check to see if a register is already allocated ...
t_already_allocated(H,[map(_,logical(H))|_]).
t_already_allocated(H,[_|M]) :- t_already_allocated(H,M).
t_already_allocated([load(_)|_],[]).





% produce_matchlist(...).
produce_matchlist([],[]).
produce_matchlist([Proto|Rest],Matchvector) :-
  write_list_list(Rest),
  produce_matchvector(Proto,Rest,Matchvector).

produce_matchvector([],_,[]).
produce_matchvector([match(A,B)|T0],Rest0,[vector(A,[A,B|Rest])|T]) :-
  produce_matchrest(A,Rest0,Rest),
  produce_matchvector(T0,Rest0,T).


produce_matchrest(_,[],[]).
produce_matchrest(A,[H0|T0],[B|T]) :-
  memberchk(match(A,B),H0),
  produce_matchrest(A,T0,T).
produce_matchread(A,[_|T0],[-1|T]) :- produce_matchrest(A,T0,T).


% Following not working at present, needs code to merge in 'matchup'.
% By now, we have a scheduled instruction stream expressed in vector operations. Expand it in terms of
% scalar operations, which may include double-hummer-style SIMD ops.

scalarise([],[]).
scalarise([H0|T0],[H|T]) :-
  scalarise_one_stream(H0,H),
  scalarise(T0,T).

scalarise_one_stream(V,S) :-
  stream_width(V,N),
  scalarise_stream(N,V,S).

scalarise_stream(_,[],[]).
scalarise_stream(N,[H|T],S) :-
  scalarise_stream(N,T,S0),
  scalarise_op(N,H,S0,S).

scalarise_op(N,op(Opcode,Target,Sources),S0,S) :-
  scalarise_n(0,N,Opcode,Target,Sources,S0,S).

scalarise_n(I,N,_,_,_,S,S) :- I >= N, !.
scalarise_n(I,N,Opcode,Target0,Sources0,S0,[op(Opcode,Target,Sources)|S0] ) :- I =:= N-1, !,
   target_n(I,N,Target0,Target),
   sources_n(I,N,Sources0,Sources).
scalarise_n(I0,N,Opcode0,Target0,Sources0,S0,[op(Opcode,Target,Sources)|S] ) :-
   parallel_opcode(Opcode0,Opcode),
   parallel_target_n(I0,N,Target0,Target),
   parallel_sources_n(I0,N,Sources0,Sources),
   I is I0+2,
   scalarise_n(I,N,Opcode0,Target0,Sources0,S0,S).

parallel_opcode(X0,parallel(X0)).

target_n(I,N,t(X0),fp(X)) :- !, I is N-1, P is N // 2, X is X0*P + P - 1.   % only has to work for 'last' ...
target_n(I,_,storage(L),storage(X)) :- nth(I,L,X).

sources_n(_,_,[],[]).
sources_n(I,N,[H0|T0],[H|T]) :-
  source_n(I,N,H0,H),
  sources_n(I,N,T0,T).

odd(N) :- 1 is N /\ 1.
even(N) :- 0 is N /\ 1.

basereg(N,X0,X) :- N1 is N+1, N2 is N1 >> 1, X is X0 * N2.
offsreg(I,X0,X) :- Q is I >> 1, X is X0 + Q.

source_n(I,N,t(X0),fp(X)) :- even(I), basereg(N,X0,X1), offsreg(I,X1,X).
source_n(I,N,t(X0),fs(X)) :- odd(I), basereg(N,X0,X1), offsreg(I,X1,X).
source_n(I,_,L,X) :- I1 is I+1, nth(I1,L,X).

parallel_target_n(I,N,t(X0),pfp(X)) :- even(I), basereg(N,X0,X1), offsreg(I,X1,X).
parallel_target_n(I,_,storage(L),pstore(A,B)) :- I1 is I+1, nth(I1,L,A), I2 is I+2, nth(I2,L,B).

parallel_sources_n(_,_,[],[]).
parallel_sources_n(I,N,[H0|T0],[H|T]) :-
  parallel_source_n(I,N,H0,H),
  parallel_sources_n(I,N,T0,T).

parallel_source_n(I,N,t(X0),pfp(X)) :- even(I), basereg(N,X0,X1), offsreg(I,X1,X).
parallel_source_n(I,_,storage(L),pload(A,B)) :- I1 is I+1, nth(I1,L,A), I2 is I+2, nth(I2,L,B).

% The width of the stream is the number of targets for any 'store' in the stream.
stream_width([op(_,storage(Targets),_)|_],N) :- !,length(Targets,N).
stream_width([_|T],N) :- stream_width(T,N).






% Initial creation of temporary variables
tempmany(X,_,[]) :- X =< 0, !.
tempmany(N,A,[t(A)|T]) :- N1 is N-1, A1 is A+1, tempmany(N1,A1,T).

%temp0([
%t(19),t(18),t(17),t(16),t(15),t(14),t(13),t(12),t(11),t(10),
%t(9),t(8),t(7),t(6),t(5),t(4),t(3),t(2),t(1),t(0)
%]).
% temp0([]).

temp0(0).

% Set operations
% A set representation of a list is maintained sorted; duplicate elements in a list are represented once in the set
list_set(L,S) :- sort(L,S).

head_of([H|_],H).

set_union([],S,S) :- !.
set_union(S,[],S) :- !.
set_union([H|T0],[H|T1],[H|T]) :- !,set_union(T0,T1,T).
set_union([H0|T0],L1,[H0|T]) :- head_of(L1,H1), H0 < H1, !, set_union(T0,L1,T).
set_union(L0,[H1|T1],[H1|T]) :- set_union(L0,T1,T).

set_intersection([],_,[]) :- !.
set_intersection(_,[],[]) :- !.
set_intersection([H|T0],[H|T1],[H|T]) :- !, set_intersection(T0,T1,T).
set_intersection([H0|T0],L1,T) :- head_of(L1,H1), H0 < H1, !, set_intersection(T0,L1,T).
set_intersection(L0,[_|T1],T) :- set_intersection(L0,T1,T).

set_difference([],_,[]) :- !.
set_difference(S,[],S) :- !.
set_difference([H|T0],[H|T1],T) :- !, set_difference(T0,T1,T).
set_difference([H0|T0],L1,[H0|T]) :- head_of(L1,H1), H0 < H1, !, set_difference(T0,L1,T).
set_difference(L0,[_|T1],T) :- set_difference(L0,T1,T).

set_intersects([H|_],[H|_]).
set_intersects([H0|T0],L1) :- head_of(L1,H1), H0 < H1, !, set_intersects(T0,L1).
set_intersects(L0,[_|T1]) :- set_intersects(L0,T1).

set_disjoint(L0,L1) :- set_intersects(L0,L1), !, fail.
set_disjoint(_,_).

% Support for deleting 'unused' code

% Take in a list after 'pgm_dep', and leave only those ops which produce results which are used.
dep_used([],[]).
dep_used([H|T0],T) :-
  dep_used(T0,T1),
  used_or_left(H,T1,T).
used_or_left(H,T,[H|T]) :- is_store(H), !.
used_or_left(H,T,[H|T]) :- is_branch(H), !.
used_or_left(H,T,[H|T]) :- target_of(H,X), any_source_of(X,T), !.
used_or_left(_,T,T).

any_source_of(X,[op(_,_,S)|_]) :- memberchk(X,S), !.
any_source_of(X,[_|T]) :- any_source_of(X,T).


annotate_temps([],[],[]).
annotate_temps([H|T0],[t(H,Temporaries)|T],Temporaries) :-
  annotate_temps(T0,T,Temporaries0),
  target_of(H,Target),
  sources_of(H,Sources),
  delete(Temporaries0,Target,Temporaries1),
  list_set(Sources,SourceSet),
  set_union(SourceSet,Temporaries1,Temporaries).

annotate_temps_only([],[],_).
annotate_temps_only([t(H,Temps0)|T0],[t(H,Temps)|T],S) :-
  set_difference(Temps0,S,Temps),
  annotate_temps_only(T0,T,S).

annotate_regcount([],[],_,_).
annotate_regcount([t(H,Temps)|T0],[t(H,R,TT)|T],M0,Temps0) :-
   set_difference(Temps0,Temps,TT),
   result_type(H,X),
   target_of(H,N),
   tot_up_regs(Temps,M0,q(0,0,0),R),
   write(t(H,R,Temps)),write('\n'),
   annotate_regcount(T0,T,[m(N,X)|M0],Temps).

result_type(op(Z,_,_),X) :- op_result_type(Z,X).

tot_up_regs([],_,Q,Q).
tot_up_regs([H|T],M,Q0,Q) :-
  memberchk(m(H,R),M),
  add_reg(R,Q0,Q1),
  tot_up_regs(T,M,Q1,Q).

add_reg(i,q(I0,F,C),q(I,F,C)) :- I is I0+1.
add_reg(f,q(I,F0,C),q(I,F,C)) :- F is F0+1.
add_reg(c,q(I,F,C0),q(I,F,C)) :- C is C0+1.
add_reg(n,Q,Q).


op_result_type('A'     ,i).
op_result_type('ABSFL' ,i).
op_result_type('AFL'   ,f).
op_result_type('AI'    ,i).
op_result_type('AIU'   ,i).
op_result_type('B'     ,n).
op_result_type('BA'    ,n).
op_result_type('BF'    ,n).
op_result_type('BT'    ,n).
op_result_type('CFL'   ,c).
op_result_type('COMPFL',f).
op_result_type('CVLS'  ,f).
op_result_type('FMA'   ,f).
op_result_type('FMS'   ,f).
op_result_type('FNMA'  ,f).
op_result_type('FNMS'  ,f).
op_result_type('FRES'  ,f).
op_result_type('FRSQRE',f).
op_result_type('FSEL'  ,f).
op_result_type('L4A'   ,i).
op_result_type('LFL'   ,f).
op_result_type('LFS'   ,f).
op_result_type('LI'    ,i).
op_result_type('LIU'   ,i).
op_result_type('LR'    ,i).
op_result_type('LRFL'  ,f).
op_result_type('M'     ,i).
op_result_type('MFL'   ,f).
op_result_type('NABSFL',f).
op_result_type('RN4'   ,i).
op_result_type('S'     ,i).
op_result_type('SFL'   ,f).
op_result_type('SLL4'  ,i).
op_result_type('SRL4'  ,i).
op_result_type('ST4A'  ,i).
op_result_type('ST4U'  ,i).
op_result_type('STFDU' ,f).
op_result_type('STFL'  ,f).
op_result_type(unary(X),Y) :- op_result_type(X,Y).
op_result_type(binary(X),Y) :- op_result_type(X,Y).
op_result_type(binary12(X),Y) :- op_result_type(X,Y).
op_result_type(binary13(X),Y) :- op_result_type(X,Y).

op_result_type(X,z) :- write(X), trace, fail.


