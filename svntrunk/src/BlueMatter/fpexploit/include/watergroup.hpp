/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 #if !defined(WATERGROUP_HPP)
#define WATERGROUP_HPP
class RunTimeGlobals
{
   public:
   static XYZ mBoundingBoxDimensionVector ;
} ;

extern RunTimeGlobals RTG ;

class WaterGroup
{
   public:
   // Centre and radius of sphere enclosing the fragment (smaller the better, best is H-H diameter for water)
   int mElementId ;
   XYZ mGeoCentre ;
   double mGeoRadius ;


   XYZ mAtomPositions[3] ;

   int GetIrreduciblePartitionElementId(void) const { return mElementId ; } ;
   const XYZ* GetPositionPtr(int AtomNumber) const { return &mAtomPositions[AtomNumber] ; } ;
   const XYZ& GetGeoCentre(void) const { return mGeoCentre ; } ;
   double GetGeoRadius(void) const { return mGeoRadius ; } ;

} ;

class Result
{
   public:
//   XYZ mForces[3] ;
//   void AddForce(int AtomNumber, const XYZ& Force)
//   {
//      mForces[AtomNumber] = mForces[AtomNumber] + Force ;
//   } ;
     XYZ mForce0 ;
     XYZ mForce1 ;
     XYZ mForce2 ;
   void AddForce3(const XYZ& Force0, const XYZ& Force1, const XYZ& Force2)
   {
      XYZ aForce0 = Force0 ;
      XYZ aForce1 = Force1 ;
      XYZ aForce2 = Force2 ;
//    XYZA aSum0 = mForce0 + aForce0 ;
//    XYZA aSum1 = mForce1 + aForce1 ;
//    XYZA aSum2 = mForce2 + aForce2 ;
      mForce0 = mForce0 + aForce0 ;
      mForce1 = mForce1 + aForce1 ;
      mForce2 = mForce2 + aForce2 ;
//    mForce1 = aSum1 ;
//    mForce2 = aSum2 ;
   }
} ;

class Energy
{
   public:
//   double mEnergies[UDF_Binding::ForceCodeCount] ;
//   void AddEnergy(int ForceCode, double PartialEnergy) { mEnergies[ForceCode] += PartialEnergy ; } ;
   double LJEnergy ;
   double ChEnergy ;
   void AddEnergies (double aLJEnergy, double aChEnergy)
   {
      LJEnergy += aLJEnergy ;
      ChEnergy += aChEnergy ;
   } ;
} ;

class MSD_IF {
public:
   static int mIrreduciblePartitionElementMemberSiteCount[100] ;
   static int GetIrreduciblePartitionElementMemberSiteCount(int ElementId)
    {
      return mIrreduciblePartitionElementMemberSiteCount[ElementId] ;
    } ;
   } ;

void op_water_water(const WaterGroup& SourceGroup
                  , const WaterGroup& TargetGroup
                  , Result& aResult
                  , Energy& aEnergy
                  , int SimTick
                  , void** PersistentStatePointer
                  ) ;
#endif
