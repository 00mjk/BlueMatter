/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Test cases to explore floating-point efficiency on Blue Light with double hummer
 *
 *  Classes and inlines
 *
 * Chris Ward
 *  20010821
 */
#include <math.h>
// 'fsel' is a built-in instruction on PPCGR and above, sometimes we want to force its use
#if defined(ARCH_HAS_FSEL)
#include <builtins.h>
#define fsel(a, x, y) __fsel((a),(x),(y))
#else
#define fsel(a, x, y) ( (a) >= 0.0 ? (x) : (y) )
#endif

/*
 * Double Hummer compiler idiom for quadword alignment
 */
#if defined(PK_BGL)
extern "builtin" void __alignx (int, const void *);
#define QuadWordAligned(X) __alignx(16, X)
#else
#define QuadWordAligned(X)
#endif

#if defined(PK_BGL)
__align(16)
#endif
class XYZ {
  public:
  double mX ;
  double mY ;
  double mZ ;
  double LengthSquared(void) const {
     return mX*mX + mY*mY + mZ*mZ ;
     } ;
} ;

#if defined(PK_BGL)
__align(16)
#endif
class XYZA {
public:
   XYZ mXYZ ;
   double mDummy ;
} ;

#if defined(PK_BGL)
__align(16)
#endif
class XYZAf {
public:
   XYZ mXYZ ;
   double mDummyf ;
} ;

#if defined(PK_BGL)
__align(16)
#endif
class XYZAp {
public:
   XYZ mXYZ ;
   double mDummyp ;
} ;

#if defined(PK_BGL)
__align(16)
#endif
class XYZAv {
public:
   XYZ mXYZ ;
   double mDummyv ;
} ;

inline XYZ sum(const XYZ& a, const XYZ& b)
{
  XYZ result ;
  result.mX = a.mX + b.mX ;
  result.mY = a.mY + b.mY ;
  result.mZ = a.mZ + b.mZ ;
  return result ;
}

inline XYZ difference(const XYZ& a, const XYZ& b)
{
  XYZ result ;
  result.mX = a.mX - b.mX ;
  result.mY = a.mY - b.mY ;
  result.mZ = a.mZ - b.mZ ;
  return result ;
}

inline XYZ negate(const XYZ& a)
{
  XYZ result ;
  result.mX = - a.mX ;
  result.mY = - a.mY ;
  result.mZ = - a.mZ ;
  return result ;
}

inline XYZ operator* ( const XYZ& a, double b)
{
   XYZ result ;
   result.mX = a.mX * b ;
   result.mY = a.mY * b ;
   result.mZ = a.mZ * b ;
   return result ;
}

inline XYZ operator+ ( const XYZ& a, const XYZ& b)
{
   XYZ result ;
   result.mX = a.mX + b.mX ;
   result.mY = a.mY + b.mY ;
   result.mZ = a.mZ + b.mZ ;
   return result ;
}

inline XYZ operator- ( const XYZ& a, const XYZ& b)
{
   XYZ result ;
   result.mX = a.mX - b.mX ;
   result.mY = a.mY - b.mY ;
   result.mZ = a.mZ - b.mZ ;
   return result ;
}

inline double sqr(const XYZ& a)
{
  return a.mX*a.mX + a.mY*a.mY + a.mZ*a.mZ ;
}

inline XYZ CrossProduct(const XYZ& a, const XYZ& b)
{
   XYZ result ;
   result.mX = a.mY*b.mZ - a.mZ*b.mY ;
   result.mY = a.mZ*b.mX - a.mX*b.mZ ;
   result.mZ = a.mX*b.mY - a.mY*b.mX ;
   return result ;
}

inline double DotProduct(const XYZ& a, const XYZ& b)
{
   return a.mX*b.mX + a.mY*b.mY + a.mZ*b.mZ ;
}


class MD_Atom
{
public:
  XYZ mLoc ;
  int mAtomType ;
  int mDummy ; // to cause 16-byte alignment
} ;

class MD_BondSpec
{
public:
  int mAtomIndexA ;
  int mAtomIndexB ;
} ;

class MD_BondSpecX
{
public:
  XYZ mAtomLocA ;
  XYZ mAtomLocB ;
} ;

class MD_BondVector
{
public:
  XYZ mVec    ;
  double mSquareLength ;
  double mRecipLength ;
  double mDummy ; // to cause 16-byte alignment
} ;

class MD_HarmonicBondSpec
{
public:
   double mk ;
   double mr0 ;
   unsigned short mBondRegisterIndex ;
   unsigned short mPartialForceRegisterIndexA ;
   unsigned short mPartialForceRegisterIndexB ;
} ;

class MD_HarmonicAngleSpec
{
public:
   double mk ;
   double mth0;
   unsigned short mBondRegisterIndexBA ;
   unsigned short mBondRegisterIndexBC ;
   unsigned short mPartialForceRegisterIndexA ;
   unsigned short mPartialForceRegisterIndexB ;
   unsigned short mPartialForceRegisterIndexC ;
} ;

// Compute a group of bond vectors from their specifications
// Work out vectors in both directions, square lengths, and reciprocal lengths
void ComputeBondVectors(
  MD_BondVector * BondVectorTable
  , const MD_Atom* AtomTable
  , const MD_BondSpec* BondSpecTable
  , unsigned int grouplim
  ) ;

void HarmonicBondForce(
   XYZA* PartialForceTable
   , double& TotalEnergy
   , const MD_BondVector* BondVectorTable
   , const MD_HarmonicBondSpec* HarmonicBondSpecTable
   , unsigned int groupcount
   ) ;

void HarmonicAngleForce(
   XYZA* PartialForceTable
   , double& TotalEnergy
   , const MD_BondVector* BondVectorTable
   , const MD_HarmonicAngleSpec* HarmonicAngleSpecTable
   , unsigned int groupcount
   ) ;

void forcesum2 (
  XYZA* TotalForceTable
  , const XYZA* PartialForceTable
  , const unsigned int* RAMap
  , unsigned int groupcount
) ;

void forcesum3 (
  XYZA* TotalForceTable
  , const XYZA* PartialForceTable
  , const unsigned int* RAMap
  , unsigned int groupcount
) ;

void WaterBond(
   XYZA* TotalForceTable
  ,const MD_Atom* AtomTable
  , double StretchEnergy
  , double AngleEnergy
  ) ;

