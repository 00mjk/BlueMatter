#!/bin/perl
####################################################################
### opls2xml.pl 
###          A perl script file for generating force field independent
###          parameter files for OPLS-AA from IMPACT runs. It will
###          collect OPLS-AA parameters and structural information 
###          from IMPACT output files and pdb files, and then write them out
###          into a readable ASCII file, and finally convert it into 
###          an XML file. 
###          
###
### usage:   opls2xml.pl [-options] jobname.out jobname.pdb
### example: opls2xml.pl enkp.out enkp.pdb
###          opls2xml.pl -w hairpin_water.out hairpin_water.pdb 
###          # this generates "enkp.prm" and "enkp.xml"
###          # note: the pdb file must have the same atom order 
###            as the output file (use the pdb file generated by IMPACT)
###
### options:
###          -w water will be included explicitly (ie, no DB2 path)         
###
### 
### input:   impact output file (jobname.out,verbose level >= 4) and pdb file
### output:  parameter files: jobname.prm (ASCII) and jobname.xml (XML)
###
### Note: index starts from 1 in site/bond/angle/torsion counts
###
### R. Zhou, IBM, 09/2000, modified 06/2001, 09/2001, 02/2002
####################################################################

#$IMP_HOME=$ENV{"IMP_ROOT"};

#if($IMP_HOME eq ""){ 
#  print STDERR "\n";
#  print STDERR "You don't have enviornmental variable IMP_ROOT defined\n"; 
#  print STDERR "Please consult your IMPACT expert to setup IMP_ROOT\n"; 
#  exit(0); 
#}

### run impact job to get parameters for the pdb structure

#print ("\n");
#print (" RUN IMPACT ....\n");
#print ("\n");

#unlink<oplsprm.out*>if (-r <oplsprm.out*>);
#$pdbfile = shift(@ARGV);
#($system = $pdbfile) =~ s/\.pdb//;
#system("cp $pdbfile myprot.pdb");
#system("cp oplsprm.inp fort.1");
#system("$IMP_HOME/bin/main1h > $system.log");
#system("cp oplsprm.out $system.out");  
#system("cp impact.tpl $system.tpl");
#$outfile = "$system.out";
#$prmfile = "$system.prm";
#$tplfile = "$system.tpl";
#$xmlfile = "$system.opls.xml";

use Getopt::Std;
$opt_w = 0;
getopts('w') || die "Options wrong for opls2xml.pl!\n";

### get OPLS parameters from output file $system.out

$outfile = shift(@ARGV);
$pdbfile = shift(@ARGV);
($system = $pdbfile) =~ s/\.pdb//;
$prmfile = "$system.prm";
$tplfile = "$system.tpl";
$xmlfile = "$system.opls.xml";

# r_min = 0.5 * 2^(1/6) * sigma
# R_min = 2 * r_min = 2^(1/6) * sigma
$RminSigmaFactor = 1.122462048309370;

print ("\n");
print (" COLLECT IMPACT DATA ....\n");
print ("\n");

open(FILE,"<$outfile") || die "Cannot open output file $outfile\n";
open(PRMOUT,">$prmfile") || die "Cannot open prm file $prmfile\n";

printf(PRMOUT "##################################################\n");
printf(PRMOUT "# Parameter file for system:  $system \n");
printf(PRMOUT "##################################################\n");

printf(PRMOUT "#-------------------------------------------------\n");
printf(PRMOUT "# Functional Forms \n");
printf(PRMOUT "#-------------------------------------------------\n");
printf(PRMOUT "charge                          1 \n");
printf(PRMOUT "vdw                             1 \n");
printf(PRMOUT "vdw_combining_rule              2 \n");
printf(PRMOUT "1,4_charge                      2 \n");
printf(PRMOUT "1,4_vdw                         2 \n");
printf(PRMOUT "1,4_charge_scaling_factor       0.5 \n");
printf(PRMOUT "1,4_vdw_scaling_factor          0.5 \n");
printf(PRMOUT "improper_torsion                2 \n");
printf(PRMOUT "torsional_input                 2 \n");
printf(PRMOUT "Urey-Bradey                     0 \n");
printf(PRMOUT "grouping_method                 0 \n");
printf(PRMOUT "water_model                     0 \n");
printf(PRMOUT "unit_scheme                     1 \n");

# get into the IMPACT/atomtype output section

printf(PRMOUT "#---------------------------------------------------------\n");
printf(PRMOUT "# site  symbol  epsilon  sigma  epsilon14  sigma14 mass charge atomicnum  \n");
printf(PRMOUT "#---------------------------------------------------------\n");

do {
   $_ = <FILE>;
} until(/OPLSAA FORCE FIELD TYPE/ || eof(FILE));
if(eof(FILE)) {
   print "Run $pdbfile not finished.  Will stop this job.\n";
   exit(0);
}
# skip 3 more lines in the output file
foreach $i (1 .. 3) {
   $_ = <FILE>;
}

$_ = <FILE>;
until(/-------/) {
   @fft = split;
   $mass = &get_mass($fft[0]);
   $atomicnum = &get_atomic_number($fft[0]);
   $element = &get_element_name($fft[0]);
   $sigma = $fft[4];
   $epsilon = $fft[5];
   # Rmin = (2^(1/6)) * sigma
   # starting from here, sigma is really Rmin for the stupid BM
   # $sigma = $sigma * $RminSigmaFactor;
   $sigma14 = $sigma;
   $epsilon14 = $epsilon;
   
   printf(PRMOUT "%-6s  %-6s %12.8f  %20.16f  %12.8f  %20.16f  %8.4f %8.4f %4s\n", $fft[0],$fft[2],$epsilon, $sigma, $epsilon14, $sigma14, $mass, $fft[3],$element);
   $_ = <FILE>;
}

# generate bond information

printf(PRMOUT "#-------------------------------------------------\n");
printf(PRMOUT "# bonds            k           r0 \n");
printf(PRMOUT "#-------------------------------------------------\n");

do {
   $_ = <FILE>;
} until(/Stretch List:/ || eof(FILE));
if(eof(FILE)) {
   print "Run $pdbfile not finished.  Will stop this job.\n";
   exit(0);
}
@fft = split;
$nbonds = $fft[3];

# skip 3 more lines in the output file
foreach $i (1 .. 3) {
   $_ = <FILE>;
}

for($i=0; $i<$nbonds; $i++){
   $_ = <FILE>;
   @fft = split;
   printf(PRMOUT "%-6s  %-6s   %8.4f  %8.4f\n", $fft[0],$fft[1],$fft[2],$fft[3]);
}


# generate angle information

printf(PRMOUT "#-------------------------------------------------\n");
printf(PRMOUT "# angles                  k        theta0       ku      ru\n");
printf(PRMOUT "#-------------------------------------------------\n");

do {
   $_ = <FILE>;
} until(/Bending List:/ || eof(FILE));
if(eof(FILE)) {
   print "Run $pdbfile not finished.  Will stop this job.\n";
   exit(0);
}
@fft = split;
$nangles = $fft[3];

# skip 3 more lines in the output file
foreach $i (1 .. 3) {
   $_ = <FILE>;
}

for($i=0; $i<$nangles; $i++){
   $_ = <FILE>;
   @fft = split;
   # set Urey-Bradey constants to zero
   $ku = 0.0;
   $ru = 0.0;
   printf(PRMOUT "%-6s  %-6s  %-6s  %8.4f  %8.4f  %8.4f  %8.4f\n", $fft[0],$fft[1],$fft[2],$fft[3], $fft[4], $ku, $ru);
}

# generate torsion information

printf(PRMOUT "#-------------------------------------------------\n");
printf(PRMOUT "# Proper Torsions                  V0       V1       V2      V3       \n");
printf(PRMOUT "#-------------------------------------------------\n");

do {
   $_ = <FILE>;
} until(/Torsion List:/ || eof(FILE));
if(eof(FILE)) {
   print "Run $pdbfile not finished.  Will stop this job.\n";
   exit(0);
}
@fft = split;
$nproptors = $fft[5];
$nimptors = $fft[8];

# skip 3 more lines in the output file
foreach $i (1 .. 3) {
   $_ = <FILE>;
}

for($i=0; $i<$nproptors; $i++){
   $_ = <FILE>;
   @fft = split;
   printf(PRMOUT "%-6s  %-6s  %-6s  %-6s  %8.4f %8.4f %8.4f %8.4f\n", $fft[0],$fft[1],$fft[2],$fft[3], $fft[4], $fft[5], $fft[6], $fft[7]);
}

printf(PRMOUT "#-------------------------------------------------\n");
printf(PRMOUT "# Improper Torsions               V0       V1       V2       V3       \n");
printf(PRMOUT "#-------------------------------------------------\n");

for($i=0; $i<$nimptors; $i++){
   $_ = <FILE>;
   @fft = split;
   printf(PRMOUT "%-6s  %-6s  %-6s  %-6s  %8.4f %8.4f %8.4f %8.4f\n", $fft[0],$fft[1],$fft[2],$fft[3], $fft[4], $fft[5], $fft[6], $fft[7]);
}
printf(PRMOUT "#-------------------------------------------------\n");
printf(PRMOUT "# 1,4 vdw symbol1 symbol2   sigma    epsilon   \n");
printf(PRMOUT "#-------------------------------------------------\n");

printf(PRMOUT "#-------------------------------------------------\n");
printf(PRMOUT "# Explicit group definition              \n");
printf(PRMOUT "#-------------------------------------------------\n");

# get into the IMPACT template file to get nbexclusion list



### At the end print out definitions for Fuctional Forms

printf(PRMOUT "##################################################\n");
printf(PRMOUT "# Definitions of Functional Forms                 \n"); 
printf(PRMOUT "##################################################\n");
printf(PRMOUT "## charge      1: fixed charge, 2: fluctuating charge \n");
printf(PRMOUT "## vdw         1: 6-12   \n");
printf(PRMOUT "## vdw combining rule   1: CHARMm, 2: OPLSAA \n");
printf(PRMOUT "## 1,4 charge           1: excluded, 2: scaling, 3: specific parms \n");
printf(PRMOUT "## 1,4 vdw              1: excluded, 2: scaling, 3: specific parms \n");
printf(PRMOUT "## 1,4 charge scaling factor       scaling factor (0.0 - 1.0) \n");
printf(PRMOUT "## 1,4 vdw scaling factor          scaling factor (0.0 - 1.0) \n");
printf(PRMOUT "## improper torsion     1: CHARMm, 2: OPLSAA  \n");
printf(PRMOUT "## torsional input      1: CHARMm, 2: OPLSAA  \n");
printf(PRMOUT "## Urey-Bradey          0: None,   1: Yes     \n");
printf(PRMOUT "## grouping method      0: atoms, 1: residue, 2: molecule, 3: explicit \n");
printf(PRMOUT "## water model          0: none, 1: TIP3P, 2: TIP4P, 3: TIP5P \n");
printf(PRMOUT "## unit scheme          1: kcal/mol, 2: kJ/mol \n");
printf(PRMOUT "##################################################\n");

close(FILE);
close(PRMOUT);



### Writing the XML file from the ASCII prm file
### This part modified from RSG's txt2xml.pl

print ("\n");
print (" WRITING XML FILE ....\n");
print ("\n");


$unknownMode = 0;
$headerMode = 1;
$siteMode = 2;
$bondMode = 3;
$angleMode = 4;
$torsionMode = 5;
$improperMode = 6;

@mode = ("unknown", "header", "site", "bond", "angle", "normal torsion", "improper torsion");

@listTag = ("invalid", "header", "sitelist", "bondlist", "anglelist",
	    "torsionlist", "improperlist");

%headerTag = ('charge', "charge",
	      'vdw', "vdw",
	      'vdw_combining_rule', "vdwcombine",
	      '1,4_charge', "charge14",
	      '1,4_charge_scaling_factor', "charge14scale",
	      '1,4_vdw', "vdw14",
	      '1,4_vdw_scaling_factor', "vdw14scale",
	      'improper_torsion', "improper",
	      'torsional_input', "torsioninput",
	      'Urey-Bradey', "ureybradley",
	      'grouping_method', "grouping",
	      'water_model', "water",
	      'unit_scheme', "units");

open(PRMIN,"<$prmfile") || die "Cannot open parameter file $prmfile\n";
open(PDBIN,"<$pdbfile") || die "Cannot open PDB file $pdbfile\n";
open(XMLOUT,">$xmlfile") || die "Cannot open XML file $xmlfile\n";

### Read in atom name, residue, ... information from .pdb file

# add in any columns needed in PDB later if needed
$pdbsitecount = 0;   
$watercount = 0;     
$wateratomcount = 0;
$Hatomcount = $Oatomcount = 0;

$TotalResidues =0;
$ResidueName[$TotalResidues] = "UNK";
$prevres = -9999;

while (<PDBIN>) {
   if((/^ATOM  /) || (/^HETATM/)){
     chop;
     $pdbsitecount++;
     $atomname[$pdbsitecount]    = substr($_,12,4);
     $atomname[$pdbsitecount]    =~ s/ //g;    
    
     $residuename[$pdbsitecount] = substr($_,17,3);
     $residuename[$pdbsitecount] =~ s/ //g;     

     #$chainname[$pdbsitecount]  = substr($_,21,1);

     $residuenum[$pdbsitecount]  = substr($_,23,4);
     $residuenum[$pdbsitecount]  =~ s/ //g;     

     #chop;
     #split;
     #$pdbsitecount++;
     #$atomname[$pdbsitecount]    = $_[2];
     #$residuename[$pdbsitecount] = $_[3];
     #$residuenum[$pdbsitecount]  = $_[4];

     # figure out total residues and residue names for 
     # chem component and monomer info needed later

     #chop;
     #split;
     #$pdbsitecount++;
     #$atomname[$pdbsitecount]    = $_[2];
     #$residuename[$pdbsitecount] = $_[3];
     #$residuenum[$pdbsitecount]  = $_[4];

     # figure out total residues and residue names for 
     # chem component and monomer info needed later
     if ($residuenum[$pdbsitecount] != $prevres){
       $prevres = $residuenum[$pdbsitecount];
       $TotalResidues++;
       $ResidueName[$TotalResidues] =  $residuename[$pdbsitecount];
       # handle chain ID and name more generally later
       $chainID[$TotalResidues] = 1;
     }
     # this residue number is garaunteed to be from 1 to N   
     $ResidueNumber[$pdbsitecount]  = $TotalResidues;
 
     # temporary now
     $molecule[$pdbsitecount] = 1;

     # figuring out waters

     $_ = $residuename[$pdbsitecount];
     if ( (/SPC/) || (/HOH/) || (/TIP3/) || (/T3P/) ){
       # found water, assuming 3 atoms of one water stay together
       if ($wateratomcount % 3 == 0) {$watercount++;}
       $wateratomcount++;
       $_ = $atomname[$pdbsitecount];
       if (/1HW/ || /1HO/ || /HO1/ || /H1/) {
          $waterH1[$watercount] = $pdbsitecount;
          $Hatomcount++;
       }
       elsif (/2HW/ || /2HO/ || /HO2/ || /H2/) {
          $waterH2[$watercount] = $pdbsitecount;
          $Hatomcount++;
       }
       elsif (/OW/  || /OH/  || /O/)  {
          $waterO[$watercount] = $pdbsitecount;
          $Oatomcount++;
       }
     }
   }
}
close (PDBIN);

if($Hatomcount != 2 * $Oatomcount){ 
  die "Water H atoms are not twice the O atoms, check your pdb file!\n";
}
$waterbondcount = 2*$watercount;
$wateranglecount = $watercount;


### Read in site/bond/angle/torsion information from .prm file

$mode = $unknownMode;
$oldMode = $unknownMode;
$sitecount = $bondcount = $anglecount = $torsioncount = $imptorscount = 0;
$headcount = 0;

while (<PRMIN>) {

    if (m/^\# Functional Forms/) {
	$oldMode = $mode;
	$mode = $headerMode;
	next;
    } elsif (m/^\# site /) {
	$oldMode = $mode;
	$mode = $siteMode;
	next;
    } elsif (m/^\# bonds /) {
	$oldMode = $mode;
	$mode = $bondMode;
	next;
    } elsif (m/^\# angles /) {
	$oldMode = $mode;
	$mode = $angleMode;
	next;
    } elsif (m/^\# Proper Torsions /) {
	$oldMode = $mode;
	$mode = $torsionMode;
	next;
    } elsif (m/^\# Improper Torsions /) {
	$oldMode = $mode;
	$mode = $improperMode;
	next;
    } elsif (m/^\#/) {
	# comment line, do nothing
	next;
    } else {
	# other line
	# print STDERR "mode = $mode[$mode]\n";
	# print STDERR $_;
    }

    if ($mode == $unknownMode) {
	next;
#	print STDERR "ILLEGAL MODE = $mode[$unknown]\n";
	exit;
    }
    if ($oldMode <=> $mode) { # time for a new list record
	if ($oldMode <=> $unknownMode) {
	    #print XMLOUT"</$listTag[$oldMode]>\n";
	}
	#print XMLOUT"<$listTag[int($mode)]>\n";
	$oldMode = $mode;
    }

    chop;
    split;
    if ($mode == $headerMode) {
	$headcount++;
	$headname[$headcount] = $_[0];
	$headvale[$headcount] = $_[1];
    } elsif ($mode == $siteMode) {
	$sitecount++;
	$siteID[$sitecount]      = $_[0];
	$symbol[$sitecount]      = $_[1];
	$epsilon[$sitecount]     = $_[2];
	$sigma[$sitecount]       = $_[3];
	$epsilon14[$sitecount]   = $_[4];
	$sigma14[$sitecount]     = $_[5];
	$mass[$sitecount]        = $_[6];
	$charge[$sitecount]      = $_[7];
	$element[$sitecount]     = $_[8];
    } elsif ($mode == $bondMode) {
	$bondcount++;
	$bond_site1[$bondcount] = &get_id($_[0]);
	$bond_site2[$bondcount] = &get_id($_[1]);
	$bond_k[$bondcount]     = $_[2];
	$bond_r0[$bondcount]    = $_[3];
    } elsif ($mode == $angleMode) {
	$anglecount++;
	$angle_site1[$anglecount]  = &get_id($_[0]);
	$angle_site2[$anglecount]  = &get_id($_[1]);
	$angle_site3[$anglecount]  = &get_id($_[2]);
	$angle_k[$anglecount]      = $_[3];
	$angle_theta0[$anglecount] = $_[4];
    } elsif ($mode == $torsionMode) {
	if (scalar(@_) < 8) {
	    print XMLOUTSTDERR "Illegal torsion record\n";
	    exit;
	}
        for($i=0; $i<4; $i++){
          $Vn = $_[$i+4];      # V0 starts at $_[4]          
          $n = $i;
          $phi0 = 0.0;
          if($n == 2) { $phi0 = 180.0; }
          if (($n == 0) && (abs($Vn) < 1.0e-6)) {next;}
          if (($n == 1) && (abs($Vn) < 1.0e-6)) {next;}
          if (($n == 2) && (abs($Vn) < 1.0e-6)) {next;}	  
          $torsioncount++;
	  $torsion_site1[$torsioncount] = &get_id($_[0]);
	  $torsion_site2[$torsioncount] = &get_id($_[1]);
	  $torsion_site3[$torsioncount] = &get_id($_[2]);
	  $torsion_site4[$torsioncount] = &get_id($_[3]);
   	  $torsion_Vn[$torsioncount]    = $Vn;
   	  $torsion_n[$torsioncount]     = $n;
   	  $torsion_phi0[$torsioncount]  = $phi0;
        }

    } elsif ($mode == $improperMode) {
	if (scalar(@_) < 8) {
	    print STDERR "Illegal improper torsion record\n";
	    exit;
	}

        for($i=0; $i<4; $i++){
          $Vn = $_[$i+4];      # V0 starts at $_[4]          
          $n = $i;
          $phi0 = 0.0;
          if($n == 2) { $phi0 = 180.0; }          
          if($Vn < -1.0e-6 || $Vn >1.0e-6){
            $imptorscount++;
            $imptors_site1[$imptorscount] = &get_id($_[0]);
	    $imptors_site2[$imptorscount] = &get_id($_[1]);
	    $imptors_site3[$imptorscount] = &get_id($_[2]);
	    $imptors_site4[$imptorscount] = &get_id($_[3]);
   	    $imptors_Vn[$imptorscount]    = $Vn;
   	    $imptors_n[$imptorscount]     = $n;
   	    $imptors_phi0[$imptorscount]  = $phi0;
          }
        }
    } else {
	print STDERR "Illegal mode = $mode\n";
	exit;
    }

}
close(PRMIN);

# safety check

if ($pdbsitecount != $sitecount){
   print "Number of atoms in the PDB file and IMPACT output file not equal!\n";
   exit(0);
}

### reduce atom names 

#
# UniqueAtomNames[]   - holds the unique atom names 
# AtomNameType[]      - holds the numerical name type for each atom 
#

$TotalAtomNameTypes = 0;
$UniqueAtomNames[$TotalAtomNameTypes] = " ";
$AtomNameType[$TotalAtomNameTypes] = 0;

for($i=1; $i <= $sitecount; $i++){
  $name = convertatomtag($atomname[$i],$residuename[$i]);
  $atomname[$i] = $name;
  # reduce atomname and also residuename is no longer used but I still keep the code
  $pos = &check_position($name,$TotalAtomNameTypes,\@UniqueAtomNames);
  #print ("New symbol: $name, position: $pos\n");
  if ($pos != -1){
    $AtomNameType[$i] = $pos;
  }
  else{
    $TotalAtomNameTypes++;
    $UniqueAtomNames[$TotalAtomNameTypes] = $name;
    $AtomNameType[$i] = $TotalAtomNameTypes;
  }
}


### reduce residue names 

#
# UniqueResidueNames[]   - holds the unique residue names 
# ResidueNameType[]      - holds the numerical residue type for each atom 
#

# to reduce to residues first, then reduce to unique residues

$TotalResidueTypes = 0;
$UniqueResidueNames[$TotalResidueTypes] = "UNK";
$ResidueNameType[$TotalResidueTypes] = 0;

for($i=1; $i <= $TotalResidues; $i++){
  $name = convertresiduetag($ResidueName[$i]);
  $ResidueName[$i] = $name;
  $pos = &check_position($name,$TotalResidueTypes,\@UniqueResidueNames);
  #print ("New symbol: $name, position: $pos\n");
  if ($pos != -1){
    $ResidueNameType[$i] = $pos;
  }
  else{
    $TotalResidueTypes++;
    $UniqueResidueNames[$TotalResidueTypes] = $name;
    $ResidueNameType[$i] = $TotalResidueTypes;
  }
}

### reduce LJ types

#
# LJTypeList[]   - holds the unique atom type symbols (unique LJ param)
# atomLJType[]   - holds the LJ numerical type for each atom
#

$TotalLJTypes = 0;
$LJTypeList[$TotalLJTypes] = " ";
$epsilonLJType[$TotalLJTypes] = 0.0;
$epsilon14LJType[$TotalLJTypes] = 0.0;
$sigmaLJType[$TotalLJTypes] = 0.0;
$sigma14LJType[$TotalLJTypes] = 0.0;

for($i=1; $i <= $sitecount; $i++){
  $LJt = $symbol[$i];
  $pos = &check_position($LJt,$TotalLJTypes,\@LJTypeList);
  #print ("New symbol: $LJt, position: $pos\n");
  if ($pos != -1){
    $atomLJType[$i] = $pos;
  }
  else{
    $TotalLJTypes++;
    $LJTypeList[$TotalLJTypes] = $LJt;

    $epsilonLJType[$TotalLJTypes] = $epsilon[$i];
    $epsilon14LJType[$TotalLJTypes] = $epsilon14[$i];
    $sigmaLJType[$TotalLJTypes] = $sigma[$i];
    $sigma14LJType[$TotalLJTypes] = $sigma14[$i];

    $atomLJType[$i] = $TotalLJTypes;
  }
}
  
#for($i=1; $i<= $TotalLJTypes; $i++){
#   print ("check: $i, $LJTypeList[$i]\n");
#}

#########################################################
#########################################################
###
### print out XML file ....
###
#########################################################
#########################################################

#################
# dtd header info
#################


print XMLOUT "<?xml version='1.0' encoding='US-ASCII' standalone='no' ?>\n";
print XMLOUT "<!DOCTYPE ffparams [\n";
print XMLOUT "<!ELEMENT ffparams (header_parameter_list, (data_list)+,\n";
print XMLOUT "(udf_invocation_table)?, (site_tuple_list | param_tuple_list)*,\n";
print XMLOUT "(pair_list)*, (group_list)*)>\n\n";

print XMLOUT "<!-- The header parameter list contains per system information.  Each -->\n";
print XMLOUT "<!-- parameter has associated name, type, and symbolic_constant -->\n";
print XMLOUT "<!-- attributes.  If symbolic_constant=\"true\" then it is intended that -->\n";
print XMLOUT "<!-- the parameter so labeled is to be treated as a symbolic constant -->\n";
print XMLOUT "<!-- for use by downstream applications-->\n";
print XMLOUT "<!ELEMENT header_parameter_list (header_parameter)+>\n";
print XMLOUT "<!ELEMENT header_parameter (#PCDATA)>\n";
print XMLOUT "<!ATTLIST header_parameter param_id ID #REQUIRED>\n";
print XMLOUT "<!ATTLIST header_parameter type (char | double | int) \"char\">\n";
print XMLOUT "<!ATTLIST header_parameter symbolic_constant (true | false) \"false\">\n\n";

print XMLOUT "<!-- The data_list contains a list of type_ids that are used -->\n";
print XMLOUT "<!-- for a variety of purposes, including molecule types and molecule -->\n";
print XMLOUT "<!-- instances as well as LJ types.   These types may have -->\n";
print XMLOUT "<!-- parameter values associated with them which are defined in the -->\n";
print XMLOUT "<!-- type_parameter_list. Information about what type_id is -->\n";
print XMLOUT "<!-- bound to a particular site_id must be conveyed via a -->\n";
print XMLOUT "<!-- site_parameter_ref. It is required that type_ids consist of the -->\n";
print XMLOUT "<!-- type_class string with an underscore and number appended -->\n";
print XMLOUT "<!ELEMENT data_list (data_title, data_parameter_list, (data_record)+)>\n";
print XMLOUT "<!ATTLIST data_list data_class_prepend ID #REQUIRED>\n";
print XMLOUT "<!ELEMENT data_title (#PCDATA)>\n";
print XMLOUT "<!ELEMENT data_parameter_list (data_parameter_spec)*>\n";
print XMLOUT "<!ATTLIST data_parameter_list param_prepend ID #REQUIRED>\n";
print XMLOUT "<!ELEMENT data_parameter_spec (#PCDATA)>\n";
print XMLOUT "<!ATTLIST data_parameter_spec param_id ID #REQUIRED>\n";
print XMLOUT "<!ATTLIST data_parameter_spec type (char | double | int | idref) \"char\">\n";
print XMLOUT "<!ATTLIST data_parameter_spec ref_prepend IDREF #IMPLIED>\n";
print XMLOUT "<!ELEMENT data_record ((data_parameter | data_parameter_ref))*>\n";
print XMLOUT "<!ATTLIST data_record data_id ID #REQUIRED>\n";
print XMLOUT "<!ELEMENT data_parameter (#PCDATA)>\n";
print XMLOUT "<!ATTLIST data_parameter param_ref IDREF #REQUIRED>\n";
print XMLOUT "<!ELEMENT data_parameter_ref EMPTY>\n";
print XMLOUT "<!ATTLIST data_parameter_ref param_ref IDREF #REQUIRED>\n";
print XMLOUT "<!ATTLIST data_parameter_ref ref_ptr IDREF #REQUIRED>\n";

print XMLOUT "<!-- The invocation table contains a list of all the user defined -->\n";
print XMLOUT "<!-- functions required for this system and pointers to tuples of -->\n";
print XMLOUT "<!-- sites and parameters required for each UDF   -->\n";
print XMLOUT "<!ELEMENT udf_invocation_table (udf_invocation_rec)*>\n";
print XMLOUT "<!ELEMENT udf_invocation_rec EMPTY>\n";
print XMLOUT "<!ATTLIST udf_invocation_rec udf_id ID #REQUIRED>\n";
print XMLOUT "<!ATTLIST udf_invocation_rec site_tuple_ref IDREF #REQUIRED>\n";
print XMLOUT "<!ATTLIST udf_invocation_rec param_tuple_ref IDREF #IMPLIED>\n\n";

print XMLOUT "<!-- The site tuple list contains a collection of site_id tuples that are -->\n";
print XMLOUT "<!-- used by one or more udfs.  The order of the tuples in this list -->\n";
print XMLOUT "<!-- must correspond to the order of the tuples in the corresponding -->\n";
print XMLOUT "<!-- param_tuple_list -->\n";
print XMLOUT "<!ELEMENT site_tuple_list (site_tuple)+>\n";
print XMLOUT "<!ATTLIST site_tuple_list id ID #REQUIRED>\n";
print XMLOUT "<!ELEMENT site_tuple (site)+>\n";
print XMLOUT "<!ELEMENT site EMPTY>\n";
print XMLOUT "<!ATTLIST site site_ref IDREF #REQUIRED>\n";
print XMLOUT "<!ATTLIST site site_ordinal CDATA #REQUIRED>\n\n";

print XMLOUT "<!-- The param tuple list contains a collection of parameter tuples -->\n";
print XMLOUT "<!-- that are used by one or more udfs.  The order of the tuples in -->\n";
print XMLOUT "<!-- this list must correspond to the order of the tuples in the -->\n";
print XMLOUT "<!-- corresponding site_tuple_list.  This list also has the usual -->\n";
print XMLOUT "<!-- parameter specification block at the beginning.  The element -->\n";
print XMLOUT "<!-- value of the param_spec element is the name of the parameter -->\n";
print XMLOUT "<!ELEMENT param_tuple_list (param_spec_list, (param_tuple)+)>\n";
print XMLOUT "<!ATTLIST param_tuple_list id ID #REQUIRED>\n";
print XMLOUT "<!ELEMENT param_spec_list (param_spec)+>\n";
print XMLOUT "<!ATTLIST param_spec_list param_prepend NMTOKEN #REQUIRED>\n";
print XMLOUT "<!ELEMENT param_spec (#PCDATA)>\n";
print XMLOUT "<!ATTLIST param_spec param_id ID #REQUIRED>\n";
print XMLOUT "<!ATTLIST param_spec type (double | int) \"double\">\n";
print XMLOUT "<!ELEMENT param_tuple (param)+>\n";
print XMLOUT "<!ELEMENT param (#PCDATA)>\n";
print XMLOUT "<!ATTLIST param param_ref IDREF #REQUIRED>\n\n";

print XMLOUT "<!-- The pair list contains a list of pair interaction parameters for -->\n";
print XMLOUT "<!-- each pair of the associated types-->\n";
print XMLOUT "<!ELEMENT pair_list (pair_parameter_list, (pair_record)+)>\n";
print XMLOUT "<!ATTLIST pair_list type_class_prepend IDREF #REQUIRED>\n";
print XMLOUT "<!ELEMENT pair_parameter_list (pair_parameter_spec)+>\n";
print XMLOUT "<!ATTLIST pair_parameter_list param_prepend ID #REQUIRED>\n";
print XMLOUT "<!ELEMENT pair_parameter_spec (#PCDATA)>\n";
print XMLOUT "<!ATTLIST pair_parameter_spec param_id ID #REQUIRED>\n";
print XMLOUT "<!ATTLIST pair_parameter_spec type (char | double | int) \"char\">\n";
print XMLOUT "<!ELEMENT pair_record (pair_parameter)+>\n";
print XMLOUT "<!ATTLIST pair_record type_ref_1 IDREF #REQUIRED>\n";
print XMLOUT "<!ATTLIST pair_record type_ref_2 IDREF #REQUIRED>\n";
print XMLOUT "<!ELEMENT pair_parameter (#PCDATA)>\n";
print XMLOUT "<!ATTLIST pair_parameter param_ref IDREF #REQUIRED>\n\n";

print XMLOUT "<!-- User defined groups contain group information and a list of group -->\n";
print XMLOUT "<!-- members specified by site_id-->\n";
print XMLOUT "<!ELEMENT group_list (group_info, (group_member)+)>\n";
print XMLOUT "<!ATTLIST group_list group_id ID #REQUIRED>\n";
print XMLOUT "<!ATTLIST group_list group_class CDATA #REQUIRED>\n";
print XMLOUT "<!ELEMENT group_info (#PCDATA)>\n";
print XMLOUT "<!ELEMENT group_member EMPTY>\n";
print XMLOUT "<!ATTLIST group_member site_ref IDREF #REQUIRED>\n";
print XMLOUT "]>\n";



print XMLOUT "<ffparams>\n";

#################
# header info
#################

print XMLOUT  "<header_parameter_list>\n";
print XMLOUT  "<header_parameter param_id=\"ff_family\" type=\"char\" symbolic_constant=\"false\">OPLSAA</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"ff_spec\" type=\"char\" symbolic_constant=\"false\">OPLSAA</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"charge14\" type=\"int\" symbolic_constant=\"true\">1</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"charge14scale\" type=\"double\" symbolic_constant=\"true\">0.5</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"lj14\" type=\"int\" symbolic_constant=\"true\">1</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"lj14scale\" type=\"double\" symbolic_constant=\"true\">0.5</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"torsioninput\" type=\"int\" symbolic_constant=\"false\">1</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"improper\" type=\"int\" symbolic_constant=\"false\">1</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"ureybradley\" type=\"int\" symbolic_constant=\"false\">0</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"grouping\" type=\"int\" symbolic_constant=\"false\">1</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"water\" type=\"char\" symbolic_constant=\"false\">SPC</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"units\" type=\"char\" symbolic_constant=\"false\">CHEM</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"ChargeConversion\" type=\"double\" symbolic_constant=\"true\">SciConst::ImpactChargeConversion</header_parameter>\n";
print XMLOUT  "<header_parameter param_id=\"TimeConversionFactor\" type=\"double\" symbolic_constant=\"true\">SciConst::OldTimeConversion</header_parameter>\n";
print XMLOUT  "</header_parameter_list>\n";
   
#################
# molecule type
#################

@mol_type = ("protein", "carbohydrate", "dna", "rna", "ligand", "other_polymer", "lipid", "cofactor", "ligand", "solvent", "salt", "other");
#print XMLOUT "\n";
#print XMLOUT "<data_list data_class_prepend=\"mt_\">\n";
#print XMLOUT " <data_title>molecule_type</data_title>\n";
#print XMLOUT " <data_parameter_list param_prepend=\"mtp_\">\n";
#print XMLOUT "    <data_parameter_spec param_id=\"mtp_1\" type=\"char\">class</data_parameter_spec>\n";
#print XMLOUT " </data_parameter_list>\n";

#$i=1;
#foreach $mt (@mol_type){
#   print XMLOUT " <data_record data_id=\"mt_$i\">\n";
#   print XMLOUT "    <data_parameter param_ref=\"mtp_1\">$mt</data_parameter>\n";
#   print XMLOUT " </data_record>\n";
#   $i++;
#}
#print XMLOUT "</data_list>\n";

#################
# molecule name
#################

print XMLOUT "\n";
print XMLOUT "<data_list data_class_prepend=\"mn_\">\n";
print XMLOUT "<data_title>molecule_name</data_title>\n";
print XMLOUT " <data_parameter_list param_prepend=\"mnp_\">\n";
print XMLOUT "   <data_parameter_spec param_id=\"mnp_1\" type=\"char\">name</data_parameter_spec>\n";
print XMLOUT "   <data_parameter_spec param_id=\"mnp_2\" type=\"char\">type</data_parameter_spec>\n";
print XMLOUT " </data_parameter_list>\n";

#temporary, need to add user option later to assign names
$molecules = 1;
$moleculeType[1] = "protein";
$myprotein_name = "myprotein";
for($i=1; $i <= $molecules; $i++){
   print XMLOUT " <data_record data_id=\"mn_$i\">\n";
   print XMLOUT "    <data_parameter param_ref=\"mnp_1\">$myprotein_name</data_parameter>\n";
   print XMLOUT "    <data_parameter param_ref=\"mnp_2\">$moleculeType[$i]</data_parameter>\n";
   print XMLOUT " </data_record>\n";
}
print XMLOUT " </data_list>\n";


#################
# chemical component
#################

%chem_comp = ("ALA", "Alanine",
              "ARG", "Arginine",
              "ARD", "Neutral Arginine",
              "ASH", "Neutral Asparic acid",
              "ASN", "Asparagine",
              "ASP", "Aspararic acid",
              "CYS", "Cysteine",
              "CYD", "Neutral Cysteine",
              "CYX", "S-S bridged Cystenine",
              "GLH", "Neutral Glutamic acid",
              "GLN", "Glutamine",
              "GLU", "Glutamic acid",
              "GLY", "Glycine",
              "HIH", "Charged Histidine",
              "HIS", "Histidine",
              "HIE", "Histidine with proton on NE2",
              "ILE", "Isoleucine",
	      "LEU", "Leucine",
              "LYD", "Neutral Lysine",
              "LYS", "Lysine",
              "MET", "Methionine",
              "PHE", "Phenylalanine",
              "PRO", "Proline",
              "SER", "Serine",
              "SED", "Charged Serine",
              "THR", "Threonine",
              "TRP", "Tryptophan",
              "TYR", "Tyrosine",
              "TYD", "Charged Tyrosine",
              "VAL", "Valine",
	      "HOH", "water",
	      "TIP3", "TIP3P water",
	      "TIP4", "TIP4P water",
	      "TIP5", "TIP5P water",
	      "SPC", "SPC water",
	      "SPCE", "SPCE water",
	      "T4FQ", "TIP4PFQ water",
	      "POL5", "POL5 water",
              "NUSA", "Deoxyribose adenosine 3',5' monophosphate",
              "NUSC", "Deoxyribose cytidine 3',5' monophosphate",
              "NUSG", "Deoxyribose guanosine 3',5' monophosphate",
              "NUST", "Deoxyribose thymidine 3',5' monophosphate",
              "RNUA", "Ribose adenosine 3',5' monophosphate",
              "RNUC", "Ribose cytidine 3',5' monophosphate",
              "RNUG", "Ribose guanosine 3',5' monophosphate",
              "RNUU", "Ribose uracil 3',5' monophosphate"
               );

#print XMLOUT "\n";
#print XMLOUT "<data_list data_class_prepend=\"cc_\">\n";
#print XMLOUT "<data_title>chemical_component</data_title>\n";
#print XMLOUT "<data_parameter_list param_prepend=\"ccp_\">\n";
#print XMLOUT "<data_parameter_spec param_id=\"ccp_1\" type=\"char\">id</data_parameter_spec>\n";
#print XMLOUT "<data_parameter_spec param_id=\"ccp_2\" type=\"char\">name</data_parameter_spec>\n";
#print XMLOUT "</data_parameter_list>\n";


#for($i=1; $i <= $TotalResidueTypes; $i++){
#   print XMLOUT "    <data_record data_id=\"cc_$i\">\n";
#   print XMLOUT "      <data_parameter param_ref=\"ccp_1\" >$UniqueResidueNames[$i]</data_parameter>\n";
#   print XMLOUT "      <data_parameter param_ref=\"ccp_2\" >$chem_comp{$UniqueResidueNames[$i]}</data_parameter>\n";
#   print XMLOUT "    </data_record>\n";
#}
#print XMLOUT "</data_list>\n";

#################
# chain
#################

print XMLOUT "\n";
print XMLOUT "<data_list data_class_prepend=\"ch_\">\n";
print XMLOUT "<data_title>chain</data_title>\n";
print XMLOUT "<data_parameter_list param_prepend=\"chp_\">\n";
print XMLOUT "<data_parameter_spec param_id=\"chp_1\" type=\"char\">name</data_parameter_spec>\n";
print XMLOUT "</data_parameter_list>\n";

# temporary for chainname
$TotalChainTypes = 1;
for ($i=1; $i<=$TotalChainTypes; $i++) {$chainname[$i] = "A";};
for($i=1; $i <= $TotalChainTypes; $i++){
   print XMLOUT "    <data_record data_id=\"ch_$i\">\n";
   print XMLOUT "      <data_parameter param_ref=\"chp_1\">$chainname[$i]</data_parameter>\n";

   print XMLOUT "    </data_record>\n";
}
print XMLOUT "</data_list>\n";



#################
# chemical component instance
#################

print XMLOUT "\n";
print XMLOUT "<data_list data_class_prepend=\"cci_\">\n";
print XMLOUT "<data_title>chemical_component_instance</data_title>\n";
print XMLOUT "<data_parameter_list param_prepend=\"ccip_\">\n";
print XMLOUT "<data_parameter_spec param_id=\"ccip_1\" type=\"char\">cc_id</data_parameter_spec>\n";
print XMLOUT "</data_parameter_list>\n";


for($i=1; $i <= $TotalResidues; $i++){
   print XMLOUT "    <data_record data_id=\"cci_$i\">\n";
   print XMLOUT "      <data_parameter param_ref=\"ccip_1\">$ResidueName[$i]</data_parameter>\n";
   print XMLOUT "    </data_record>\n";
}
print XMLOUT "</data_list>\n";


#################
# monomer instance
#################

print XMLOUT "\n";
print XMLOUT "<data_list data_class_prepend=\"moni_\">\n";
print XMLOUT "<data_title>monomer_instance</data_title>\n";
print XMLOUT "<data_parameter_list param_prepend=\"monip_\">\n";
print XMLOUT "<data_parameter_spec param_id=\"monip_1\" type=\"idref\" ref_prepend=\"ch_\">chain_id</data_parameter_spec>\n";
print XMLOUT "<data_parameter_spec param_id=\"monip_2\" type=\"idref\" ref_prepend=\"cci_\">cc_instance_id</data_parameter_spec>\n";
print XMLOUT "</data_parameter_list>\n";

# temporarily set monomers = residues, which is true for proteins
$TotalMonomers = $TotalResidues;
for($i=1; $i <= $TotalMonomers; $i++){
   print XMLOUT "    <data_record data_id=\"moni_$i\">\n";
   print XMLOUT "      <data_parameter_ref param_ref=\"monip_1\" ref_ptr=\"ch_$chainID[$i]\"/>\n";
   print XMLOUT "      <data_parameter_ref param_ref=\"monip_2\" ref_ptr=\"cci_$i\"/>\n";
   print XMLOUT "    </data_record>\n";
}
print XMLOUT "</data_list>\n";



#################
# molecule instance
#################

print XMLOUT "\n";
print XMLOUT "<data_list data_class_prepend=\"mi_\">\n";
print XMLOUT "<data_title>molecule_instance</data_title>\n";
print XMLOUT " <data_parameter_list param_prepend=\"mip_\">\n";
print XMLOUT "    <data_parameter_spec param_id=\"mip_1\" type=\"idref\" ref_prepend=\"mn_\">molecule_name</data_parameter_spec>\n";
print XMLOUT " </data_parameter_list>\n";

for($i=1; $i <= $molecules; $i++){
   print XMLOUT " <data_record data_id=\"mi_$i\">\n";
   print XMLOUT "   <data_parameter_ref param_ref=\"mip_1\" ref_ptr=\"mn_$i\"/>\n";
   print XMLOUT " </data_record>\n";
}
print XMLOUT " </data_list>\n";


#################
# atom name (tag)
#################

#print XMLOUT "\n";
#print XMLOUT "<data_list data_class_prepend=\"at_\">\n";
#print XMLOUT "<data_title>atom_tag</data_title>\n";
#print XMLOUT "<data_parameter_list param_prepend=\"atp_\">\n";
#print XMLOUT "<data_parameter_spec param_id=\"atp_1\" type=\"char\">atom_tag</data_parameter_spec>\n";
#print XMLOUT "</data_parameter_list>\n";

#for ($i=1; $i <= $TotalAtomNameTypes; $i++){
#   print XMLOUT "    <data_record  data_id=\"at_$i\"> \n";
#   print XMLOUT "      <data_parameter param_ref=\"atp_1\">$UniqueAtomNames[$i]</data_parameter>\n";
#   print XMLOUT "    </data_record>\n";
#}
#print XMLOUT "</data_list>\n";

#################
# LJ type list
#################

#print XMLOUT "\n";
#print XMLOUT "<data_list data_class_prepend=\"lj_\">\n";
#print XMLOUT "<data_title>Lennard_Jones_Types</data_title>\n";
#print XMLOUT "<data_parameter_list param_prepend=\"ljt_\">\n";
#print XMLOUT "</data_parameter_list>\n";

#for($i=1; $i<=$TotalLJTypes; $i++){
#   print XMLOUT "  <data_record data_id=\"lj_$i\"></data_record>\n";
#}
#print XMLOUT "</data_list>\n";

#################
# LJ14 type list
#################

#print XMLOUT "\n";
#print XMLOUT "<data_list data_class_prepend=\"lj14_\">\n";
#print XMLOUT "<data_title>Lennard_Jones_14_Types</data_title>\n";
#print XMLOUT "<data_parameter_list param_prepend=\"ljt14_\">\n";
#print XMLOUT "</data_parameter_list>\n";

#for($i=1; $i<=$TotalLJTypes; $i++){
#   print XMLOUT "  <data_record data_id=\"lj14_$i\"></data_record>\n";
#}
#print XMLOUT "</data_list>\n";

#################
# site list
#################

print XMLOUT "\n";
print XMLOUT "<data_list data_class_prepend=\"site_\">\n";
print XMLOUT "<data_title>site_list</data_title>\n";
print XMLOUT "  <data_parameter_list param_prepend=\"sp_\">\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_1\" type=\"double\">mass</data_parameter_spec>\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_2\" type=\"double\">charge</data_parameter_spec>\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_3\" type=\"int\">mol_instance_id</data_parameter_spec>\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_4\" type=\"int\">cc_instance_id</data_parameter_spec>\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_5\" type=\"char\">atom_tag</data_parameter_spec>\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_6\" type=\"double\">epsilon</data_parameter_spec>\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_7\" type=\"double\">rmin</data_parameter_spec>\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_8\" type=\"double\">epsilon14</data_parameter_spec>\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_9\" type=\"double\">rmin14</data_parameter_spec>\n";
print XMLOUT "     <data_parameter_spec param_id=\"sp_10\" type=\"char\">element</data_parameter_spec>\n";
print XMLOUT "  </data_parameter_list>\n";

# for waters, print out NULL's later
for($i=1; $i<= $sitecount; $i++){
   print XMLOUT " <data_record data_id=\"site_$i\">\n";
   print XMLOUT "   <data_parameter param_ref=\"sp_1\">$mass[$i]</data_parameter>\n";
   print XMLOUT "   <data_parameter param_ref=\"sp_2\">($charge[$i]*ChargeConversion)</data_parameter>\n";
   print XMLOUT "   <data_parameter param_ref=\"sp_3\">$molecule[$i]</data_parameter> \n";
   print XMLOUT "   <data_parameter param_ref=\"sp_4\">$ResidueNumber[$i]</data_parameter>\n";
   print XMLOUT "   <data_parameter param_ref=\"sp_5\">$atomname[$i]</data_parameter>\n";
   print XMLOUT "   <data_parameter param_ref=\"sp_6\">$epsilon[$i]</data_parameter>\n";
   print XMLOUT "   <data_parameter param_ref=\"sp_7\">($sigma[$i]*SciConst::SixthRootOfTwo)</data_parameter>\n";
   print XMLOUT "   <data_parameter param_ref=\"sp_8\">$epsilon14[$i]</data_parameter>\n";
   print XMLOUT "   <data_parameter param_ref=\"sp_9\">($sigma14[$i]*SciConst::SixthRootOfTwo)</data_parameter>\n";
   print XMLOUT "   <data_parameter param_ref=\"sp_10\">$element[$i]</data_parameter>\n";
   print XMLOUT " </data_record>\n";
}
print XMLOUT "</data_list>\n";


#################
# bond list
#################

print XMLOUT "\n";
print XMLOUT "<data_list data_class_prepend=\"bond_\">\n";
print XMLOUT " <data_title>bond_list</data_title>\n";
print XMLOUT " <data_parameter_list param_prepend=\"bondp_\">\n";
print XMLOUT "   <data_parameter_spec param_id=\"bondp_1\" type=\"idref\" ref_prepend=\"site_\">site_ref1</data_parameter_spec>\n";
print XMLOUT "   <data_parameter_spec param_id=\"bondp_2\" type=\"idref\" ref_prepend=\"site_\">site_ref2</data_parameter_spec>\n";
print XMLOUT "   <data_parameter_spec param_id=\"bondp_3\" type=\"char\">type</data_parameter_spec>\n";
print XMLOUT " </data_parameter_list>\n";

for($i=1; $i<= $bondcount; $i++){
   print XMLOUT " <data_record data_id=\"bond_$i\">\n";
   print XMLOUT "   <data_parameter_ref param_ref=\"bondp_1\" ref_ptr=\"site_$bond_site1[$i]\"/>\n";
   print XMLOUT "   <data_parameter_ref param_ref=\"bondp_2\" ref_ptr=\"site_$bond_site2[$i]\"/>\n";
   print XMLOUT "   <data_parameter param_ref=\"bondp_3\">single</data_parameter>\n";
   print XMLOUT " </data_record>\n";
}
print XMLOUT "</data_list>\n";


#########################
# UDF invocation table
#########################

print XMLOUT "<udf_invocation_table>\n";
if ($watercount > 0 ) {
  if ($wattype eq "rigid") {
    #print XMLOUT "<udf_invocation_rec udf_id=\"WaterRigid3SiteRattle\" site_tuple_ref=\"SPCForce_sites\"/>\n";
    #print XMLOUT "<udf_invocation_rec udf_id=\"WaterRigid3SiteShake\" site_tuple_ref=\"SPCForce_sites\"/>\n";
  } else {
    #print XMLOUT "<udf_invocation_rec udf_id=\"SPCForce\" site_tuple_ref=\"SPCForce_sites\"/>\n";
  }
}
if (($bondcount -$waterbondcount) > 0) {
  print XMLOUT "<udf_invocation_rec udf_id=\"StdHarmonicBondForce\" site_tuple_ref=\"StdHarmonicBondForce_sites\" param_tuple_ref=\"StdHarmonicBondForce_params\"/>\n";
}
if (($anglecount -$wateranglecount) > 0 ) {
  print XMLOUT "<udf_invocation_rec udf_id=\"StdHarmonicAngleForce\" site_tuple_ref=\"StdHarmonicAngleForce_sites\" param_tuple_ref=\"StdHarmonicAngleForce_params\"/>\n";
}
if ($torsioncount > 0) {
  print XMLOUT "<udf_invocation_rec udf_id=\"OPLSTorsionForce\" site_tuple_ref=\"OPLSTorsionForce_sites\" param_tuple_ref=\"OPLSTorsionForce_params\"/>\n";
}
if ($imptorscount > 0) {
  print XMLOUT "<udf_invocation_rec udf_id=\"OPLSImproperForce\" site_tuple_ref=\"OPLSImproperForce_sites\" param_tuple_ref=\"OPLSImproperForce_params\"/>\n";
}
print XMLOUT "</udf_invocation_table>\n";

#################
# water tuple list
#################

if ($watercount > 0 && $opt_w == 0) {
# /SPC/SPCE/TIP3P water sites
  #print XMLOUT "<site_tuple_list id=\"SPCForce_sites\">\n";
  print XMLOUT "<site_tuple_list id=\"Water3sites\">\n";
  for($i=1; $i <= $watercount; $i++){
    print XMLOUT "<site_tuple>\n";
    # H..O..H order
    print XMLOUT "<site site_ref=\"site_$waterH1[$i]\" site_ordinal=\"1\"/>\n";
    print XMLOUT "<site site_ref=\"site_$waterO[$i]\" site_ordinal=\"2\"/>\n";
    print XMLOUT "<site site_ref=\"site_$waterH2[$i]\" site_ordinal=\"3\"/>\n";
    print XMLOUT "</site_tuple>\n";
  }
  print XMLOUT "</site_tuple_list>\n";
}

#################
# force bond list
#################

if (($bondcount -$waterbondcount) > 0) {
  #nonwater bond sites
  print XMLOUT "<site_tuple_list id=\"StdHarmonicBondForce_sites\">\n";
  if($opt_w == 0) {
    $newbondcount = $bondcount-$waterbondcount;
  }
  else{
    $newbondcount = $bondcount;
  }
  for($i=1; $i <= $newbondcount; $i++){
    print XMLOUT "<site_tuple>\n";
    # protein bonds first, water bonds last
    print XMLOUT "<site site_ref=\"site_$bond_site1[$i]\" site_ordinal=\"1\"/>\n";
    print XMLOUT "<site site_ref=\"site_$bond_site2[$i]\" site_ordinal=\"2\"/>\n";
    print XMLOUT "</site_tuple>\n";
  }
  print XMLOUT "</site_tuple_list>\n";
  #nontip3 bond parameters
  print XMLOUT "<param_tuple_list id=\"StdHarmonicBondForce_params\">\n";
  print XMLOUT "<param_spec_list param_prepend=\"bh_\">\n";
  print XMLOUT "<param_spec param_id=\"bh_1\" type=\"double\">k</param_spec>\n";
  print XMLOUT "<param_spec param_id=\"bh_2\" type=\"double\">r0</param_spec>\n";
  print XMLOUT "</param_spec_list>\n";
  for($i=1; $i <= $newbondcount; $i++){
    print XMLOUT "<param_tuple>\n";
    print XMLOUT "<param param_ref=\"bh_1\">$bond_k[$i]</param>\n";
    print XMLOUT "<param param_ref=\"bh_2\">$bond_r0[$i]</param>\n";
    print XMLOUT "</param_tuple>\n";
  }
  print XMLOUT "</param_tuple_list>\n";
}

#################
# force angle list
#################

if (($anglecount -$wateranglecount) > 0 ) {
  #nonwater angle sites
  print XMLOUT "<site_tuple_list id=\"StdHarmonicAngleForce_sites\">\n";
  if($opt_w == 0) {
    $newanglecount = $anglecount-$wateranglecount;
  }
  else{
    $newanglecount = $anglecount;
  }
  for($i=1; $i <= $newanglecount; $i++){
    print XMLOUT "<site_tuple>\n";
    # protein bonds first, water bonds last
    print XMLOUT "<site site_ref=\"site_$angle_site1[$i]\" site_ordinal=\"1\"/>\n";
    print XMLOUT "<site site_ref=\"site_$angle_site2[$i]\" site_ordinal=\"2\"/>\n";
    print XMLOUT "<site site_ref=\"site_$angle_site3[$i]\" site_ordinal=\"3\"/>\n";
    print XMLOUT "</site_tuple>\n";
  }
  print XMLOUT "</site_tuple_list>\n";
  #nonwater angle parameters
  print XMLOUT "<param_tuple_list id=\"StdHarmonicAngleForce_params\">\n";
  print XMLOUT "<param_spec_list param_prepend=\"ah_\">\n";
  print XMLOUT "<param_spec param_id=\"ah_1\" type=\"double\">k</param_spec>\n";
  print XMLOUT "<param_spec param_id=\"ah_2\" type=\"double\">th0</param_spec>\n";
  print XMLOUT "</param_spec_list>\n";
  for($i=1; $i <= $newanglecount; $i++){
    print XMLOUT "<param_tuple>\n";
    print XMLOUT "<param param_ref=\"ah_1\">$angle_k[$i]</param>\n";
    print XMLOUT "<param param_ref=\"ah_2\">($angle_theta0[$i]*Math::Deg2Rad)</param>\n";
    print XMLOUT "</param_tuple>\n";
  }
  print XMLOUT "</param_tuple_list>\n";
}

#################
# force torsion list
#################

if ($torsioncount > 0) {
  print XMLOUT "<site_tuple_list id=\"OPLSTorsionForce_sites\">\n";
    for($i=1; $i <= $torsioncount; $i++){
      print XMLOUT "<site_tuple>\n";
      print XMLOUT "<site site_ref=\"site_$torsion_site1[$i]\" site_ordinal=\"1\"/>\n";
      print XMLOUT "<site site_ref=\"site_$torsion_site2[$i]\" site_ordinal=\"2\"/>\n";
      print XMLOUT "<site site_ref=\"site_$torsion_site3[$i]\" site_ordinal=\"3\"/>\n";
      print XMLOUT "<site site_ref=\"site_$torsion_site4[$i]\" site_ordinal=\"4\"/>\n";
      print XMLOUT "</site_tuple>\n";
    }
  print XMLOUT "</site_tuple_list>\n";
  #swopetorsion parameters
  print XMLOUT "<param_tuple_list id=\"OPLSTorsionForce_params\">\n";
  print XMLOUT "<param_spec_list param_prepend=\"ctp_\">\n";
  print XMLOUT "<param_spec param_id=\"ctp_1\" type=\"double\">k</param_spec>\n";
  print XMLOUT "<param_spec param_id=\"ctp_2\" type=\"int\">n</param_spec>\n";
  print XMLOUT "<param_spec param_id=\"ctp_3\" type=\"double\">sinDelta</param_spec>\n";
  print XMLOUT "<param_spec param_id=\"ctp_4\" type=\"double\">cosDelta</param_spec>\n";
  print XMLOUT "</param_spec_list>\n";
  for($i=1; $i <= $torsioncount; $i++){
    print XMLOUT "<param_tuple>\n";
    print XMLOUT "<param param_ref=\"ctp_1\">$torsion_Vn[$i]</param>\n";
    print XMLOUT "<param param_ref=\"ctp_2\">$torsion_n[$i]</param>\n";
    print XMLOUT "<param param_ref=\"ctp_3\">sin($torsion_phi0[$i]*Math::Deg2Rad)</param>\n";
    print XMLOUT "<param param_ref=\"ctp_4\">cos($torsion_phi0[$i]*Math::Deg2Rad)</param>\n";
    print XMLOUT "</param_tuple>\n";
  }
  print XMLOUT "</param_tuple_list>\n";
}

#################
# force improper torsion list
#################

if ($imptorscount > 0) {
  #improper sites
  print XMLOUT "<site_tuple_list id=\"OPLSImproperForce_sites\">\n";
    for($i=1; $i <= $imptorscount; $i++){
      print XMLOUT "<site_tuple>\n";
      print XMLOUT "<site site_ref=\"site_$imptors_site1[$i]\" site_ordinal=\"1\"/>\n";
      print XMLOUT "<site site_ref=\"site_$imptors_site2[$i]\" site_ordinal=\"2\"/>\n";
      print XMLOUT "<site site_ref=\"site_$imptors_site3[$i]\" site_ordinal=\"3\"/>\n";
      print XMLOUT "<site site_ref=\"site_$imptors_site4[$i]\" site_ordinal=\"4\"/>\n";
      print XMLOUT "</site_tuple>\n";
    }
  print XMLOUT "</site_tuple_list>\n";
  #improper parameters
  print XMLOUT "<param_tuple_list id=\"OPLSImproperForce_params\">\n";
  print XMLOUT "<param_spec_list param_prepend=\"citp_\">\n";
  print XMLOUT "<param_spec param_id=\"citp_1\" type=\"double\">k</param_spec>\n";
  print XMLOUT "<param_spec param_id=\"citp_2\" type=\"int\">n</param_spec>\n";
  print XMLOUT "<param_spec param_id=\"citp_3\" type=\"double\">sinDelta</param_spec>\n";
  print XMLOUT "<param_spec param_id=\"citp_4\" type=\"double\">cosDelta</param_spec>\n";
  print XMLOUT "</param_spec_list>\n";
  for($i=1; $i <= $imptorscount; $i++){
    print XMLOUT "<param_tuple>\n";
    print XMLOUT "<param param_ref=\"citp_1\">$imptors_Vn[$i]</param>\n";
    print XMLOUT "<param param_ref=\"citp_2\">$imptors_n[$i]</param>\n";
    print XMLOUT "<param param_ref=\"citp_3\">sin($imptors_phi0[$i]*Math::Deg2Rad)</param>\n";
    print XMLOUT "<param param_ref=\"citp_4\">cos($imptors_phi0[$i]*Math::Deg2Rad)</param>\n";
    print XMLOUT "</param_tuple>\n";
  }
  print XMLOUT "</param_tuple_list>\n";
}


#################
# LJ pair list
#################

##print XMLOUT "\n";
##print XMLOUT "<pair_list type_class_prepend=\"lj_\">\n";
##print XMLOUT " <pair_parameter_list param_prepend=\"ljp_\">\n";
##print XMLOUT "     <pair_parameter_spec param_id=\"ljp_1\" type=\"double\">epsilon</pair_parameter_spec>\n";
##print XMLOUT "     <pair_parameter_spec param_id=\"ljp_2\" type=\"double\">sigma</pair_parameter_spec>\n";
##print XMLOUT " </pair_parameter_list>\n";

# back to 
##for($i=1; $i<=$TotalLJTypes; $i++){
##     print XMLOUT " <pair_record type_ref_1=\"lj_$i\">\n";
##     print XMLOUT "   <pair_parameter param_ref=\"ljp_1\">$epsilonLJType[$i]</pair_parameter>\n";
##     print XMLOUT "   <pair_parameter param_ref=\"ljp_2\">$sigmaLJType[$i]</pair_parameter>\n";
##     print XMLOUT " </pair_record>\n";
  
##}

#for($i=1; $i<=$TotalLJTypes; $i++){
#  for($j=$i; $j<=$TotalLJTypes; $j++){ 
#     $epsij = 0.5 * sqrt($epsilonLJType[$i] * $epsilonLJType[$j]);
#     $sigij = sqrt($sigmaLJType[$i] * $sigmaLJType[$j]);
#     print XMLOUT " <pair_record type_ref_1=\"lj_$i\" type_ref_2=\"lj_$j\">\n";
#     print XMLOUT "   <pair_parameter param_ref=\"ljp_1\">$epsij</pair_parameter>\n";
#     print XMLOUT "   <pair_parameter param_ref=\"ljp_2\">$sigij</pair_parameter>\n";
#     print XMLOUT " </pair_record>\n";
#  }
#}
##print XMLOUT "</pair_list>\n";


#################
# LJ14 pair list
#################

##print XMLOUT "\n";
##print XMLOUT "<pair_list type_class_prepend=\"lj14_\">\n";
##print XMLOUT " <pair_parameter_list param_prepend=\"lj14p_\">\n";
##print XMLOUT "     <pair_parameter_spec param_id=\"lj14p_1\" type=\"double\">epsilon</pair_parameter_spec>\n";
##print XMLOUT "     <pair_parameter_spec param_id=\"lj14p_2\" type=\"double\">sigma</pair_parameter_spec>\n";
##print XMLOUT " </pair_parameter_list>\n";

##for($i=1; $i<=$TotalLJTypes; $i++){
##     $epsilon14LJType[$i] =  $epsilon14LJType[$i];
##     print XMLOUT " <pair_record type_ref_1=\"lj14_$i\">\n";
##     print XMLOUT "   <pair_parameter param_ref=\"lj14p_1\">$epsilon14LJType[$i]</pair_parameter>\n";
##     print XMLOUT "   <pair_parameter param_ref=\"lj14p_2\">$sigma14LJType[$i]</pair_parameter>\n";
##     print XMLOUT " </pair_record>\n";
##}

#for($i=1; $i<=$TotalLJTypes; $i++){
#  for($j=$i; $j<=$TotalLJTypes; $j++){ 
#     $epsij = 0.5 * sqrt($epsilon14LJType[$i] * $epsilon14LJType[$j]);
#     $sigij = sqrt($sigma14LJType[$i] * $sigma14LJType[$j]);
#     print XMLOUT " <pair_record type_ref_1=\"lj14_$i\" type_ref_2=\"lj14_$j\">\n";
#     print XMLOUT "   <pair_parameter param_ref=\"lj14p_1\">$epsij</pair_parameter>\n";
#     print XMLOUT "   <pair_parameter param_ref=\"lj14p_2\">$sigij</pair_parameter>\n";
#     print XMLOUT " </pair_record>\n";
#  }
#}

##print XMLOUT "</pair_list>\n";

# end
print XMLOUT"</ffparams>\n";

close(XMLOUT);



sub get_id{
  my($name) = @_;
  # temporary assume only the first char is element name
  $num = substr($name,1);
  return $num;
}
 
sub get_atomic_number{
  my($name) = @_;
  $_ = $name;

  if(/Cl/){
    return 17;
  } elsif(/Br/){
    return 35;
  } elsif(/Na/){
    return 11;
  } elsif(/Ca/){
    return 20;
  } elsif(/Zn/){
    return 30;
  } elsif(/C/){
    return 6;
  } elsif(/H/){
    return 1;
  } elsif(/N/){
    return 7;
  } elsif(/O/){
    return 8;
  } elsif(/S/){
    return 16;
  } elsif(/P/){
    return 15;
  } elsif(/LP/){
    return 0;
  }
  printf(" Can't find atomic number for your input name %s\n", $name);
  return 0;
}

sub get_element_name{
  my($name) = @_;
  $_ = $name;

  if(/Cl/){
    return "Cl";
  } elsif(/Br/){
    return "Br";
  } elsif(/Na/){
    return "Na";
  } elsif(/Ca/){
    return "Ca";
  } elsif(/Zn/){
    return "Zn";
  } elsif(/C/){
    return "C";
  } elsif(/H/){
    return "H";
  } elsif(/N/){
    return "N";
  } elsif(/O/){
    return "O";
  } elsif(/S/){
    return "S";
  } elsif(/P/){
    return "P";
  } elsif(/LP/){
    return "LP";
  }
  printf(" Can't find element name for your input name %s\n", $name);
  return "NULL";
}


sub get_mass{
  my($name) = @_;
  $_ = $name;

  if(/Cl/){
    return 35.45;
  }  elsif(/Br/){
    return 79.90;
  } elsif(/Na/){
    return 23.00;
  } elsif(/Ca/){
    return 40.08;
  } elsif(/Zn/){
    return 65.38;
  } elsif(/C/){
    return 12.01;
  } elsif(/H/){
    return 1.008;
  } elsif(/N/){
    return 14.01;
  } elsif(/O/){
    return 16.00;
  } elsif(/S/){
    return 32.06;
  } elsif(/P/){
    return 30.97;
  } elsif(/LP/){
    return 0.0;
  }
  printf(" Can't find mass for your input name %s\n", $name);
  return 0.0;
}

sub check_position {
  my($name,$totalnum,$List) = @_;

  my ($i);

  # if found $LJt in the list
  for($i=1; $i<= $totalnum; $i++){
    if ($name eq $List->[$i]) {return $i;}
  }

  # else return -1
  return -1;

}


sub checkmoleculetype {
  $foo = "null";
  if ($_[0] eq 'ALA' || $_[0] eq 'ARG' || $_[0] eq 'ACE' ||
      $_[0] eq 'ARD' || $_[0] eq 'ASH' || $_[0] eq 'ASP' || $_[0] eq 'ASN' ||
      $_[0] eq 'CYS' || $_[0] eq 'CYD' || $_[0] eq 'CYX' || $_[0] eq 'GLH' ||
      $_[0] eq 'GLU' || $_[0] eq 'GLN' || $_[0] eq 'GLY' || $_[0] eq 'HIH' ||
      $_[0] eq 'HIS' || $_[0] eq 'HIE' || $_[0] eq 'ILE' || $_[0] eq 'LEU' ||
      $_[0] eq 'LYS' || $_[0] eq 'LYD' || $_[0] eq 'MET' || $_[0] eq 'PHE' ||
      $_[0] eq 'PRO' || $_[0] eq 'SER' || $_[0] eq 'SED' || $_[0] eq 'THR' ||
      $_[0] eq 'TRP' || $_[0] eq 'TYR' || $_[0] eq 'TYD' || $_[0] eq 'VAL' ||
      $_[0] eq 'NT1' || $_[0] eq 'NT2' || $_[0] eq 'NT3' || $_[0] eq 'CT5' ||
      $_[0] eq 'CT1' || $_[0] eq 'CT2' || $_[0] eq 'CT3' || $_[0] eq 'CT4' ){
    $foo = "protein"
  } elsif ($_[0] eq 'TIP3' || $_[0] eq 'TIP4' || $_[0] eq 'TIP5' ||
	   $_[0] eq 'SPC'  || $_[0] eq 'SPCE' || $_[0] eq 'DMSO' ||
	   $_[0] eq 'MEOH' || $_[0] eq 'UREA' || $_[0] eq 'HOH' ){
    $foo = "solvent"
  } elsif ($_[0] eq 'NUSA' || $_[0] eq 'NUSC' || $_[0] eq 'NUSG' ||
	   $_[0] eq 'NUST' ){
    $foo = "dna"
  } elsif ($_[0] eq 'RNUA' || $_[0] eq 'RNUC' || $_[0] eq 'RNUG' ||
	   $_[0] eq 'RNUU' ){
    $foo = "rna"
  } elsif ($_[0] eq 'F'  || $_[0] eq 'NA' || $_[0] eq 'CA' || $_[0] eq 'MG' ||
	   $_[0] eq 'AR' || $_[0] eq 'FE' || $_[0] eq 'K'  || $_[0] eq 'CL') {
    $foo = "ion"
  }
  return($foo);
}

sub checkpolymer {
  if ($_[0] eq 'protein' || $_[0] eq 'dna' || $_[0] eq 'rna') {
    return(1);
  } else {
    return(0);
  }
}

sub convertresiduetag {
   if($_[0] eq "HID") {return "HIS" ;}
   if($_[0] eq "HIP") {return "HIH" ;}
   if($_[0] eq "AME") {return "NMA" ;}
   if($_[0] eq "SPC" || $_[0] eq "T3P") {return "HOH" ;}
   return($_[0]);
}

sub convertatomtag {
  if ($_[0] eq "HN")  {return ("H");}

  # handle ligand atoms
  if ($_[1] eq "UNK" || $_[1] eq "LIG") {
    # check 2-char atoms first
    if($_[0] =~/^Ca/) {return "Ca" ;}
    if($_[0] =~/^Na/) {return "Na" ;}
    if($_[0] =~/^Cl/) {return "Cl" ;}
    if($_[0] =~/^Br/) {return "Cl" ;}
    if($_[0] =~/^H/) {return "H" ;}
    if($_[0] =~/^C/) {return "C" ;}
    if($_[0] =~/^N/) {return "N" ;}
    if($_[0] =~/^O/) {return "O" ;}
    if($_[0] =~/^S/) {return "S" ;}
    if($_[0] =~/^I/) {return "I" ;}
    return ($_[0]);
  }


  # handle various waters
  if ($_[1] eq "SPC" || $_[1] eq "T3P" || $_[1] eq "HOH") {
    if($_[0] =~/^O/) {return "O" ;}
    if($_[0] =~/^1H/) {return "H1" ;}
    if($_[0] =~/^2H/) {return "H2" ;}
    return ($_[0]);
  }


  if ($_[0] =~ /^H/ ) {
    if ($_[1] eq "ACE") {
      if ($_[0] eq "HH31")  {return ("1H");}
      if ($_[0] eq "HH32")  {return ("2H");}
      if ($_[0] eq "HH33")  {return ("3H");}
      return($_[0]);
    }
    elsif ($_[1] eq "NMA") {
      if ($_[0] eq "HH31")  {return ("1HA");}
      if ($_[0] eq "HH32")  {return ("2HA");}
      if ($_[0] eq "HH33")  {return ("3HA");}
      return($_[0]);
    }
    elsif ($_[1] eq "ARG") {
      if ($_[0] eq "HB1")  {return ("1HB");}
      if ($_[0] eq "HB2")  {return ("2HB");}
      if ($_[0] eq "HG1")  {return ("1HG");}
      if ($_[0] eq "HG2")  {return ("2HG");}
      if ($_[0] eq "HD1")  {return ("1HD");}
      if ($_[0] eq "HD2")  {return ("2HD");}
      if ($_[0] eq "HH11") {return ("1HH1");}
      if ($_[0] eq "HH12") {return ("2HH1");}
      if ($_[0] eq "HH21") {return ("1HH2");}
      if ($_[0] eq "HH22") {return ("2HH2");}
      return($_[0]);
    }
    elsif ($_[1] eq "ASN") {
      if ($_[0] eq "HB1")  {return ("1HB");}
      if ($_[0] eq "HB2")  {return ("2HB");}
      if ($_[0] eq "HD21") {return ("1HD2");}
      if ($_[0] eq "HD22") {return ("2HD2");}
      return($_[0]);
    }
    elsif ($_[1] eq "LEU") {
      if ($_[0] eq "HG1")  {return ("1HG");}
      if ($_[0] eq "HG2")  {return ("2HG");}
      if ($_[0] eq "HD11") {return ("1HD1");}
      if ($_[0] eq "HD12") {return ("2HD1");}
      if ($_[0] eq "HD13") {return ("3HD1");}
      if ($_[0] eq "HD21") {return ("1HD2");}
      if ($_[0] eq "HD22") {return ("2HD2");}
      if ($_[0] eq "HD23") {return ("3HD2");}
      return($_[0]);
    }
    elsif ($_[1] eq "THR") {
      if ($_[0] eq "HG11")  {return ("1HG1");}
      if ($_[0] eq "HG12")  {return ("2HG1");}
      if ($_[0] eq "HG13")  {return ("3HG1");}
      return($_[0]);
    }
    elsif ($_[1] eq "VAL") {
      if ($_[0] eq "HG11")  {return ("1HG1");}
      if ($_[0] eq "HG12")  {return ("2HG1");}
      if ($_[0] eq "HG13")  {return ("3HG1");}
      if ($_[0] eq "HG21")  {return ("1HG2");}
      if ($_[0] eq "HG22")  {return ("2HG2");}
      if ($_[0] eq "HG23")  {return ("3HG2");}
      return($_[0]);
    }
    elsif ($_[1] eq "ILE") {
      if ($_[0] eq "HG11")  {return ("1HG1");}
      if ($_[0] eq "HG12")  {return ("2HG1");}
      if ($_[0] eq "HG21")  {return ("1HG2");}
      if ($_[0] eq "HG22")  {return ("2HG2");}
      if ($_[0] eq "HG23")  {return ("3HG2");}
      if ($_[0] eq "HD11")  {return ("1HD1");}
      if ($_[0] eq "HD12")  {return ("2HD1");}
      if ($_[0] eq "HD13")  {return ("3HD1");}
      return($_[0]);
    }
    elsif ($_[1] eq "PRO") {
      if ($_[0] eq "HN1")  {return ("1HN");}
      if ($_[0] eq "HN2")  {return ("2HN");}
      if ($_[0] eq "HB1")  {return ("1HB");}
      if ($_[0] eq "HB2")  {return ("2HB");}
      if ($_[0] eq "HG1")  {return ("1HG");}
      if ($_[0] eq "HG2")  {return ("2HG");}
      if ($_[0] eq "HD1")  {return ("1HD");}
      if ($_[0] eq "HD2")  {return ("2HD");}
      return($_[0]);
    }
    elsif ($_[1] eq "GLY") {
      if ($_[0] eq "HA1")  {return ("1HA");}
      if ($_[0] eq "HA2")  {return ("2HA");}
      return($_[0]);
    }
    elsif ($_[1] eq "ALA") {
      if ($_[0] eq "HB1")  {return ("1HB");}
      if ($_[0] eq "HB2")  {return ("2HB");}
      if ($_[0] eq "HB3")  {return ("3HB");}
      return($_[0]);
    }
    elsif ($_[1] eq "LYS" || $_[1] eq "LYD") {
      if ($_[0] eq "HB1")  {return ("1HB");}
      if ($_[0] eq "HB2")  {return ("2HB");}
      if ($_[0] eq "HG1")  {return ("1HG");}
      if ($_[0] eq "HG2")  {return ("2HG");}
      if ($_[0] eq "HD1")  {return ("1HD");}
      if ($_[0] eq "HD2")  {return ("2HD");}
      if ($_[0] eq "HE1")  {return ("1HE");}
      if ($_[0] eq "HE2")  {return ("2HE");}
      if ($_[0] eq "HZ1")  {return ("1HZ");}
      if ($_[0] eq "HZ2")  {return ("2HZ");}
      if ($_[0] eq "HZ3")  {return ("3HZ");}
      return($_[0]);
    }
    elsif ($_[1] eq "MET") {
      if ($_[0] eq "HB1")  {return ("1HB");}
      if ($_[0] eq "HB2")  {return ("2HB");}
      if ($_[0] eq "HG1")  {return ("1HG");}
      if ($_[0] eq "HG2")  {return ("2HG");}
      if ($_[0] eq "HE1")  {return ("1HE");}
      if ($_[0] eq "HE2")  {return ("2HE");}
      if ($_[0] eq "HE3")  {return ("3HE");}
      return($_[0]);
    }
    elsif ($_[1] eq "GLN" || $_[1] eq "GLH" || $_[1] eq "GLU") {
      if ($_[0] eq "HB1")  {return ("1HB");}
      if ($_[0] eq "HB2")  {return ("2HB");}
      if ($_[0] eq "HG1")  {return ("1HG");}
      if ($_[0] eq "HG2")  {return ("2HG");}
      if ($_[0] eq "HE21") {return ("1HE2");}
      if ($_[0] eq "HE22") {return ("2HE2");}
      return($_[0]);
    }
    elsif ($_[1] eq "ASH" || $_[1] eq "ASP" || $_[1] eq "CYS" || $_[1] eq "CYD" ||
	$_[1] eq "CYX" || $_[1] eq "HIH" || $_[1] eq "HIS" || $_[1] eq "HIE" ||
	$_[1] eq "SER" || $_[1] eq "SED" || $_[1] eq "PHE" || $_[1] eq "TYR" ||
	$_[1] eq "TYD" || $_[1] eq "TRP" ) {
      if ($_[0] eq "HB1")  {return ("1HB");}
      if ($_[0] eq "HB2")  {return ("2HB");}
      return($_[0]);
    }
  }
  return($_[0]);
}

sub convertcapatomtag {
  if (!$cap) { 
    if ($atname[$i] eq "HT1") {$atname[$i] = "1H";}
    if ($atname[$i] eq "HT2") {$atname[$i] = "2H";}
    if ($atname[$i] eq "HT3") {$atname[$i] = "3H";}
    if ($atname[$i] eq "HN1") {$atname[$i] = "1H";}
    if ($atname[$i] eq "HN2") {$atname[$i] = "2H";}
    if ($atname[$i] eq "OT1") {$atname[$i] = "O";}
    if ($atname[$i] eq "OT2") {$atname[$i] = "OXT";}
    if ($atname[$i] eq "HY1") {$atname[$i] = "1H" ;$resname[$i] = "ACE";$resnum[$i] = $resnum[$i] - 1;}
    if ($atname[$i] eq "HY2") {$atname[$i] = "2H" ;$resname[$i] = "ACE";$resnum[$i] = $resnum[$i] - 1;}
    if ($atname[$i] eq "HY3") {$atname[$i] = "3H" ;$resname[$i] = "ACE";$resnum[$i] = $resnum[$i] - 1;}
    if ($atname[$i] eq "CAY") {$atname[$i] = "CH3";$resname[$i] = "ACE";$resnum[$i] = $resnum[$i] - 1;}
    if ($atname[$i] eq "CY")  {$atname[$i] = "C"  ;$resname[$i] = "ACE";$resnum[$i] = $resnum[$i] - 1;}
    if ($atname[$i] eq "OY")  {$atname[$i] = "O"  ;$resname[$i] = "ACE";$resnum[$i] = $resnum[$i] - 1;}
    if ($atname[$i] eq "NT")  {$atname[$i] = "N"  ;$resname[$i] = "CT5";$resnum[$i] = $resnum[$i] + 1;}
  } else {
    if ($atname[$i] eq "HNT") {$atname[$i] = "H"  ;$resname[$i] = "CT5";$resnum[$i] = $resnum[$i] + 1;}
    if ($atname[$i] eq "CAT") {$atname[$i] = "CA" ;$resname[$i] = "CT5";$resnum[$i] = $resnum[$i] + 1;}
    if ($atname[$i] eq "HT1") {$atname[$i] = "HA1";$resname[$i] = "CT5";$resnum[$i] = $resnum[$i] + 1;}
    if ($atname[$i] eq "HT2") {$atname[$i] = "HA2";$resname[$i] = "CT5";$resnum[$i] = $resnum[$i] + 1;}
    if ($atname[$i] eq "HT3") {$atname[$i] = "HA3";$resname[$i] = "CT5";$resnum[$i] = $resnum[$i] + 1;}
  }
  return;
  if ($atname[$i] eq "OT1") {$atname[$i] = "O1";$resname[$i] = "CT3";}
  if ($atname[$i] eq "OT2") {$atname[$i] = "O2";$resname[$i] = "CT3";}
  if ($atname[$i] eq "CT")  {$atname[$i] = "CA";$resname[$i] = "CT3";}
  if ($atname[$i] eq "HT1") {$atname[$i] = "1H";$resname[$i] = "CT3";}
  if ($atname[$i] eq "HT2") {$atname[$i] = "2H";$resname[$i] = "CT3";}
  if ($atname[$i] eq "HT3") {$atname[$i] = "3H";$resname[$i] = "CT3";}
  if ($atname[$i] eq "NT")  {$atname[$i] = "N"; $resname[$i] = "CT4";}
  if ($atname[$i] eq "HT1") {$atname[$i] = "1H";$resname[$i] = "CT4";}
  if ($atname[$i] eq "HT2") {$atname[$i] = "2H";$resname[$i] = "CT4";}
}

sub removespace{
  my($string) = @_;
  $string =~s/ //g;
  return $string;
}
