/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Interface for 'mechanisable' NSQ processing
 */
// 'fsel' is a built-in instruction on PPCGR and above, sometimes we want to force its use
#if 1
#include <builtins.h>
#define fsel(a, x, y) __fsel((a),(x),(y))
#else
#define fsel(a, x, y) ( (a) >= 0.0 ? (x) : (y) )
#endif

#include <math.h> // for 'fabs'
 
// Coordinate geometry
template <class type>
class tXYZ {
  public:
  type mX, mY, mZ ;
    void Zero(void) { 
      mX = 0.0 ; 
      mY = 0.0 ; 
    mZ = 0.0 ; 
  }
      inline
    tXYZ operator+( const tXYZ& aOther ) const
      {
      tXYZ rc;
      rc.mX = mX + aOther.mX;
      rc.mY = mY + aOther.mY;
      rc.mZ = mZ + aOther.mZ;
      return( rc );
      }
  
    inline
    tXYZ operator-( const tXYZ<type>& aOther ) const
      {
      tXYZ<type> rc;
      rc.mX = mX - aOther.mX;
      rc.mY = mY - aOther.mY;
      rc.mZ = mZ - aOther.mZ;
      return( rc );
      }
     inline
    tXYZ operator*( type aScalar ) const
      {
      tXYZ rc;
      rc.mX = mX * aScalar;
      rc.mY = mY * aScalar;
      rc.mZ = mZ * aScalar;
      return( rc );
      }
          inline
    type LengthSquared() const
    {
      type ls =  mX * mX + mY * mY + mZ * mZ ;
      return( ls );
    } 
      
          
} ;

typedef tXYZ<double> XYZ;
 
// Bond physics ... LJ and Electrostatics constants for each chemical element of interest
class LJParms
{
public:
  double p1 ;
  double p2 ;
} ;
class ESParms
{
public:
  double p1 ;
} ;

class BondPhysics
{
  public: 
  LJParms mLJ ;
  ESParms mES ;
} ;

enum {
    k_MaxElements = 16 
} ;

BondPhysics BondPhysicsArray[k_MaxElements] ;

// All the atoms in the system
class AtomStatic
{
  public: 
  int mElement ;
} ;
class AtomDynamic
{
  public:
  XYZ mLocation ;
} ;

enum {
    k_MaxAtoms = 4096 
} ;

// This implementation keeps the time-varying implementation separate from the invariants.
// Another implementation might keep copies of the invariants along with the time-varying
// items, in an attempt to reduce cache misses when accessing things.
// 'Atom' class hides this
AtomStatic AtomStaticArray[k_MaxAtoms] ;
AtomDynamic AtomDynamicArray[k_MaxAtoms] ;

class Atom {
  public: 
  XYZ& Location(int x) { return AtomDynamicArray[x].mLocation ; }
  const LJParms& LJ(int x) { return BondPhysicsArray[AtomStaticArray[x].mElement].mLJ ; }
  const ESParms& ES(int x) { return BondPhysicsArray[AtomStaticArray[x].mElement].mES ; } 
} ;

Atom AllAtoms ;

// What we know about the fragments that are of interest to this node
class FragmentStatic {
  public:
  int mFirstAtom ;
  int mAtomCount ;
  int mMolecule ; // sequence number of the molecule that this fragment belongs to
  int mFragmentTag ; // sequence number of this fragment within its molecule
} ; 

// What we know about the dynamics of a fragment
class FragmentDynamic {
  public: 
  XYZ mBoundingBoxCentre ;
  XYZ mBoundingBoxSize ;
  XYZ mBoundingSphereCentre ; // Might be different from mBoundingBoxCentre if we try a water optimisation
  double mBoundingSphereRadius ;
} ;

enum {
  k_MaxFragments = 1024 ,
} ;

FragmentStatic FragmentStaticArray[k_MaxFragments] ;
FragmentDynamic FragmentDynamicArray[k_MaxFragments+20] ; // Extra space to let vector square root work efficiently

class Fragment {
  public:
  XYZ& BoundingBoxCentre(int x) { return FragmentDynamicArray[x].mBoundingBoxCentre ; } 
  XYZ& BoundingBoxSize(int x) { return FragmentDynamicArray[x].mBoundingBoxSize ; } 
  XYZ& BoundingSphereCentre(int x) { return FragmentDynamicArray[x].mBoundingSphereCentre ; } 
  double& BoundingSphereRadius(int x) { return FragmentDynamicArray[x].mBoundingSphereRadius ; } 
  FragmentStatic& Static(int x) { return FragmentStaticArray[x] ; } 
  FragmentDynamic& Dynamic(int x) { return FragmentDynamicArray[x] ; } 
} ;

Fragment AllFragments ;

// We keep the fragments by number of atoms.
enum {
  k_MaxFragmentAtomCount = 8 
} ;
int FragIndexNextStart[k_MaxFragmentAtomCount] ;

// A Verlet list is a list of fragment pairs which this node is evaluating the forces for
// Here expressed as indices to the local node's Fragment table, which in general is
// different from the global table.
class VerletListItem
{
  public: 
  int mFrag0 ;
  int mFrag1 ;
} ;

enum { 
  k_VerletListMaxSize = 16384 
} ;

VerletListItem VerletList[k_VerletListMaxSize] ;

class Configuration
{
  public: 
  int mActualFragCount ;
} ;

class NSQ : public Configuration
{
public: 	
  // NSQ gets asked to go through the Verlet list for this node, figuring
  // which fragments are actually in range, and driving IFP for them
  void Process(void) ;
private:
  void EvaluateBoundaries(void) ;
  int PackVerletList(VerletListItem * PackedVerletList) ;
  void RunVerletList(void) ;	
  void IFP(FragmentStatic& Frag0, FragmentStatic& Frag1) ;
} ;
 
void NSQ::Process(void) {
  EvaluateBoundaries() ;
  RunVerletList() ; 
}


void ConvertToRadius(int FragIndexFirst, int FragIndexQuit) ;


//int NSQ::PackVerletList(VerletListItem * PackedVerletList)
//{
//	return -1 ; 
//} 


