/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /*
 * Mechanisable NSQ processing
 */
#include <NSQProto.hpp>


template <int AtomCount> void xEvaluateBoundaries(int FragStart, int NextFragStart) ;

template <int AtomCount> static inline void EvaluateBoundary(FragmentDynamic& Dynamic, const FragmentStatic& Static) ;


static inline double min(double a, double b)
{
  return fsel(a-b,b,a) ; // ((a-b) >= 0.0)  ? b : a ;
}
static inline double max(double a, double b)
{
  return fsel(a-b,a,b) ; // ((a-b) >= 0.0)  ? a : b ;
}

// 1-atom fragment is a special case ...
template <> inline void EvaluateBoundary<1>(FragmentDynamic& Dynamic, const FragmentStatic& Static)
{
  XYZ Centre = AllAtoms.Location(Static.mFirstAtom) ;
  Dynamic.mBoundingBoxCentre = Centre ;
  Dynamic.mBoundingSphereCentre = Centre ;
  Dynamic.mBoundingBoxSize.Zero() ; 
  Dynamic.mBoundingSphereRadius = 0.0 ;
}

// 2-atom fragment likewise
template <> inline void EvaluateBoundary<2>(FragmentDynamic& Dynamic, const FragmentStatic& Static)
{
  XYZ First = AllAtoms.Location(Static.mFirstAtom) ;
  XYZ Second = AllAtoms.Location(Static.mFirstAtom+1) ;
  XYZ Centre = (First + Second) * 0.5 ;
  XYZ aBox = ( First - Second ) * 0.5 ;
  Dynamic.mBoundingBoxSize.mX = fabs(aBox.mX) ;
  Dynamic.mBoundingBoxSize.mY = fabs(aBox.mY) ;
  Dynamic.mBoundingBoxSize.mZ = fabs(aBox.mZ) ;
  Dynamic.mBoundingBoxCentre = Centre ;
  Dynamic.mBoundingSphereCentre = Centre ;
  Dynamic.mBoundingSphereRadius = aBox.LengthSquared() * 0.25 ;
}

// General case. Exploit the optimisation that we want 'max' and 'min', take atoms in pairs
template <int AtomCount> static inline void EvaluateBoundary(FragmentDynamic& Dynamic, const FragmentStatic& Static)
{
  int FirstAtom = Static.mFirstAtom ;
  XYZ LowerLeft ;
  XYZ UpperRight ;
  int LoopStart ;
  // Arrange for an even number of atoms to be processed in the loop
  if ( AtomCount & 1 )
  {
    LowerLeft = AllAtoms.Location(FirstAtom) ;
    UpperRight = LowerLeft ;
    LoopStart = 1 ;
  } else {
    XYZ First = AllAtoms.Location(FirstAtom) ;
    XYZ Second = AllAtoms.Location(FirstAtom+1) ;
    LowerLeft.mX = min(First.mX,Second.mX) ;
    LowerLeft.mY = min(First.mY,Second.mZ) ;
    LowerLeft.mZ = min(First.mZ,Second.mZ) ;
    UpperRight.mX = max(First.mX,Second.mX) ;
    UpperRight.mY = max(First.mY,Second.mZ) ;
    UpperRight.mZ = max(First.mZ,Second.mZ) ;
    LoopStart = 2 ;
  }
  for (int x=LoopStart;x<AtomCount;x+=1)
  {
    XYZ First = AllAtoms.Location(FirstAtom+x) ;
    XYZ Second = AllAtoms.Location(FirstAtom+x+1) ;
    
    LowerLeft.mX = min(LowerLeft.mX,min(First.mX,Second.mX)) ;
    LowerLeft.mY = min(LowerLeft.mY,min(First.mY,Second.mY)) ;
    LowerLeft.mZ = min(LowerLeft.mZ,min(First.mZ,Second.mZ)) ;
    UpperRight.mX = max(UpperRight.mX,max(First.mX,Second.mX)) ;
    UpperRight.mY = max(UpperRight.mY,max(First.mY,Second.mY)) ;
    UpperRight.mZ = max(UpperRight.mZ,max(First.mZ,Second.mZ)) ;
    
  }
  XYZ Centre = (LowerLeft + UpperRight) * 0.5 ;
  XYZ BoundingBoxSize = (UpperRight - LowerLeft) * 0.5 ;
  Dynamic.mBoundingBoxCentre = Centre ;
  Dynamic.mBoundingBoxSize = BoundingBoxSize ;
  Dynamic.mBoundingSphereCentre = Centre ;
  double maxRadSquared = (AllAtoms.Location(FirstAtom)-Centre).LengthSquared() ;
  for (int xx=1;xx<AtomCount;xx+=1)
  {
    double RadSquared = (AllAtoms.Location(FirstAtom+xx)-Centre).LengthSquared() ;
    maxRadSquared = max(maxRadSquared,RadSquared) ;
  }
  Dynamic.mBoundingSphereRadius = maxRadSquared ;
}

template <int AtomCount> void xEvaluateBoundaries(int FragStart, int NextFragStart) 
{
  for ( int x=FragStart;x<NextFragStart;x+=1)
  {
    EvaluateBoundary<AtomCount>(AllFragments.Dynamic(x),AllFragments.Static(x)) ;
  }
}

void NSQ::EvaluateBoundaries(void)
{ 
  // Find the boundaries of all the size-1 fragments (trivial)
  xEvaluateBoundaries<1>(                   0 ,FragIndexNextStart[0]) ;
  // Then the boundaries of all the size-2 fragments
  xEvaluateBoundaries<2>(FragIndexNextStart[0],FragIndexNextStart[1]) ;
  // Then all the size-3 fragments (includes all the waters)
  xEvaluateBoundaries<3>(FragIndexNextStart[1],FragIndexNextStart[2]) ;
  // and so on
  xEvaluateBoundaries<4>(FragIndexNextStart[2],FragIndexNextStart[3]) ;
  xEvaluateBoundaries<5>(FragIndexNextStart[3],FragIndexNextStart[4]) ;
  xEvaluateBoundaries<6>(FragIndexNextStart[4],FragIndexNextStart[5]) ;
  xEvaluateBoundaries<7>(FragIndexNextStart[5],FragIndexNextStart[6]) ;
  xEvaluateBoundaries<8>(FragIndexNextStart[6],FragIndexNextStart[7]) ;
  // We have been collecting up 'radius squared'; convert all to radius
  ConvertToRadius(FragIndexNextStart[0],FragIndexNextStart[7]) ;
}
