/* Copyright 2001, 2019 IBM Corporation
 *
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the 
 * following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the 
 * following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the 
 * following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, 
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE 
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 package com.ibm.bluematter.db2probspec;

import java.sql.*;
import java.io.*;
import java.util.*;

import com.ibm.bluematter.db2probspec.parser.*;

public class P2Generator {			   

    

    public static void dump( FileWriter out ) throws IOException {
  out.write("#ifndef __P2__HPP__\n");
  out.write("#define __P2__HPP__\n");
  out.write("\n");
  out.write("#ifndef PKTRACE_PKMAIN_CNTL\n");
  out.write("#define PKTRACE_PKMAIN_CNTL (0)\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("#ifndef PKFXLOG_RESPA_STEPS\n");
  out.write("#define PKFXLOG_RESPA_STEPS 0\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("#ifndef PKFXLOG_INTEGRATOR_TRACE\n");
  out.write("#define PKFXLOG_INTEGRATOR_TRACE 0\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("\n");
// 	out.write("// #include <pk/platform.hpp>\n");
// 	out.write("// #include <pk/fxlogger.hpp>\n");
// 	out.write("\n");
// 	out.write("// #include <BlueMatter/XYZ.hpp>\n");
// 	out.write("// #include <BlueMatter/BoundingBox.hpp>\n");
// 	out.write("\n");
// 	out.write("// #include <BlueMatter/RunTimeGlobals.hpp>\n");
// 	out.write("// RunTimeGlobals RTG;\n");
// 	out.write("\n");
// 	out.write("// #include <BlueMatter/MSD_Prefix.hpp>\n");
// 	out.write("\n");
// 	out.write("// #include "UDF_BindingWrapper.hpp"\n");
// 	out.write("\n");
// 	out.write("// #include <BlueMatter/MDVM_IF.hpp>\n");
// 	out.write("\n");
// 	out.write("// #include "LocalTupleListDriver.hpp"\n");
// 	out.write("// #include "LocalFragmentDirectDriver.hpp"\n");
// 	out.write("\n");
  //	out.write("///////////////#include <BlueMatter/msd.hpp> <THIS IS THE MSD.CPP>\n");
// out.write("\n");
// out.write("// #include <BlueMatter/UDF_BindingWrapper.hpp>\n");
// out.write("\n");
// out.write("// #include <BlueMatter/MDVM_IF.hpp>\n");
// out.write("\n");
// out.write("// #include <BlueMatter/LocalTupleListDriver.hpp>\n");
// out.write("// #include <BlueMatter/LocalFragmentDirectDriver.hpp>\n");
// out.write("\n");
// out.write("////////////////////#include <BlueMatter/MSD_Wrapper.hpp>\n");
  out.write("\n");
  out.write("#include <BlueMatter/MSD_IF.hpp>\n");
  out.write("\n");
  out.write("#include <BlueMatter/RunTimeGlobalsInit.hpp>\n");
  out.write("\n");
//	out.write("#include <pk/AtomicOps.hpp>\n");
//	out.write("#include <pk/ThreadCreate.hpp>\n");
  out.write("\n");
//	out.write("#include <pk/Barrier.hpp>\n");
  out.write("#include <BlueMatter/random.hpp>\n");
  out.write("\n");
  out.write("// An evil global... moved here to be after the XYZ.hpp include\n");
  out.write("XYZ GlobalVirial;\n");
  out.write("\n");
  out.write("#include <fstream.h>\n");
  out.write("\n");
  out.write("#include <BlueMatter/SimulationParameters.hpp>\n");
  out.write("#include <BlueMatter/EnergyMonitorIF.hpp>\n");
  out.write("\n");
  out.write("#include <BlueMatter/DynamicVariableManager.hpp>\n");
  out.write("\n");
  out.write("#include <BlueMatter/PeriodicImage.hpp>\n");
  out.write("\n");
  out.write("#include <BlueMatter/RandomVelocity.hpp>\n");
  out.write("\n");
  out.write("\n");
  out.write("typedef TDynamicVariableManager< MSD::SiteIDtoSiteTypeMapSize,\n");
  out.write("                                 MSD::IrreduciblePartitionCount,\n");
  out.write("                                 MSD::NumberOfRespaLevels\n");
  out.write("                               > DynamicVariableManager;\n");
  out.write("\n");
  out.write("// More globals - not long for this world!\n");
  out.write("XYZ  *StartingVelocities;\n");
  out.write("XYZ  *StartingPositions;\n");
  out.write("\n");
  out.write("#include <BlueMatter/DVSFile.hpp>\n");
  out.write("#include <BlueMatter/NSQ.hpp>\n");
  out.write("\n");
  
  
  out.write("#ifndef MSDDEF_NO_LRF\n");
  out.write("typedef NSQAnchor<DynamicVariableManager,GeneralRealSpaceIFP> PNBE_TYPE;\n");
  out.write("PNBE_TYPE PNBE;\n");
  out.write("\n");
  out.write("#ifdef MSDDEF_EWALD\n");
  out.write("#include <BlueMatter/Ewald.hpp>\n");
  out.write("#include <BlueMatter/EwaldKSpaceEngine.hpp>\n");
  out.write("EwaldKSpaceAnchor<DynamicVariableManager,NBVM> Ewald_NBE;\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("#ifdef MSDDEF_P3ME\n");
  out.write("#include <BlueMatter/P3MEKSpaceEngine.hpp>\n");
  out.write("P3MEKSpaceAnchor<DynamicVariableManager,NBVM> P3ME_NBE;\n");
  out.write("#endif\n");
  out.write("#endif\n");
  out.write("\n");


  out.write("DynamicVariableManager DynVarMgrIF;\n");
  out.write("\n");
  out.write("// This thread will manage the work flow of a single voxel.\n");
  out.write("class VoxelManagerThreadArguments\n");
  out.write("  {\n");
  out.write("  public:\n");
  out.write("    int         VoxelId;\n");
  out.write("    BoundingBox VoxelBounds;\n");
  out.write("    Grid2D      mGrid2D;\n");
  out.write("  };\n");
  out.write("\n");
  out.write("#define VoxelCountCubeRoot (1) // there will be (VoxelCubeRoot ** 3) voxels\n");
  out.write("#define VoxelCount ( VoxelCountCubeRoot * VoxelCountCubeRoot * VoxelCountCubeRoot )\n");
  out.write("\n");
  out.write("// A simple arbitrary projection of the 3d cube to 2D grid?\n");
  out.write("#define RowCount (VoxelCountCubeRoot * VoxelCountCubeRoot )\n");
  out.write("#define ColCount (VoxelCountCubeRoot)\n");
  out.write("\n");
  out.write("int DoneFlag;\n");
  out.write("\n");
  out.write("ThreadBarrier PositionsReadyBarrier;\n");
  out.write("\n");
  out.write("void *\n");
  out.write("VoxelManagerThread( void* arg )\n");
  out.write("  {\n");
  out.write("  int VoxelInitialSiteCount = 0;\n");
  out.write("\n");
  out.write("  VoxelManagerThreadArguments *vmta = (VoxelManagerThreadArguments *) arg;\n");
  out.write("\n");
  out.write("  int VoxelId = vmta->VoxelId;\n");
  out.write("\n");
  out.write("  BegLogLine(1)\n");
  out.write("    << \"VoxelMangerThread Id:\"\n");
  out.write("    << vmta->VoxelId << \" \"\n");
  out.write("    << vmta->VoxelBounds.mMinBox\n");
  out.write("    << vmta->VoxelBounds.mMaxBox\n");
  out.write("    << EndLogLine;\n");
  out.write("\n");
  out.write("  BegLogLine(1)\n");
  out.write("    << \"VoxelThreadManager done setup \"\n");
  out.write("    << vmta->VoxelId\n");
  out.write("    << \" total sites \"\n");
  out.write("    << DynVarMgrIF.GetNumberOfSites()\n");
  out.write("    << \" VoxelBounds \"\n");
  out.write("    << vmta->VoxelBounds.mMinBox\n");
  out.write("    << \" \"\n");
  out.write("    << vmta->VoxelBounds.mMaxBox\n");
  out.write("    << EndLogLine;\n");
  out.write("\n");
  out.write("\n");
  out.write("  //*********************************************************************\n");
  out.write("  //*********************************************************************\n");
  out.write("\n");
  out.write("  unsigned PositionsReadyBarrierSeqNo = 0;\n");
  out.write("\n");
  out.write("  PositionsReadyBarrier.Wait( PositionsReadyBarrierSeqNo );\n");
  out.write("  PositionsReadyBarrierSeqNo++;\n");
  out.write("\n");
  out.write("  BegLogLine(0)\n");
  out.write("    << \"VoxelThread Exiting barrier \"\n");
  out.write("    << EndLogLine;\n");
  out.write("\n");
  out.write("  //*********************************************************************\n");
  out.write("  //*********************************************************************\n");
  out.write("\n");
  out.write("  // Dvs data has been globalized and so we'll fish through it here\n");
  out.write("  // picking out what this voxel needs to fly.\n");
  out.write("\n");
  out.write("  // These loops MUST have all the sites available in a single voxel.\n");
  out.write("  DynVarMgrIF.Init();\n");
  out.write("\n");
  out.write("  DynVarMgrIF.AllocateBlock( 0, MSD_IF::GetNumberOfSites() );\n");
  out.write("\n");
  out.write("  assert( MSD_IF::GetNumberOfSites() == DynVarMgrIF.GetNumberOfSites() );\n");
  out.write("\n");
  out.write("\n");
  out.write("  for( int SiteId = 0;\n");
  out.write("           SiteId < DynVarMgrIF.GetNumberOfSites();\n");
  out.write("           SiteId++ )\n");
  out.write("    {\n");
  out.write("    DynVarMgrIF.LoadDynamicVariables( SiteId,\n");
  out.write("                                            StartingPositions[ SiteId ],\n");
  out.write("                                            StartingVelocities[ SiteId ] );\n");
  out.write("    }\n");
  out.write("\n");
  out.write("\n");
  out.write("  MDVM dvsCheckMdvm;\n");
  out.write("  dvsCheckMdvm.Init();\n");
  out.write("  dvsCheckMdvm.SetSiteForRegMap( 0, 0 );\n");
  out.write("  dvsCheckMdvm.SetSiteForRegMap( 1, 1 );\n");
  out.write("\n");
  out.write("  for( int fragmentId1 = 0; fragmentId1 < DynVarMgrIF.GetIrreducibleFragmentCount(); fragmentId1++ )\n");
  out.write("    {\n");
  out.write("    int firstSiteId = DynVarMgrIF.GetNthIrreducibleFragmentFirstSiteIndex( fragmentId1 );\n");
  out.write("    for( int siteId = firstSiteId; siteId < DynVarMgrIF.GetNthIrreducibleFragmentSiteCount( fragmentId1 ); siteId++ )\n");
  out.write("      {\n");
  out.write("      for( int fragmentId2 = 0; fragmentId2 < DynVarMgrIF.GetIrreducibleFragmentCount(); fragmentId2++ )\n");
  out.write("        {\n");
  out.write("        int firstSiteId1 = DynVarMgrIF.GetNthIrreducibleFragmentFirstSiteIndex( fragmentId2 );\n");
  out.write("        for( int siteId1 = firstSiteId1; siteId1 < DynVarMgrIF.GetNthIrreducibleFragmentSiteCount( fragmentId2 ); siteId1++ )\n");
  out.write("          {\n");
  out.write("          if(siteId != siteId1)\n");
  out.write("            {\n");
  out.write("            dvsCheckMdvm.SetPositionRegister( MDVM::SiteA, DynVarMgrIF.GetPosition( siteId ));\n");
  out.write("            dvsCheckMdvm.SetPositionRegister( MDVM::SiteB, DynVarMgrIF.GetPosition( siteId1 ));\n");
  out.write("            ///////////////UDF_Binding::UDF_Execute(UDF_Binding::NSQCheckSitesInBox_Code, dvsCheckMdvm, NULL);\n");
  out.write("            UDF_Binding::UDF_NSQCheckSitesInBox_Execute( dvsCheckMdvm );\n");
  out.write("            }\n");
  out.write("          }\n");
  out.write("        }\n");
  out.write("      }\n");
  out.write("    }\n");
  out.write("\n");
  out.write("\n");
  out.write("  // This routine should probably contain everthing from here back to the Init() call.\n");
  out.write("  DynVarMgrIF.Load();\n");
  out.write("\n");
  out.write("\n");
  out.write("  int RespaLevel =\n");
  out.write("    MSD_IF::Access().NumberOfRespaLevels - 1;  // Change to Zero based index.\n");
  out.write("\n");
  out.write("  unsigned TimeStep = 0; // If respa is being used, this is the outer most timestep or lowest frequency iterator\n");
  out.write("  unsigned SimTick = 0;  // If respa is being used, this is the inner most timestep or highest frequency iterator\n");
  out.write("  unsigned LastSimTickOfTimeStepFlag = 1; // We begin as if initial conditions are the end of the last, possibly respa loop iter.\n");
  out.write("\n");
  out.write("  MSD_IF::ExpandSiteInfo();\n");
  out.write("\n");
  out.write("  MSD_IF::Init();\n");
  out.write("\n");
  out.write("  RTG.Init();\n");
  out.write("\n");
  out.write("  #if( MSDDEF_DoShakeRattle )\n");
  out.write("  //if( MSD_IF::Access().DoShakeRattle )\n");
  out.write("    {\n");
  out.write("	// MDVM_Controller.Run( RespaLevel, SimTick, MDVM_ManagerIF::DO_WATER_INIT);\n");
  out.write("    }\n");
  out.write("  #endif\n");
  out.write("\n");
  out.write("  //Spool throught the Fragments and report to log file\n");
  out.write("  for( int i = 0; i < MSD_IF::GetIrreducibleFragmentCount(); i++ )\n");
  out.write("    {\n");
  out.write("    for( int j = 0; j < MSD_IF::GetIrreducibleFragmentMemberSiteCount( i ); j++ )\n");
  out.write("      {\n");
  out.write("      BegLogLine(1)\n");
  out.write("        << \"Fragment \"\n");
  out.write("        << i\n");
  out.write("        << \" Site \"\n");
  out.write("        << j << \"/\" <<  MSD_IF::GetIrreducibleFragmentMemberSiteCount( i )\n");
  out.write("        << \" AbsSiteId \"\n");
  out.write("        << MSD_IF::GetIrreducibleFragmentMemberSiteId( i, j )\n");
  out.write("        << EndLogLine;\n");
  out.write("      }\n");
  out.write("    }\n");
  out.write("\n");
  out.write("#if MSDDEF_DoPressureControl //0\n");
  out.write("  MSD_TYPED_LFD_UpdateCenterOfMassDriver::Execute( DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("  //*********************************************************************\n");
  out.write("  //*********************************************************************\n");
  out.write("\n");
  out.write("  int i;\n");
  out.write("\n");
  out.write("  //******************************************************************\n");
  out.write("  //****   Set up for dynamics.\n");
  out.write("  //****   Since we have velocities, we need forces to enter the\n");
  out.write("  //****   main dynamics loop.  So, drive all relevant force generating\n");
  out.write("  //****   infrastructures to develop their force partial sums based\n");
  out.write("  //****   on current positions.\n");
  out.write("  //****   Note that the RespaLevel the force will be computed at\n");
  out.write("  //****   must be used in the call so that the forces will be placed\n");
  out.write("  //****   in the correct accumulator (and thus integrated with the\n");
  out.write("  //****   correct timestep for that level.  -1 drops force term out.)\n");
  out.write("  //******************************************************************\n");
  out.write("\n");
  out.write("  for ( i = 0; i < MSD_IF::Access().NumberOfRespaLevels; i++)\n");
  out.write("    {\n");
  out.write("    BegLogLine( 1 )\n");
  out.write("      << \"MSD_IF::Access().SimTicksAtRespaLevel[ \" << i << \" ]= \"\n");
  out.write("      << MSD_IF::Access().SimTicksAtRespaLevel[ i ]\n");
  out.write("      << EndLogLine;\n");
  out.write("    }\n");
  out.write("\n");
  out.write("  DynVarMgrIF.ZeroForceRegisters( 0, MSD_IF::Access().NumberOfRespaLevels - 1 );\n");
  out.write("\n");
  out.write("  XYZ InitialVirial;\n");
  out.write("  // This should later come from dvs...\n");
  out.write("  InitialVirial.Zero();\n");
  out.write("\n");
  out.write("  ///GlobalVirial = InitialVirial;\n");
  out.write("\n");
  out.write("  MSD_TYPED_LFD_UpdateKineticEnergyDriver::Execute( DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("\n");
  out.write("  MSD_TYPED_STD_BondedForceDriver::Init();\n");
  out.write("  MSD_TYPED_STD_BondedForceDriver::Execute(DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("\n");
  out.write("  ED_Emit_InformationRunTimeConfiguration( TimeStep,\n");
  out.write("                                           1u,       // Since the plimptonizer only works with 1 voxel right now\n");
  out.write("                                           1u );     // Total number of Nonbonded engines in use.\n");
  out.write("\n");
  out.write("  // Calculate and emit Constraint info\n");
  out.write("  int NumberOfCOMConstraints      = MSD_IF::Access().NumberOfCOMConstraints;\n");
  out.write("  int NumberOfAtoms               = MSD_IF::GetNumberOfSites();\n");
  out.write("  int NumberOfDegreesOfFreedom    = 3 * NumberOfAtoms - NumberOfCOMConstraints;\n");
  out.write("  ED_Emit_InformationConstraints( TimeStep, NumberOfCOMConstraints, NumberOfDegreesOfFreedom, 0 );\n");
  out.write("\n");
  out.write("\n");
  out.write("  // Bring up plimpton engines\n");
  out.write("  Grid2D PlimptonGrid;\n");
  out.write("  PlimptonGrid.MaximumNearSquareWithColumnsLonger();\n");
  out.write("\n");
  out.write("#ifndef MSDDEF_NO_LRF\n");
  out.write("  PNBE_TYPE::ClientIF  PlimptonClient;\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("#ifdef MSDDEF_EWALD\n");
  out.write("  EwaldKSpaceAnchor<DynamicVariableManager,NBVM>::ClientIF EwaldKSpaceClient;\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("#ifdef MSDDEF_P3ME\n");
  out.write("  P3MEKSpaceAnchor<DynamicVariableManager,NBVM>::ClientIF P3MEKSpaceClient;\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("\n");
  out.write("#ifndef MSDDEF_NO_LRF\n");
  out.write("  // if ( MSD_IF::Access().LongRangeForceMethod != PreMSD::NO_LRF )\n");
  out.write("    {\n");
  out.write("    /**\n");
  out.write("     *    Connect PlimptonEngine\n");
  out.write("     **/\n");
  out.write("    PNBE.Init();  //NEED: THIS IS GOD-AWFULL... MUST NOT HAVE TO DO THIS HERE!!!!!\n");
  out.write("    PlimptonClient = PNBE.GetClientIF();\n");
  out.write("\n");
  out.write("    PlimptonClient.Connect(\n");
  out.write("                           PlimptonGrid,\n");
  out.write("                           & DynVarMgrIF,\n");
  out.write("                           0,\n");
  out.write("                           MSD_IF::Access().RespaLevelNonBonded );\n");
  out.write("    }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("    // if ( MSD_IF::Access().LongRangeForceMethod == PreMSD::EWALD )\n");
  out.write("#ifdef MSDDEF_EWALD\n");
  out.write("    {\n");
  out.write("    /**\n");
  out.write("     *    Connect EwaldKspaceEngine\n");
  out.write("     **/\n");
  out.write("    Ewald_NBE.Init();  //NEED: THIS IS GOD-AWFULL... MUST NOT HAVE TO DO THIS HERE!!!!!\n");
  out.write("    EwaldKSpaceClient = Ewald_NBE.GetClientIF();\n");
  out.write("\n");
  out.write("    EwaldKSpaceClient.Connect(& DynVarMgrIF,\n");
  out.write("                              0,\n");
  out.write("                              MSD_IF::Access().SimTicksAtRespaLevel[ MSD_IF::Access().RespaLevelNonBonded ],\n");
  out.write("                              MSD_IF::Access().RespaLevelNonBonded );\n");
  out.write("    }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("    // if ( MSD_IF::Access().LongRangeForceMethod == PreMSD::P3ME )\n");
  out.write("#ifdef MSDDEF_P3ME\n");
  out.write("    {\n");
  out.write("    /**\n");
  out.write("     *    Connect P3MEKspaceEngine\n");
  out.write("     **/\n");
  out.write("    P3ME_NBE.Init();  //NEED: THIS IS GOD-AWFULL... MUST NOT HAVE TO DO THIS HERE!!!!!\n");
  out.write("    P3MEKSpaceClient = P3ME_NBE.GetClientIF();\n");
  out.write("\n");
  out.write("    P3MEKSpaceClient.Connect(& DynVarMgrIF,\n");
  out.write("                             0,\n");
  out.write("                             MSD_IF::Access().SimTicksAtRespaLevel[ MSD_IF::Access().RespaLevelNonBonded ],\n");
  out.write("                             MSD_IF::Access().RespaLevelNonBonded );\n");
  out.write("    }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("  if( MSD_IF::Access().RespaLevelNonBonded >= 0 )\n");
  out.write("    {\n");
  out.write("\n");
  out.write("#ifndef MSDDEF_NO_LRF\n");
  out.write("	// if( MSD_IF::Access().LongRangeForceMethod != PreMSD::NO_LRF )\n");
  out.write("      {\n");
  out.write("      BegLogLine(1) << \"VoxelThread Done Sending \" << EndLogLine;\n");
  out.write("      PlimptonClient.Send( 0 );\n");
  out.write("      BegLogLine(1) << \"VoxelThread Done Sending, Waiting \" << EndLogLine;\n");
  out.write("      PlimptonClient.Wait( 0 );\n");
  out.write("      BegLogLine(1) << \"VoxelThread Done Waiting \" << EndLogLine;\n");
  out.write("      }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("#ifdef MSDDEF_EWALD\n");
  out.write("      // if( MSD_IF::Access().LongRangeForceMethod == PreMSD::EWALD )\n");
  out.write("      {\n");
  out.write("      BegLogLine(1) << \"VoxelThread Done Sending \" << EndLogLine;\n");
  out.write("      EwaldKSpaceClient.Send( 0 );\n");
  out.write("      BegLogLine(1) << \"VoxelThread Done Sending, Waiting \" << EndLogLine;\n");
  out.write("      EwaldKSpaceClient.Wait( 0 );\n");
  out.write("      BegLogLine(1) << \"VoxelThread Done Waiting \" << EndLogLine;\n");
  out.write("      }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("#ifdef MSDDEF_P3ME\n");
  out.write("      // if( MSD_IF::Access().LongRangeForceMethod == PreMSD::P3ME )\n");
  out.write("      {\n");
  out.write("      BegLogLine(1) << \"VoxelThread Done Sending \" << EndLogLine;\n");
  out.write("      P3MEKSpaceClient.Send( 0 );\n");
  out.write("      BegLogLine(1) << \"VoxelThread Done Sending, Waiting \" << EndLogLine;\n");
  out.write("      P3MEKSpaceClient.Wait( 0 );\n");
  out.write("      BegLogLine(1) << \"VoxelThread Done Waiting \" << EndLogLine;\n");
  out.write("      }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("    }\n");
  out.write("\n");
  out.write("\n");
  out.write("  // Without the following, you'll be updating positions before their time!!\n");
  out.write("  PositionsReadyBarrier.Wait(PositionsReadyBarrierSeqNo++);\n");
  out.write("\n");
  out.write("  // The addition on a 3 is to account for the Kinetic Energy semi-UDF and LJ and charge\n");
  out.write("\n");
  out.write("  // Add another one if Ewald is used - do the same for PME\n");
  out.write("  ED_Emit_InformationUDFCount( 0, MSD_IF::GetNumberOfUDFsInUse() + 1 );// was 3\n");
  out.write("  // 2*(MSD_IF::Access().LongRangeForceMethod == PreMSD::EWALD));\n");
  out.write("\n");
  out.write("  DynVarMgrIF.ExportDynamicVariables( TimeStep );\n");
  out.write("\n");
  out.write("#if MSDDEF_DoPressureControl\n");
  out.write("  MSD_TYPED_LFD_UpdateFragmentKineticEnergyDriver::Execute( DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("  unsigned FrameContentsMask = 0;\n");
  out.write("\n");
  out.write("  FrameContentsMask |= FrameContents::Constraints;\n");
  out.write("\n");
  out.write("  //******************************************************************\n");
  out.write("  //****                   Initial virial and piston force\n");
  out.write("  //******************************************************************\n");
  out.write("\n");
  out.write("#if MSDDEF_DoPressureControl //0\n");
  out.write("  // Pressure Control global setup\n");
  out.write("//  if( MSD_IF::Access().DoPressureControl )\n");
  out.write("    {\n");
  out.write("    // GlobalVirial was set during NB force calculation\n");
  out.write("    DynVarMgrIF.mVirial.Zero();\n");
  out.write("\n");
  out.write("    // Here convert from atm to internal units\n");
  out.write("    DynVarMgrIF.mExternalPressure = MSD_IF::Access().PressureControlTarget * SciConst::Atm_IU;\n");
  out.write("\n");
  out.write("    // For now, each volume dimension is a scalar equal to the bounding box volume\n");
  out.write("    XYZ bbox = ((BoundingBox) MSD_IF::Access().BoundingBoxDef).GetDimensionVector();\n");
  out.write("    DynVarMgrIF.mVolume.mX = DynVarMgrIF.mVolume.mY = DynVarMgrIF.mVolume.mZ  =\n");
  out.write("        bbox.mX * bbox.mY * bbox.mZ;\n");
  out.write("\n");
  out.write("    // VolumeVelocity should come either from RTP, dvs, or randomization call\n");
  out.write("    // I guess RTP variable should be mPressureControlPistonVelocity\n");
  out.write("    // May need random seed in rtp file\n");
  out.write("    // Need separate temperature for piston velocity randomization?\n");
  out.write("    DynVarMgrIF.mVolumeVelocity.mX = DynVarMgrIF.mVolumeVelocity.mY = DynVarMgrIF.mVolumeVelocity.mZ =\n");
  out.write("      MSD_IF::Access().PressureControlPistonInitialVelocity;\n");
  out.write("\n");
  out.write("    DynVarMgrIF.mVolumeVelocityRatio.mX = DynVarMgrIF.mVolumeVelocityRatio.mY = DynVarMgrIF.mVolumeVelocityRatio.mZ =\n");
  out.write("      DynVarMgrIF.mVolumeVelocity.mX / DynVarMgrIF.mVolume.mX;\n");
  out.write("\n");
  out.write("    DynVarMgrIF.mVolumeMass = MSD_IF::Access().PressureControlPistonMass;\n");
  out.write("    FrameContentsMask |= FrameContents::Pressure;\n");
  out.write("    }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("  // Report initial conditions.  Two loops to make FXLOG line ordered on when no parallel.\n");
  out.write("  FrameContentsMask |= FrameContents::UDFs;\n");
  out.write("  FrameContentsMask |= FrameContents::Sites;\n");
  out.write("\n");
  out.write("  ED_Emit_InformationFrameContents( TimeStep, FrameContentsMask  );\n");
  out.write("  ED_Emit_ControlSyncId( eInvariantMagicNumber, 0, eVariableMagicNumber, eInvariantMagicNumber, 0 );\n");
  out.write("\n");
  out.write("  #if MSDDEF_DoPressureControl\n");
  out.write("    {\n");
  out.write("    DirectMDVM< DynamicVariableManager > D_MDVM( DynVarMgrIF );;\n");
  out.write("\n");
  out.write("    //////////UDF_Binding::UDF_Execute( UDF_Binding::UpdateVirialForce_Code,    D_MDVM, NULL );\n");
  out.write("    UDF_Binding::UDF_UpdateVirialForce_Execute( D_MDVM );\n");
  out.write("\n");
  out.write("    ED_Emit_ControlPressure( TimeStep,\n");
  out.write("                             DynVarMgrIF.mVirial,\n");
  out.write("                             DynVarMgrIF.mVolume,\n");
  out.write("                             DynVarMgrIF.mVolumeVelocity,\n");
  out.write("                             XYZ::ZERO_VALUE(),\n");
  out.write("                             DynVarMgrIF.mInternalPressure / SciConst::Atm_IU );\n");
  out.write("    }\n");
  out.write("  #endif\n");
  out.write("\n");
  out.write("\n");
  out.write("  //*************** Setup SimTick loop  *****************************\n");
  out.write("  // SimTicks are the highest frequency counter in the integrator.\n");
  out.write("  // Adding 1 to SimTick moves the simulation ahead 1 InnerTimeStep\n");
  out.write("  //******************************************************************\n");
  out.write("\n");
  out.write("\n");
  out.write("  BegLogLine( PKFXLOG_INTEGRATOR_TRACE )\n");
  out.write("    << \"Major Time Step Loop Initialization: \"\n");
  out.write("    << \" SimTick \"    << SimTick\n"); 
  out.write("    << \" TimeStep \"   << TimeStep\n");
  out.write("    << \" RespaLevel \" << RespaLevel\n"); 
  out.write("    << EndLogLine;\n");
  out.write("\n");
  out.write("  //NEED: shouldn't this block come out?????  If we are setting this above to outermost respa level, why this loop?\n");
  out.write("  while( ( SimTick % MSD_IF::Access().SimTicksAtRespaLevel[ RespaLevel ] ) != 0 )\n");
  out.write("    {\n");
  out.write("    RespaLevel--;\n");
  out.write("    assert( RespaLevel >= 0 );\n");
  out.write("    }\n");
  out.write("\n");
  out.write("  // Now, we begin to move on - raise a ruckus in the LOG.\n");
  out.write("  while( SimTick < MSD_IF::Access().NumberOfSimTicks )\n");
  out.write("    {\n");
  out.write("    BegLogLine(1)\n");
  out.write("      << \"TOP OF INTEGRATOR LOOP: VoxelId \" << VoxelId\n");
  out.write("      << \" SimTick \" << SimTick\n");
  out.write("      << \" TimeStep \"     << TimeStep\n");
  out.write("      << \" RespaLevel \" << RespaLevel\n");
  out.write("      << EndLogLine;\n");
  out.write("\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****                   Reset velocities if it's time\n");
  out.write("    //****  I'm assuming that we reset velocities AFTER reporting\n");
  out.write("    //****  energies, but I could easily be wrong.  Need to settle\n");
  out.write("    //****  this as we consider how to construct quasi-energy\n");
  out.write("    //****  invariants for constant temperature ensembles.\n");
  out.write("    //******************************************************************\n");
  out.write("\n");
  out.write("#if MSDDEF_DoPressureControl || MSDDEF_DoNVT\n");
  out.write("///    if(MSD_IF::Access().DoNVT || MSD_IF::Access().DoPressureControl)\n");
  out.write("      {\n");
  out.write("      // pull the resample_modulo away out of the constant representation to try to trick the comp out of /0\n");
  out.write("      int resample_modulo = MSD_IF::Access().VelocityResamplePeriodInOTS;\n");
  out.write("      if(    ( resample_modulo != 0  )\n");
  out.write("          &&\n");
  out.write("             ((TimeStep %resample_modulo ) == 0 )\n");
  out.write("          && (RespaLevel == MSD_IF::Access().NumberOfRespaLevels - 1) )\n");
  out.write("        {\n");
  out.write("        assert( RespaLevel == MSD_IF::Access().NumberOfRespaLevels - 1 );  // must be an outermost time step (?)\n");
  out.write("        BegLogLine(PKFXLOG_RESPA_STEPS)\n");
  out.write("            << \"RESPA VoxId \"      << VoxelId\n");
  out.write("            << \" SimTick \"         << SimTick\n");
  out.write("            << \" TimeStep \"        << TimeStep\n");
  out.write("            << \" Resampling Velocities \"\n");
  out.write("            << \" Target Temp \"     << MSD_IF::Access().VelocityResampleTargetTemperature\n");
  out.write("            << EndLogLine;\n");
  out.write("\n");
  out.write("        for(int s=0; s < DynVarMgrIF.GetNumberOfSites() ; s++)\n");
  out.write("          {\n");
  out.write("          //NEED: a frag should be able to carry it's rand seed!!!\n");
  out.write("          XYZ NewVelocity = RandomVelocity( MSD_IF::GetSiteInfo( s ).mass,\n");
  out.write("                                            MSD_IF::Access().VelocityResampleTargetTemperature );\n");
  out.write("          DynVarMgrIF.SetVelocity(s, NewVelocity );\n");
  out.write("          }\n");
  out.write("\n");
  out.write("        #if MSDDEF_DoShakeRattle\n");
  out.write("        // if( MSD_IF::Access().DoShakeRattle )\n");
  out.write("          {\n");
  out.write("	      // MDVM_Controller.Run( RespaLevel, SimTick, MDVM_ManagerIF::DO_UPDATE_VELOCITY_RATTLE );\n");
  out.write("          }\n");
  out.write("	#endif\n");
  out.write("\n");
  out.write("        // suits - for pressure control, need to recalc. COM info and KE here\n");
  out.write("        #if MSDDEF_DoPressureControl\n");
  out.write("        //NEED: to figure out why this call is made twice within the main loop\n");
  out.write("        MSD_TYPED_LFD_UpdateCenterOfMassAndFragmentKineticEnergyDriver::Execute( DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("        #endif\n");
  out.write("        }\n");
  out.write("      }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****                   Update Piston Velocity and Position\n");
  out.write("    //******************************************************************\n");
  out.write("#if MSDDEF_DoPressureControl\n");
  out.write("      {\n");
  out.write("      DirectMDVM< DynamicVariableManager > D_MDVM( DynVarMgrIF );\n");
  out.write("\n");
  out.write("      // udf should be called updatevolumevelocityhalfstep\n");
  out.write("      //////////////UDF_Binding::UDF_Execute( UDF_Binding::UpdateVolumeHalfStep_Code, D_MDVM, NULL );\n");
  out.write("      UDF_Binding::UDF_UpdateVolumeHalfStep_Execute( D_MDVM );\n");
  out.write("\n");
  out.write("      DynVarMgrIF.SetBoundingBoxDimensionVector( RTG.mBoundingBoxDimensionVector );\n");
  out.write("\n");
  out.write("      //////////////////UDF_Binding::UDF_Execute( UDF_Binding::UpdateVolumePosition_Code, D_MDVM, NULL );\n");
  out.write("      UDF_Binding::UDF_UpdateVolumePosition_Execute( D_MDVM );\n");
  out.write("\n");
  out.write("      DynVarMgrIF.UpdateRTGBoundingBoxProperties();\n");
  out.write("      }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****                   Velocity Half Step\n");
  out.write("    //******************************************************************\n");
  out.write("    for (i = 1; i < MSD_IF::Access().NumberOfRespaLevels; i++)\n");
  out.write("      {\n");
  out.write("      BegLogLine(PKFXLOG_RESPA_STEPS)\n");
  out.write("        << \" VoxelId \"    << VoxelId\n");
  out.write("        << \" SimTick \"    << SimTick\n");
  out.write("        << \" RespaLevel \" << RespaLevel\n");
  out.write("        << \" SimTick % MSD_IF::Access().SimTicksAtRespaLevel[ \" << i << \" ] \"\n");
  out.write("        << SimTick % MSD_IF::Access().SimTicksAtRespaLevel[ i ]\n");
  out.write("        << \" TOP UpdateVelocityHalfStep() \"\n");
  out.write("        << EndLogLine;\n");
  out.write("\n");
  out.write("      BegLogLine(PKFXLOG_RESPA_STEPS)\n");
  out.write("        << \" VoxelId \"    << VoxelId\n");
  out.write("        << \" SimTick \"    << SimTick\n");
  out.write("        << \" RespaLevel \" << RespaLevel\n");
  out.write("        << \" SimTick / MSD_IF::Access().SimTicksAtRespaLevel[ \" << i << \" ] \"\n");
  out.write("        << (int)(SimTick / MSD_IF::Access().SimTicksAtRespaLevel[ i ])\n");
  out.write("        << \" TOP UpdateVelocityHalfStep() \"\n");
  out.write("        << EndLogLine;\n");
  out.write("      }\n");
  out.write("\n");
  out.write("    MSD_TYPED_LFD_UpdateVelocityFirstHalfStepDriver::Execute( DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****                       SHAKE\n");
  out.write("    //******************************************************************\n");
  out.write("    //if( MSD_IF::Access().DoShakeRattle )\n");
  out.write("    #if (MSDDEF_DoShakeRattle )\n");
  out.write("    {\n");
  out.write("      // MDVM_Controller.Run( RespaLevel, SimTick, MDVM_ManagerIF::DO_UPDATE_POSITION_SHAKE );\n");
  out.write("    }\n");
  out.write("    #endif\n");
  out.write("    //******************************************************************\n");
  out.write("    //****                   Update Positions\n");
  out.write("    //******************************************************************\n");
  out.write("\n");
  out.write("    // Wait till everyone is done so you don't prematurely update your posit\n");
  out.write("    // NOTE: This barrier can be expressed as a wait on forces which is\n");
  out.write("    //       notably not a GLOBAL barrier.\n");
  out.write("    PositionsReadyBarrier.Wait(PositionsReadyBarrierSeqNo++);\n");
  out.write("\n");
  out.write("    BegLogLine(PKFXLOG_RESPA_STEPS)\n");
  out.write("      << \"RESPA VoxId \" << VoxelId\n");
  out.write("      << \" SimTick \"         << SimTick\n");
  out.write("      << \" TimeStep \"   << TimeStep\n");
  out.write("      << \" Current Respa Level \"  << RespaLevel\n");
  out.write("      << \" Calling UpdatePositions() \"\n");
  out.write("      << EndLogLine;\n");
  out.write("\n");
  out.write("    MSD_TYPED_LFD_UpdatePositionDriver::Execute( DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //***** Increment SimTick, the integrator's highest frequency counter.\n");
  out.write("    //******************************************************************\n");
  out.write("\n");
  out.write("    ++SimTick;\n");
  out.write("\n");
  out.write("    // Reset respa level\n");
  out.write("    RespaLevel = MSD_IF::Access().NumberOfRespaLevels - 1;  // Change to Zero based index.\n");
  out.write("    while( ( SimTick % MSD_IF::Access().SimTicksAtRespaLevel[ RespaLevel ] ) != 0 )\n");
  out.write("      {\n");
  out.write("      RespaLevel--;\n");
  out.write("      assert( RespaLevel >= 0 );\n");
  out.write("      }\n");
  out.write("\n");
  out.write("    // If on an OuterMostTimeStep, increment TimeStep counter\n");
  out.write("    if( RespaLevel == MSD_IF::Access().NumberOfRespaLevels - 1 )\n");
  out.write("      {\n");
  out.write("      TimeStep ++;\n");
  out.write("      LastSimTickOfTimeStepFlag = 1;\n");
  out.write("      }\n");
  out.write("    else\n");
  out.write("      {\n");
  out.write("      LastSimTickOfTimeStepFlag = 0;\n");
  out.write("      }\n");
  out.write("\n");
  out.write("    BegLogLine(1)\n");
  out.write("      << \"X*X*X*X SimTick++ X*X*X*X VoxelId \" << VoxelId\n");
  out.write("      << \" SimTick \"               << SimTick\n");
  out.write("      << \" TimeStep \"              << TimeStep\n");
  out.write("      << \" LastSimTickOfTimeStepFlag \" <<   LastSimTickOfTimeStepFlag\n");
  out.write("      << \" RespaLevel \"            << RespaLevel\n");
  out.write("      << EndLogLine;\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****       Check Positions in Voxel and Period Bounds\n");
  out.write("    //******************************************************************\n");
  out.write("#if 0\n");
  out.write("    // Every % x SimTicks, Scan for fragments deprating from this voxel\n");
  out.write("    // NEED to make sure that we at the end of an outermost timestep.\n");
  out.write("    if(  SimTick % 1 == 0 )\n");
  out.write("      {\n");
  out.write("      for( i = 0; i < VoxelFragmentCount; i++)\n");
  out.write("        {\n");
  out.write("        int Center = VoxelFragmentList[ i ].mCenter;\n");
  out.write("        //////////////////////// XYZ CenterPos = VoxelFragmentList[ i ].AccessPosition( Center ) ;\n");
  out.write("        // Check if it is time to switch voxels\n");
  out.write("        if( ! vmta->VoxelBounds.Contains( CenterPos ) )\n");
  out.write("          {\n");
  out.write("          BegLogLine(1)\n");
  out.write("            << \"RESPA **** NEED CODE TO MOVE THIS FRAGMENT TO ANOTHER VOXEL!!!!!\"\n");
  out.write("            << EndLogLine;\n");
  out.write("\n");
  out.write("          // If we move voxels, we might need to adjust periodic boundry coords\n");
  out.write("          if( ! MSD_IF::Access().BoundingBoxDef.Contains( CenterPos ) )\n");
  out.write("            {\n");
  out.write("            BegLogLine(1)\n");
  out.write("              << \"RESPA **** Need to take care min image !!!!!\"\n");
  out.write("              << EndLogLine;\n");
  out.write("            }\n");
  out.write("          }\n");
  out.write("        }\n");
  out.write("      }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****      Clear Force and Energy Registers for each Fragment\n");
  out.write("    //******************************************************************\n");
  out.write("\n");
  out.write("    BegLogLine(PKFXLOG_RESPA_STEPS)\n");
  out.write("      << \"VoxId \" << VoxelId\n");
  out.write("      << \" SimTick \"         << SimTick\n");
  out.write("      << \" TimeStep \"        << TimeStep\n");
  out.write("      << \" Current Respa Level \"  << RespaLevel\n");
  out.write("      << \" Zeroing Force and Energy Accumulators  \"\n");
  out.write("      << EndLogLine;\n");
  out.write("\n");
  out.write("#if MSDDEF_DoPressureControl\n");
  out.write("      {\n");
  out.write("      // prepare for global virial to accumulate based on new forces\n");
  out.write("      GlobalVirial.Zero();\n");
  out.write("      }\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****    Compute Forces Depending On Respa Level\n");
  out.write("    //******************************************************************\n");
  out.write("    // Scan for stuff to be driven by the Plimptonizer\n");
  out.write("    for( int rl = 0; rl <= RespaLevel; rl++ )\n");
  out.write("      {\n");
  out.write("\n");
  out.write("      int Plimp_OpMask =     0; // mightn't we use the plimp for multiple ops???\n");
  out.write("\n");
  out.write("      //NEED: to fix this ruthless hack which senses that non-bonded forces\n");
  out.write("      // have been turned of and emits a packet sending a 0 count of nonboned\n");
  out.write("      // force engines.\n");
  out.write("\n");
  out.write("      if( MSD_IF::Access().RespaLevelNonBonded < 0 )\n");
  out.write("        {\n");
  out.write("        if( LastSimTickOfTimeStepFlag )\n");
  out.write("          {\n");
  out.write("          ED_Emit_InformationRunTimeConfiguration( TimeStep,\n");
  out.write("                                                   1u,          // Since the plimptonizer only works with 1 voxel right now\n");
  out.write("                                                   1u );        // Total number of Nonbonded engines in use.\n");
  out.write("          }\n");
  out.write("        }\n");
  out.write("\n");
  out.write("      if( MSD_IF::Access().RespaLevelNonBonded == rl )\n");
  out.write("        {\n");
  out.write("        BegLogLine(PKFXLOG_RESPA_STEPS)\n");
  out.write("            << \"RESPA Plimpton \"\n");
  out.write("            << \" SimTick \"     << SimTick\n"); 
  out.write("            << \" RespaLevel \"  << RespaLevel\n");
  out.write("            << \" rl \"          << rl\n"); 
  out.write("            << EndLogLine;\n");
  out.write("\n");
  out.write("        #ifndef MSDDEF_NO_LRF \n");
  out.write("          {\n");
  out.write("          BegLogLine(1) << \"VoxelThread Done Sending \" << EndLogLine;\n");
  out.write("          PlimptonClient.Send( SimTick );\n");
  out.write("          BegLogLine(1) << \"VoxelThread Done Sending, Waiting \" << EndLogLine;\n"); 
  out.write("          PlimptonClient.Wait( SimTick );\n");
  out.write("          BegLogLine(1) << \"VoxelThread Done Waiting \" << EndLogLine;\n");
  out.write("          }\n");
  out.write("	#endif\n");
  out.write("\n");
  out.write("	  //if( MSD_IF::Access().LongRangeForceMethod == PreMSD::EWALD )\n");
  out.write("        #ifdef MSDDEF_EWALD\n");
  out.write("          {\n");
  out.write("          BegLogLine(1) << \"VoxelThread Done Sending \" << EndLogLine;\n");
  out.write("          EwaldKSpaceClient.Send( SimTick );\n");
  out.write("          BegLogLine(1) << \"VoxelThread Done Sending, Waiting \" << EndLogLine;\n"); 
  out.write("          EwaldKSpaceClient.Wait( SimTick );\n");
  out.write("          BegLogLine(1) << \"VoxelThread Done Waiting \" << EndLogLine;\n");
  out.write("          }\n");
  out.write("	#endif\n");
  out.write("\n");
  out.write("	  // if( MSD_IF::Access().LongRangeForceMethod == PreMSD::P3ME )\n");
  out.write("        #ifdef MSDDEF_P3ME\n");
  out.write("          {\n");
  out.write("          BegLogLine(1) << \"VoxelThread Done Sending \" << EndLogLine;\n");
  out.write("          P3MEKSpaceClient.Send( SimTick );\n");
  out.write("          BegLogLine(1) << \"VoxelThread Done Sending, Waiting \" << EndLogLine;\n"); 
  out.write("          P3MEKSpaceClient.Wait( SimTick );\n");
  out.write("          BegLogLine(1) << \"VoxelThread Done Waiting \" << EndLogLine;\n");
  out.write("          }\n");
  out.write("	#endif\n");
  out.write("        }\n");
  out.write("      }\n");
  out.write("\n");
  out.write("    MSD_TYPED_STD_BondedForceDriver::Execute(DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****                   Update Volume Velocity\n");
  out.write("    //******************************************************************\n");
  out.write("\n");
  out.write("    #if ( MSDDEF_DoPressureControl )\n");
  out.write("      {\n");
  out.write("      DirectMDVM< DynamicVariableManager > D_MDVM( DynVarMgrIF );\n");
  out.write("      UDF_UpdateVolumeVelocitySecondHalfStep_Execute( D_MDVM );\n");
  out.write("      }\n");
  out.write("    #endif\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****                   Velocity Half Step\n");
  out.write("    //******************************************************************\n");
  out.write("\n");
  out.write("    BegLogLine(PKFXLOG_RESPA_STEPS)\n");
  out.write("      << \"RESPA VoxId \" << VoxelId\n");
  out.write("      << \" TS \"         << TimeStep\n");
  out.write("      << \" Current Respa Level \"  << RespaLevel\n");
  out.write("      << \" Calling UpdateVelocityHalfStep \"\n");
  out.write("      << EndLogLine;\n");
  out.write("\n");
  out.write("    MSD_TYPED_LFD_UpdateVelocitySecondHalfStepDriver::Execute( DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("\n");
  out.write("    unsigned int contentMask = 0;\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****                       RATTLE\n");
  out.write("    //******************************************************************\n");
  out.write("\n");
  out.write("    #if( MSDDEF_DoShakeRattle )\n");
  out.write("    // if( MSD_IF::Access().DoShakeRattle )\n");
  out.write("	{\n");
  out.write("	    //MDVM_Controller.Run( RespaLevel, SimTick, MDVM_ManagerIF::DO_UPDATE_VELOCITY_RATTLE );\n");
  out.write("	}\n");
  out.write("    #endif\n");
  out.write("\n");
  out.write("    #if ( MSDDEF_DoPressureControl )\n");
  out.write("      {\n");
  out.write("      DynVarMgrIF.mVirial = GlobalVirial;   // GlobalVirial was set during NB force calculation\n");
  out.write("      contentMask |= FrameContents::Pressure;\n");
  out.write("      }\n");
  out.write("    #endif\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****          Update COM velocities, positions, and KE\n");
  out.write("    //******************************************************************\n");
  out.write("\n");
  out.write("    //NEED: to figure out why this call is made twice within the main loop\n");
  out.write("#if MSDDEF_DoPressureControl\n");
  out.write("    MSD_TYPED_LFD_UpdateCenterOfMassAndFragmentKineticEnergyDriver::Execute( DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    //****  Report Energy for on ticks that do outermost respa level\n");
  out.write("    //******************************************************************\n");
  out.write("\n");
  out.write("    contentMask |= FrameContents::UDFs;\n");
  out.write("\n");
  out.write("    #if ( MSDDEF_DoPressureControl )\n");
  out.write("      {\n");
  out.write("      DirectMDVM< DynamicVariableManager > D_MDVM( DynVarMgrIF );\n");
  out.write("\n");
  out.write("      ///////////////UDF_Binding::UDF_Execute( UDF_Binding::UpdateVirialForce_Code,    D_MDVM, NULL );\n");
  out.write("      UDF_Binding::UDF_UpdateVirialForce_Execute( D_MDVM );\n");
  out.write("\n");
  out.write("      // udf should be called updatevolumevelocityhalfstep\n");
  out.write("      /////////////////UDF_Binding::UDF_Execute( UDF_Binding::UpdateVolumeHalfStep_Code, D_MDVM, NULL );\n");
  out.write("      UDF_Binding::UDF_UpdateVolumeHalfStep_Execute( D_MDVM );\n");
  out.write("\n");
  out.write("      DynVarMgrIF.SetVolumeVelocityRatio( DynVarMgrIF.GetVolumeVelocityRatio() / DynVarMgrIF.GetVolumePosition().mX );\n");
  out.write("\n");
  out.write("      // Emit the pressure info prior to updating the volume info\n");
  out.write("      // Convert pressure back to atm here\n");
  out.write("      ED_Emit_ControlPressure( TimeStep, DynVarMgrIF.mVirial, DynVarMgrIF.mVolume,\n");
  out.write("                               DynVarMgrIF.mVolumeVelocity, XYZ::ZERO_VALUE(), DynVarMgrIF.mInternalPressure / SciConst::Atm_IU );\n");
  out.write("\n");
  out.write("      }\n");
  out.write("    #endif\n");
  out.write("\n");
  out.write("\n");
  out.write("    // Things to do on outermost timestep only!\n");
  out.write("    // Note, we may not export dynamic vars and/or energies on every\n");
  out.write("    // outer most timestep - or even on the same number of timesteps.\n");
  out.write("\n");
  out.write("    if( LastSimTickOfTimeStepFlag )\n");
  out.write("      {\n");
  out.write("      if(\n");
  out.write("         ( MSD_IF::Access().SnapshotPeriodInOTS > 0)\n");
  out.write("         && (\n");
  out.write("             ((TimeStep % MSD_IF::Access().SnapshotPeriodInOTS) == 0 )\n");
  out.write("             || (SimTick >= MSD_IF::Access().NumberOfSimTicks ) // or if it's the last time around.\n");
  out.write("             )\n");
  out.write("         )\n");
  out.write("        {\n");
  out.write("        BegLogLine(PKFXLOG_RESPA_STEPS)\n");
  out.write("          << \"RESPA VoxId \"      << VoxelId\n");
  out.write("          << \" SimTick \"         << SimTick\n");
  out.write("          << \" TimeStep \"             << TimeStep\n");
  out.write("          << \" Pushing snapshot data into External Datagram stream \"\n");
  out.write("          << EndLogLine;\n");
  out.write("\n");
  out.write("        // If we're get here then tell the packet server to expect sites.\n");
  out.write("        contentMask |= FrameContents::Sites;\n");
  out.write("        DynVarMgrIF.ExportDynamicVariables( TimeStep );\n");
  out.write("        }\n");
  out.write("\n");
  out.write("      if( LastSimTickOfTimeStepFlag )\n");
  out.write("        {\n");
  out.write("        ED_Emit_InformationFrameContents( TimeStep, contentMask );\n");
  out.write("\n");
  out.write("        ED_Emit_ControlSyncId( eInvariantMagicNumber, TimeStep, eVariableMagicNumber, eInvariantMagicNumber, 0 );\n");
  out.write("        }\n");
  out.write("\n");
  out.write("      if( 1 ) //NEED: logic to let RTP file control energy reporting rate.\n");
  out.write("        {\n");
  out.write("        if( LastSimTickOfTimeStepFlag )\n");
  out.write("          {\n");
  out.write("          MSD_TYPED_LFD_UpdateKineticEnergyDriver::Execute( DynVarMgrIF, SimTick, RespaLevel );\n");
  out.write("          }\n");
  out.write("        }\n");
  out.write("      }\n");
  out.write("\n");
  out.write("    if( LastSimTickOfTimeStepFlag )\n");
  out.write("      {\n");
  out.write("      ED_Emit_InformationUDFCount( TimeStep, MSD_IF::GetNumberOfUDFsInUse() + 1 ); // was 3\n");
  out.write("	  // 2*(MSD_IF::Access().LongRangeForceMethod == PreMSD::EWALD));\n");
  out.write("      }\n");
  out.write("\n");
  out.write("    //******************************************************************\n");
  out.write("    } // End of SimTick loop.\n");
  out.write("\n");
  out.write("  ED_Emit_InformationUDFCount( TimeStep, MSD_IF::GetNumberOfUDFsInUse() + 1); // was 3\n");
  out.write("  ED_Emit_ControlTheEnd( TimeStep );\n");
  out.write("\n");
  out.write("  MSD_IF::Finalize();\n");
  out.write("\n");
  out.write("  DoneFlag += 1;\n");
  out.write("  return(NULL);\n");
  out.write("  }\n");
  out.write("\n");
  out.write("//********************************************************************************\n");
  out.write("//********************************************************************************\n");
  out.write("//********************************************************************************\n");
  out.write("\n");
  out.write("// Figures out which voxels will be computed in this address space.\n");
  out.write("// There should be at least one voxel per address space. (though maybe no water mols)\n");
  out.write("// The voxels find out later what waters are assigned.\n");
  out.write("// There might be zero waters homed here - they may drift in later.\n");
  out.write("// Starts a VoxelManager for each voxel in homed in this address space.\n");
  out.write("// Assigns a single voxel thread to handle serial stuff.\n");
  out.write("//\n");
  out.write("//********************************************************************************\n");
  out.write("\n");
  out.write("//TraceClient PkMainStart;\n");
  out.write("void *\n");
  out.write("PkMain(int argc, char** argv, char** envp)\n");
  out.write("  {\n");
  out.write("//   PkMainStart.HitOE(     PKTRACE_PKMAIN_CNTL,\n");
  out.write("//                          ACT,\n");
  out.write("//                          \"PKMAIN_Cntl\",\n");
  out.write("//                          THREAD_NUM + 1,\n");
  out.write("//                          PkMainStart );\n");
  out.write("\n");
  out.write("  if( argc != 2 )\n");
  out.write("    fprintf(stderr, \"\n****** bad args.  use: %s <idv_fn> *********\n\", argv[0] );\n");
  out.write("\n");
  out.write("  assert( argc == 2 );  // must provide dynamic variable filename\n");
  out.write("\n");
  out.write("  //  msdFileName = argv[1];\n");
  out.write("\n");
  out.write("  BegLogLine(1)\n");
  out.write("    << argv[ 0 ]\n");
  out.write("    << \"::PkMain() running. \"\n");
  out.write("    << \"IDV Fn >\"\n"); 
  out.write("    << argv[1]\n");
  out.write("    << \"< \"\n");
  out.write("    << EndLogLine;\n");
  out.write("\n");
  out.write("  // Should do a global broadcast of initial conditions\n");
  out.write("  // unless they are compiled into the code itself.\n");
  out.write("\n");
  out.write("  DoneFlag = 0;\n");
  out.write("\n");
  out.write("  BegLogLine(1)\n");
  out.write("    << \" AtomicSet Done \"\n");
  out.write("    << EndLogLine;\n");
  out.write("\n");
  out.write("\n");
  out.write("  MSD_IF::AssignMSDPtr();\n");
  out.write("\n");
  out.write("  ED_Emit_InformationMolecularSystemDefinition\n");
  out.write("    (\n");
  out.write("     0,                                       //suits 0 simtick for now\n");
  out.write("     0u,                                      //const unsigned         &aMSDCheckSum,\n");
  out.write("     MSD_IF::GetNumberOfSites(),              //const unsigned         &aSiteCount,\n");
  out.write("     1u                                       //const unsigned         &aFragmentCount\n");
  out.write("     );\n");
  out.write("\n");
  out.write("  // Use filesystem to load DVS files.  Eventually, this will be handled via\n");
  out.write("  // External Datagram interface.\n");
  out.write("\n");
  out.write("  ReadDVSFile( -1, // A flag to take the first complete set of dynamic vars found in file.\n");
  out.write("               MSD_IF::GetNumberOfSites(),\n");
  out.write("               argv[ 1 ],\n");
  out.write("               MSD_IF::Access().BoundingBoxDef  );\n");
  out.write("\n");
  out.write("#if 0\n");
  out.write("  printf(\"VoxelCountCubeRoot %d for %d total voxels.\n\",\n");
  out.write("         VoxelCountCubeRoot, VoxelCount );\n");
  out.write("#endif\n");
  out.write("\n");
  out.write("  XYZ VoxelSize;\n");
  out.write("  VoxelSize.mX = RTG.mBoundingBoxDimensionVector.mX / VoxelCountCubeRoot;\n");
  out.write("  VoxelSize.mY = RTG.mBoundingBoxDimensionVector.mY / VoxelCountCubeRoot;\n");
  out.write("  VoxelSize.mZ = RTG.mBoundingBoxDimensionVector.mZ / VoxelCountCubeRoot;\n");
  out.write("\n");
  out.write("  BegLogLine(1)\n");
  out.write("    << \"Voxel physical \"\n");
  out.write("    << VoxelSize.mX << \" \"\n");
  out.write("    << VoxelSize.mY << \" \"\n"); 
  out.write("    << VoxelSize.mZ\n");
  out.write("    << EndLogLine;\n");
  out.write("\n");
  out.write("  int ProcessCount        =  Platform::Topology::GetAddressSpaceCount();\n");
  out.write("  int MaxVoxelsPerProcess = (VoxelCount + (ProcessCount-1)) / ProcessCount;\n");
  out.write("\n");
  out.write("  int AddressSpaceId = Platform::Topology::GetAddressSpaceId() ;\n");
  out.write("\n");
  out.write("  BegLogLine(1)\n");
  out.write("    << \"Machine size \"\n");
  out.write("    << \"ProcessCount=\" << ProcessCount\n");
  out.write("    << \" AddressSpaceId=\" << AddressSpaceId\n");
  out.write("    << EndLogLine ;\n");
  out.write("\n");
  out.write("  // NEED: MOST CONFIGURATOR FUNCTION SHOULD GO ABOUT HERE.\n");
  out.write("\n");
  out.write("  PositionsReadyBarrier.Init( VoxelCount );\n");
  out.write("  DoneFlag = 0;\n");
  out.write("\n");
  out.write("  // Figure out voxel bounds and start a manager thread for each voxel.\n");
  out.write("  for(int z=0; z < VoxelCountCubeRoot; z++ )\n");
  out.write("    {\n");
  out.write("    for(int y=0; y < VoxelCountCubeRoot; y++ )\n");
  out.write("      {\n");
  out.write("      for(int x=0; x < VoxelCountCubeRoot; x++ )\n");
  out.write("        {\n");
  out.write("        VoxelManagerThreadArguments a;\n");
  out.write("        a.VoxelId = x + y*VoxelCountCubeRoot + z*VoxelCountCubeRoot*VoxelCountCubeRoot;\n");
  out.write("\n");
  out.write("        // See if the voxel is located here, if so, start voxel manager.\n");
  out.write("        if( (a.VoxelId % ProcessCount) == AddressSpaceId )\n");
  out.write("          {\n");
  out.write("          BegLogLine(1) << \"AddressSpaceMgr Voxel \" << a.VoxelId << \" located here.\" << EndLogLine;\n");
  out.write("\n");
  out.write("          a.VoxelBounds.mMinBox.mX = MSD_IF::Access().BoundingBoxDef.mMinBox.mX + (x * VoxelSize.mX);\n");
  out.write("          a.VoxelBounds.mMinBox.mY = MSD_IF::Access().BoundingBoxDef.mMinBox.mY + (y * VoxelSize.mY);\n");
  out.write("          a.VoxelBounds.mMinBox.mZ = MSD_IF::Access().BoundingBoxDef.mMinBox.mZ + (z * VoxelSize.mZ);\n");
  out.write("          a.VoxelBounds.mMaxBox.mX = a.VoxelBounds.mMinBox.mX + VoxelSize.mX;\n");
  out.write("          a.VoxelBounds.mMaxBox.mY = a.VoxelBounds.mMinBox.mY + VoxelSize.mY;\n");
  out.write("          a.VoxelBounds.mMaxBox.mZ = a.VoxelBounds.mMinBox.mZ + VoxelSize.mZ;\n");
  out.write("\n");
  out.write("         BegLogLine(1)\n");
  out.write("           << \"Starting Voxel \" << a.VoxelId << \" Min \"\n");
  out.write("           << a.VoxelBounds.mMinBox.mX << \" \"\n");
  out.write("           << a.VoxelBounds.mMinBox.mY << \" \"\n"); 
  out.write("           << a.VoxelBounds.mMinBox.mZ\n");
  out.write("           << EndLogLine;\n");
  out.write("         BegLogLine(1)\n");
  out.write("           << \"Starting Voxel \" << a.VoxelId << \" Max \"\n");
  out.write("           << a.VoxelBounds.mMaxBox.mX << \" \"\n");
  out.write("           << a.VoxelBounds.mMaxBox.mY << \" \"\n"); 
  out.write("           << a.VoxelBounds.mMaxBox.mZ\n");
  out.write("           << EndLogLine;\n");
  out.write("\n");
  out.write("          // Use remote create (so args are copied to a buffer) to create thread.\n");
  out.write("         ThreadCreate( -1, VoxelManagerThread, sizeof( a ), &a );\n");
  out.write("          }\n");
  out.write("        }\n");
  out.write("      }\n");
  out.write("    }\n");
  out.write("\n");
  out.write("\n");
  out.write("\n");
  out.write("  BegLogLine(1)\n");
  out.write("    << \" After thread create loop \"\n");
  out.write("    << EndLogLine;\n");
  out.write("\n");
  out.write("  while( DoneFlag < VoxelCount )\n");
  out.write("    {\n");
  out.write("    Platform::Thread::Sleep(1);  // linux seems to halt the whole freeking process - what up wit dat?\n");
  out.write("//     PkMainStart.HitOE(     PKTRACE_PKMAIN_CNTL,\n");
  out.write("//                            ACT,\n");
  out.write("//                            \"PKMAIN_Cntl\",\n");
  out.write("//                            THREAD_NUM + 1,\n");
  out.write("//                            PkMainStart );\n");
  out.write("    }\n");
  out.write("  return(NULL);\n");
  out.write("  }\n");
  out.write("\n");
  out.write("#endif\n");
  out.write("\n");
  out.flush();
    }
}

